Directory structure:
└── gonzalezreal-swift-markdown-ui/
    ├── README.md
    ├── LICENSE
    ├── Makefile
    ├── Package.resolved
    ├── Package.swift
    ├── .spi.yml
    ├── .swiftformat
    ├── Examples/
    │   └── Demo/
    │       └── Demo/
    │           ├── CodeSyntaxHighlightView.swift
    │           ├── CodeView.swift
    │           ├── ContentView.swift
    │           ├── DemoApp.swift
    │           ├── DemoView.swift
    │           ├── DingusView.swift
    │           ├── HeadingsView.swift
    │           ├── ImageProvidersView.swift
    │           ├── ImagesView.swift
    │           ├── LazyLoadingView.swift
    │           ├── ListsView.swift
    │           ├── QuotesView.swift
    │           ├── RepositoryReadmeView.swift
    │           ├── TablesView.swift
    │           ├── TextStylesView.swift
    │           ├── Assets.xcassets/
    │           │   ├── Contents.json
    │           │   ├── AccentColor.colorset/
    │           │   │   └── Contents.json
    │           │   ├── AppIcon.appiconset/
    │           │   │   └── Contents.json
    │           │   ├── dog.imageset/
    │           │   │   └── Contents.json
    │           │   └── smallDog.imageset/
    │           │       └── Contents.json
    │           ├── Preview Content/
    │           │   └── Preview Assets.xcassets/
    │           │       └── Contents.json
    │           └── SyntaxHighlighter/
    │               ├── SplashCodeSyntaxHighlighter.swift
    │               └── TextOutputFormat.swift
    ├── Sources/
    │   └── MarkdownUI/
    │       ├── Documentation.docc/
    │       │   ├── MarkdownUI.md
    │       │   └── Articles/
    │       │       ├── GettingStarted.md
    │       │       └── MigratingToVersion2.md
    │       ├── DSL/
    │       │   ├── Blocks/
    │       │   │   ├── Blockquote.swift
    │       │   │   ├── BulletedList.swift
    │       │   │   ├── CodeBlock.swift
    │       │   │   ├── Heading.swift
    │       │   │   ├── ListContentBuilder.swift
    │       │   │   ├── ListItem.swift
    │       │   │   ├── MarkdownContent.swift
    │       │   │   ├── MarkdownContentBuilder.swift
    │       │   │   ├── NumberedList.swift
    │       │   │   ├── Paragraph.swift
    │       │   │   ├── TaskList.swift
    │       │   │   ├── TaskListContentBuilder.swift
    │       │   │   ├── TaskListItem.swift
    │       │   │   ├── TextTable.swift
    │       │   │   ├── TextTableColumn.swift
    │       │   │   ├── TextTableColumnAlignment.swift
    │       │   │   ├── TextTableColumnBuilder.swift
    │       │   │   ├── TextTableRow.swift
    │       │   │   ├── TextTableRowBuilder.swift
    │       │   │   └── ThematicBreak.swift
    │       │   └── Inlines/
    │       │       ├── Code.swift
    │       │       ├── Emphasis.swift
    │       │       ├── InlineContent.swift
    │       │       ├── InlineContentBuilder.swift
    │       │       ├── InlineImage.swift
    │       │       ├── InlineLink.swift
    │       │       ├── LineBreak.swift
    │       │       ├── SoftBreak.swift
    │       │       ├── Strikethrough.swift
    │       │       └── Strong.swift
    │       ├── Extensibility/
    │       │   ├── AssetImageProvider.swift
    │       │   ├── AssetInlineImageProvider.swift
    │       │   ├── CodeSyntaxHighlighter.swift
    │       │   ├── DefaultImageProvider.swift
    │       │   ├── DefaultInlineImageProvider.swift
    │       │   ├── ImageProvider.swift
    │       │   └── InlineImageProvider.swift
    │       ├── Parser/
    │       │   ├── BlockNode+Rewrite.swift
    │       │   ├── BlockNode.swift
    │       │   ├── HTMLTag.swift
    │       │   ├── InlineNode+Collect.swift
    │       │   ├── InlineNode+Rewrite.swift
    │       │   ├── InlineNode.swift
    │       │   └── MarkdownParser.swift
    │       ├── Renderer/
    │       │   ├── AttributedStringInlineRenderer.swift
    │       │   ├── InlineTextStyles.swift
    │       │   └── TextInlineRenderer.swift
    │       ├── Theme/
    │       │   ├── Theme+Basic.swift
    │       │   ├── Theme+DocC.swift
    │       │   ├── Theme+GitHub.swift
    │       │   ├── Theme.swift
    │       │   ├── BlockStyle/
    │       │   │   ├── BlockConfiguration.swift
    │       │   │   ├── BlockStyle.swift
    │       │   │   ├── CodeBlockConfiguration.swift
    │       │   │   ├── ListBullet.swift
    │       │   │   ├── ListMarkerConfiguration.swift
    │       │   │   ├── TableBackgroundStyle.swift
    │       │   │   ├── TableBorderStyle.swift
    │       │   │   ├── TableCellConfiguration.swift
    │       │   │   └── TaskListMarkerConfiguration.swift
    │       │   └── TextStyle/
    │       │       ├── TextStyle.swift
    │       │       ├── TextStyleBuilder.swift
    │       │       └── Styles/
    │       │           ├── BackgroundColor.swift
    │       │           ├── EmptyTextStyle.swift
    │       │           ├── Font+FontProperties.swift
    │       │           ├── FontCapsVariant.swift
    │       │           ├── FontDigitVariant.swift
    │       │           ├── FontFamily.swift
    │       │           ├── FontFamilyVariant.swift
    │       │           ├── FontProperties.swift
    │       │           ├── FontPropertiesAttribute.swift
    │       │           ├── FontSize.swift
    │       │           ├── FontStyle.swift
    │       │           ├── FontWeight.swift
    │       │           ├── FontWidth.swift
    │       │           ├── ForegroundColor.swift
    │       │           ├── StrikethroughStyle.swift
    │       │           ├── TextKerning.swift
    │       │           ├── TextTracking.swift
    │       │           └── UnderlineStyle.swift
    │       ├── Utility/
    │       │   ├── BlockNode+ColorSchemeImage.swift
    │       │   ├── Color+RGBA.swift
    │       │   ├── Deprecations.swift
    │       │   ├── FlowLayout.swift
    │       │   ├── Indexed.swift
    │       │   ├── InlineNode+PlainText.swift
    │       │   ├── InlineNode+RawImageData.swift
    │       │   ├── Int+Roman.swift
    │       │   ├── RelativeSize.swift
    │       │   ├── ResizeToFit.swift
    │       │   └── String+KebabCase.swift
    │       └── Views/
    │           ├── Markdown.swift
    │           ├── Blocks/
    │           │   ├── BlockMargin.swift
    │           │   ├── BlockNode+View.swift
    │           │   ├── BlockquoteView.swift
    │           │   ├── BlockSequence.swift
    │           │   ├── BulletedListView.swift
    │           │   ├── CodeBlockView.swift
    │           │   ├── ColumnWidthPreference.swift
    │           │   ├── HeadingView.swift
    │           │   ├── ImageFlow.swift
    │           │   ├── ListItemSequence.swift
    │           │   ├── ListItemView.swift
    │           │   ├── NumberedListView.swift
    │           │   ├── ParagraphView.swift
    │           │   ├── TableBackgroundView.swift
    │           │   ├── TableBorderSelector.swift
    │           │   ├── TableBorderView.swift
    │           │   ├── TableBounds.swift
    │           │   ├── TableCell.swift
    │           │   ├── TableView.swift
    │           │   ├── TaskListItemView.swift
    │           │   ├── TaskListView.swift
    │           │   ├── TextStyleAttributesReader.swift
    │           │   └── ThematicBreakView.swift
    │           ├── Environment/
    │           │   ├── Environment+BaseURL.swift
    │           │   ├── Environment+CodeSyntaxHighlighter.swift
    │           │   ├── Environment+ImageProvider.swift
    │           │   ├── Environment+InlineImageProvider.swift
    │           │   ├── Environment+List.swift
    │           │   ├── Environment+SoftBreakMode.swift
    │           │   ├── Environment+Table.swift
    │           │   ├── Environment+TextStyle.swift
    │           │   └── Environment+Theme.swift
    │           └── Inlines/
    │               ├── ImageView.swift
    │               └── InlineText.swift
    ├── Tests/
    │   └── MarkdownUITests/
    │       ├── FontPropertiesTests.swift
    │       ├── HTMLTagTests.swift
    │       ├── InlineContentBuilderTests.swift
    │       ├── ListContentBuilderTests.swift
    │       ├── MarkdownContentBuilderTests.swift
    │       ├── MarkdownContentTests.swift
    │       ├── MarkdownImageTests.swift
    │       ├── MarkdownListTests.swift
    │       ├── MarkdownTableTests.swift
    │       ├── MarkdownTests.swift
    │       ├── TaskListContentBuilderTests.swift
    │       ├── TextStyleBuilderTests.swift
    │       ├── ThemeDocCTests.swift
    │       ├── ThemeGitHubTests.swift
    │       ├── ThemePreview.swift
    │       └── Resources/
    │           └── Images.xcassets/
    │               ├── Contents.json
    │               ├── 237-100x150.imageset/
    │               │   └── Contents.json
    │               ├── 237-125x75.imageset/
    │               │   └── Contents.json
    │               └── 237-500x300.imageset/
    │                   └── Contents.json
    └── .github/
        ├── CODE_OF_CONDUCT.md
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.md
        │   └── config.yml
        └── workflows/
            ├── ci.yml
            └── format.yml

================================================
FILE: README.md
================================================
# MarkdownUI
[![CI](https://github.com/gonzalezreal/MarkdownUI/workflows/CI/badge.svg)](https://github.com/gonzalezreal/MarkdownUI/actions?query=workflow%3ACI)
[![](https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fgonzalezreal%2Fswift-markdown-ui%2Fbadge%3Ftype%3Dswift-versions)](https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui)
[![](https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fgonzalezreal%2Fswift-markdown-ui%2Fbadge%3Ftype%3Dplatforms)](https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui)

Display and customize Markdown text in SwiftUI.

* [Overview](#overview)
* [Minimum requirements](#minimum-requirements)
* [Getting started](#getting-started)
  * [Creating a Markdown view](#creating-a-markdown-view)
  * [Styling Markdown](#styling-markdown)
* [Documentation](#documentation)
  * [Related content](#related-content)
* [Demo](#demo)
* [Installation](#installation)

## Overview

MarkdownUI is a powerful library for displaying and customizing Markdown text in SwiftUI. It is
compatible with the [GitHub Flavored Markdown Spec](https://github.github.com/gfm/) and can
display images, headings, lists (including task lists), blockquotes, code blocks, tables,
and thematic breaks, besides styled text and links.

MarkdownUI offers comprehensible theming features to customize how it displays Markdown text.
You can use the built-in themes, create your own or override specific text and block styles.

![](Sources/MarkdownUI/Documentation.docc/Resources/MarkdownUI@2x.png#gh-light-mode-only)
![](Sources/MarkdownUI/Documentation.docc/Resources/MarkdownUI~dark@2x.png#gh-dark-mode-only)

## Minimum requirements

You can use MarkdownUI on the following platforms:

- macOS 12.0+
- iOS 15.0+
- tvOS 15.0+
- watchOS 8.0+

Some features, like displaying tables or multi-image paragraphs, require macOS 13.0+, iOS 16.0+,
tvOS 16.0+, and watchOS 9.0+.

## Getting started

### Creating a Markdown view

A `Markdown` view displays rich structured text using the Markdown syntax. It can display images,
headings, lists (including task lists), blockquotes, code blocks, tables, and thematic breaks,
besides styled text and links.

The simplest way of creating a `Markdown` view is to pass a Markdown string to the
`init(_:baseURL:imageBaseURL:)` initializer.

```swift
let markdownString = """
  ## Try MarkdownUI

  **MarkdownUI** is a native Markdown renderer for SwiftUI
  compatible with the
  [GitHub Flavored Markdown Spec](https://github.github.com/gfm/).
  """

var body: some View {
  Markdown(markdownString)
}
```

![](Sources/MarkdownUI/Documentation.docc/Resources/MarkdownString@2x.png#gh-light-mode-only)
![](Sources/MarkdownUI/Documentation.docc/Resources/MarkdownString~dark@2x.png#gh-dark-mode-only)

A more convenient way to create a `Markdown` view is by using the
`init(baseURL:imageBaseURL:content:)` initializer, which takes a Markdown content
builder in which you can compose the view content, either by providing Markdown strings or by
using an expressive domain-specific language.

```swift
var body: some View {
  Markdown {
    """
    ## Using a Markdown Content Builder
    Use Markdown strings or an expressive domain-specific language
    to build the content.
    """
    Heading(.level2) {
      "Try MarkdownUI"
    }
    Paragraph {
      Strong("MarkdownUI")
      " is a native Markdown renderer for SwiftUI"
      " compatible with the "
      InlineLink(
        "GitHub Flavored Markdown Spec",
        destination: URL(string: "https://github.github.com/gfm/")!
      )
      "."
    }
  }
}
```

![](Sources/MarkdownUI/Documentation.docc/Resources/MarkdownContentBuilder@2x.png#gh-light-mode-only)
![](Sources/MarkdownUI/Documentation.docc/Resources/MarkdownContentBuilder~dark@2x.png#gh-dark-mode-only)

You can also create a `MarkdownContent` value in your model layer and later create a `Markdown`
view by passing the content value to the `init(_:baseURL:imageBaseURL:)` initializer. The
`MarkdownContent` value pre-parses the Markdown string preventing the view from doing this step.

```swift
// Somewhere in the model layer
let content = MarkdownContent("You can try **CommonMark** [here](https://spec.commonmark.org/dingus/).")

// Later in the view layer
var body: some View {
  Markdown(self.model.content)
}
```

### Styling Markdown

Markdown views use a basic default theme to display the contents. For more information, read about
the `basic` theme.

```swift
Markdown {
  """
  You can quote text with a `>`.

  > Outside of a dog, a book is man's best friend. Inside of a
  > dog it's too dark to read.

  – Groucho Marx
  """
}
```

![](Sources/MarkdownUI/Documentation.docc/Resources/BlockquoteContent@2x.png#gh-light-mode-only)
![](Sources/MarkdownUI/Documentation.docc/Resources/BlockquoteContent~dark@2x.png#gh-dark-mode-only)

You can customize the appearance of Markdown content by applying different themes using the
`markdownTheme(_:)` modifier. For example, you can apply one of the built-in themes, like
`gitHub`, to either a Markdown view or a view hierarchy that contains Markdown views.

```swift
Markdown {
  """
  You can quote text with a `>`.

  > Outside of a dog, a book is man's best friend. Inside of a
  > dog it's too dark to read.

  – Groucho Marx
  """
}
.markdownTheme(.gitHub)
```

![](Sources/MarkdownUI/Documentation.docc/Resources/GitHubBlockquote@2x.png#gh-light-mode-only)
![](Sources/MarkdownUI/Documentation.docc/Resources/GitHubBlockquote~dark@2x.png#gh-dark-mode-only)

To override a specific text style from the current theme, use the `markdownTextStyle(_:textStyle:)`
modifier. The following example shows how to override the `code` text style.

```swift
Markdown {
  """
  Use `git status` to list all new or modified files
  that haven't yet been committed.
  """
}
.markdownTextStyle(\.code) {
  FontFamilyVariant(.monospaced)
  FontSize(.em(0.85))
  ForegroundColor(.purple)
  BackgroundColor(.purple.opacity(0.25))
}
```

![](Sources/MarkdownUI/Documentation.docc/Resources/CustomInlineCode@2x.png#gh-light-mode-only)
![](Sources/MarkdownUI/Documentation.docc/Resources/CustomInlineCode~dark@2x.png#gh-dark-mode-only)

You can also use the `markdownBlockStyle(_:body:)` modifier to override a specific block style. For
example, you can override only the `blockquote` block style, leaving other block styles untouched.

```swift
Markdown {
  """
  You can quote text with a `>`.

  > Outside of a dog, a book is man's best friend. Inside of a
  > dog it's too dark to read.

  – Groucho Marx
  """
}
.markdownBlockStyle(\.blockquote) { configuration in
  configuration.label
    .padding()
    .markdownTextStyle {
      FontCapsVariant(.lowercaseSmallCaps)
      FontWeight(.semibold)
      BackgroundColor(nil)
    }
    .overlay(alignment: .leading) {
      Rectangle()
        .fill(Color.teal)
        .frame(width: 4)
    }
    .background(Color.teal.opacity(0.5))
}
```

![](Sources/MarkdownUI/Documentation.docc/Resources/CustomBlockquote@2x.png#gh-light-mode-only)
![](Sources/MarkdownUI/Documentation.docc/Resources/CustomBlockquote~dark@2x.png#gh-dark-mode-only)

Another way to customize the appearance of Markdown content is to create your own theme. To create
a theme, start by instantiating an empty `Theme` and chain together the different text and block
styles in a single expression.

```swift
extension Theme {
  static let fancy = Theme()
    .code {
      FontFamilyVariant(.monospaced)
      FontSize(.em(0.85))
    }
    .link {
      ForegroundColor(.purple)
    }
    // More text styles...
    .paragraph { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.25))
        .markdownMargin(top: 0, bottom: 16)
    }
    .listItem { configuration in
      configuration.label
        .markdownMargin(top: .em(0.25))
    }
    // More block styles...
}
```

## Documentation

[Swift Package Index](https://swiftpackageindex.com) kindly hosts the online documentation for all versions, available here:

- [main](https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui/main/documentation/markdownui)
- [2.1.0](https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui/2.1.0/documentation/markdownui)
- [2.0.2](https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui/2.0.2/documentation/markdownui)

### Related content

You can learn more about MarkdownUI by referring to the following articles and third-party resources:

- [Better Markdown Rendering in SwiftUI](https://gonzalezreal.github.io/2023/02/18/better-markdown-rendering-in-swiftui.html)
- [Unlock the Power of Markdown in SwiftUI with THIS Hack!](https://youtu.be/gVy06iJQFWQ) by [@Rebeloper](https://twitter.com/Rebeloper)

## Demo

MarkdownUI comes with a few more tricks on the sleeve. You can explore the
[companion demo project](Examples/Demo/) and discover its complete set of capabilities.

![](Examples/Demo/Screenshot.png#gh-light-mode-only)
![](Examples/Demo/Screenshot~dark.png#gh-dark-mode-only)

## Installation
### Adding MarkdownUI to a Swift package

To use MarkdownUI in a Swift Package Manager project, add the following line to the dependencies in your `Package.swift` file:

```swift
.package(url: "https://github.com/gonzalezreal/swift-markdown-ui", from: "2.0.2")
```

Include `"MarkdownUI"` as a dependency for your executable target:

```swift
.target(name: "<target>", dependencies: [
  .product(name: "MarkdownUI", package: "swift-markdown-ui")
]),
```

Finally, add `import MarkdownUI` to your source code.

### Adding MarkdownUI to an Xcode project

1. From the **File** menu, select **Add Packages…**
1. Enter `https://github.com/gonzalezreal/swift-markdown-ui` into the
   *Search or Enter Package URL* search field
1. Link **MarkdownUI** to your application target



================================================
FILE: LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2020 Guillermo Gonzalez

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




================================================
FILE: Makefile
================================================
test-macos:
	xcodebuild test \
			-scheme MarkdownUI \
			-destination platform="macOS"

test-macos-maccatalyst:
	xcodebuild test \
			-scheme MarkdownUI \
			-destination platform="macOS,variant=Mac Catalyst"
			
test-ios:
	xcodebuild test \
			-scheme MarkdownUI \
			-destination platform="iOS Simulator,name=iPhone SE (3rd generation)"

test-tvos:
	xcodebuild test \
			-scheme MarkdownUI \
			-destination platform="tvOS Simulator,name=Apple TV"

test-watchos:
	xcodebuild test \
			-scheme MarkdownUI \
			-destination platform="watchOS Simulator,name=Apple Watch SE (40mm) (2nd generation)"

test: test-macos test-macos-maccatalyst test-ios test-tvos test-watchos

format:
	swift format --in-place --recursive .

.PHONY: format



================================================
FILE: Package.resolved
================================================
{
  "pins" : [
    {
      "identity" : "networkimage",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/gonzalezreal/NetworkImage",
      "state" : {
        "revision" : "7aff8d1b31148d32c5933d75557d42f6323ee3d1",
        "version" : "6.0.0"
      }
    },
    {
      "identity" : "swift-cmark",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/swiftlang/swift-cmark",
      "state" : {
        "revision" : "3ccff77b2dc5b96b77db3da0d68d28068593fa53",
        "version" : "0.5.0"
      }
    },
    {
      "identity" : "swift-snapshot-testing",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pointfreeco/swift-snapshot-testing",
      "state" : {
        "revision" : "26ed3a2b4a2df47917ca9b790a57f91285b923fb",
        "version" : "1.12.0"
      }
    }
  ],
  "version" : 2
}



================================================
FILE: Package.swift
================================================
// swift-tools-version:5.6

import PackageDescription

let package = Package(
  name: "swift-markdown-ui",
  platforms: [
    .macOS(.v12),
    .iOS(.v15),
    .tvOS(.v15),
    .macCatalyst(.v15),
    .watchOS(.v8),
  ],
  products: [
    .library(
      name: "MarkdownUI",
      targets: ["MarkdownUI"]
    )
  ],
  dependencies: [
    .package(url: "https://github.com/gonzalezreal/NetworkImage", from: "6.0.0"),
    .package(url: "https://github.com/pointfreeco/swift-snapshot-testing", from: "1.10.0"),
    .package(url: "https://github.com/swiftlang/swift-cmark", from: "0.4.0"),
  ],
  targets: [
    .target(
      name: "MarkdownUI",
      dependencies: [
        .product(name: "cmark-gfm", package: "swift-cmark"),
        .product(name: "cmark-gfm-extensions", package: "swift-cmark"),
        .product(name: "NetworkImage", package: "NetworkImage"),
      ]
    ),
    .testTarget(
      name: "MarkdownUITests",
      dependencies: [
        "MarkdownUI",
        .product(name: "SnapshotTesting", package: "swift-snapshot-testing"),
      ],
      exclude: ["__Snapshots__"]
    ),
  ]
)



================================================
FILE: .spi.yml
================================================
version: 1
builder:
  configs:
  - documentation_targets: [MarkdownUI]



================================================
FILE: .swiftformat
================================================
--wraparguments before-first
--wrapcollections before-first



================================================
FILE: Examples/Demo/Demo/CodeSyntaxHighlightView.swift
================================================
import MarkdownUI
import Splash
import SwiftUI

struct CodeSyntaxHighlightView: View {
  @Environment(\.colorScheme) private var colorScheme

  private let content = #"""
    This screen demonstrates how you can integrate a 3rd party library
    to render syntax-highlighted code blocks.

    First, we create a type that conforms to `CodeSyntaxHighlighter`,
    using [John Sundell's Splash](https://github.com/JohnSundell/Splash)
    to highlight code blocks.

    ```swift
    import MarkdownUI
    import Splash
    import SwiftUI

    struct SplashCodeSyntaxHighlighter: CodeSyntaxHighlighter {
      private let syntaxHighlighter: SyntaxHighlighter<TextOutputFormat>

      init(theme: Splash.Theme) {
        self.syntaxHighlighter = SyntaxHighlighter(format: TextOutputFormat(theme: theme))
      }

      func highlightCode(_ content: String, language: String?) -> Text {
        guard language != nil else {
          return Text(content)
        }

        return self.syntaxHighlighter.highlight(content)
      }
    }

    extension CodeSyntaxHighlighter where Self == SplashCodeSyntaxHighlighter {
      static func splash(theme: Splash.Theme) -> Self {
        SplashCodeSyntaxHighlighter(theme: theme)
      }
    }
    ```

    Then we configure the `Markdown` view to use the `SplashCodeSyntaxHighlighter`
    that we just created.

    ```swift
    var body: some View {
      Markdown(self.content)
        .markdownCodeSyntaxHighlighter(.splash(theme: .sunset(withFont: .init(size: 16))))
    }
    ```

    More languages to render:

    ```
    A plain code block without the specifying a language name.
    ```

    ```cpp
    #include <iostream>
    #include <vector>

    int main() {
        std::vector<std::string> fruits = {"apple", "banana", "orange"};
        for (const std::string& fruit : fruits) {
            std::cout << "I love " << fruit << "s!" << std::endl;
        }
        return 0;
    }
    ```

    ```typescript
    interface Person {
      name: string;
      age: number;
    }

    const person = Person();
    ```

    ```ruby
    fruits = ["apple", "banana", "orange"]
    fruits.each do |fruit|
      puts "I love #{fruit}s!"
    end
    ```

    """#

  var body: some View {
    DemoView {
      Markdown(self.content)
        .markdownBlockStyle(\.codeBlock) {
          codeBlock($0)
        }
        .markdownCodeSyntaxHighlighter(.splash(theme: self.theme))
    }
  }

  @ViewBuilder
  private func codeBlock(_ configuration: CodeBlockConfiguration) -> some View {
    VStack(spacing: 0) {
      HStack {
        Text(configuration.language ?? "plain text")
          .font(.system(.caption, design: .monospaced))
          .fontWeight(.semibold)
          .foregroundColor(Color(theme.plainTextColor))
        Spacer()

        Image(systemName: "clipboard")
          .onTapGesture {
            copyToClipboard(configuration.content)
          }
      }
      .padding(.horizontal)
      .padding(.vertical, 8)
      .background {
        Color(theme.backgroundColor)
      }

      Divider()

      ScrollView(.horizontal) {
        configuration.label
          .relativeLineSpacing(.em(0.25))
          .markdownTextStyle {
            FontFamilyVariant(.monospaced)
            FontSize(.em(0.85))
          }
          .padding()
      }
    }
    .background(Color(.secondarySystemBackground))
    .clipShape(RoundedRectangle(cornerRadius: 8))
    .markdownMargin(top: .zero, bottom: .em(0.8))
  }

  private var theme: Splash.Theme {
    // NOTE: We are ignoring the Splash theme font
    switch self.colorScheme {
    case .dark:
      return .wwdc17(withFont: .init(size: 16))
    default:
      return .sunset(withFont: .init(size: 16))
    }
  }

  private func copyToClipboard(_ string: String) {
    #if os(macOS)
      if let pasteboard = NSPasteboard.general {
        pasteboard.clearContents()
        pasteboard.setString(string, forType: .string)
      }
    #elseif os(iOS)
      UIPasteboard.general.string = string
    #endif
  }
}

struct CodeSyntaxHighlightView_Previews: PreviewProvider {
  static var previews: some View {
    CodeSyntaxHighlightView()
  }
}



================================================
FILE: Examples/Demo/Demo/CodeView.swift
================================================
import MarkdownUI
import SwiftUI

struct CodeView: View {
  private let content = #"""
    You can call out code or a command within a sentence with single backticks.
    The text within the backticks will not be formatted.

    ```
    Use `git status` to list all new or modified files that haven't yet been committed.
    ```

    Use `git status` to list all new or modified files that haven't yet been committed.

    To format code or text into its own distinct block, either use triple backticks
    (` ``` `) or indent each line by 4 spaces.

    ~~~
    After creating a group, any modifier you apply to the group affects
    all of that group’s members.

    ```swift
    Group {
        Text("SwiftUI")
        Text("Combine")
        Text("Swift System")
    }
    .font(.headline)
    ```
    ~~~

    After creating a group, any modifier you apply to the group affects
    all of that group’s members.

    ```swift
    Group {
        Text("SwiftUI")
        Text("Combine")
        Text("Swift System")
    }
    .font(.headline)
    ```
    """#

  var body: some View {
    DemoView {
      Markdown(self.content)
    }
  }
}

struct CodeView_Previews: PreviewProvider {
  static var previews: some View {
    CodeView()
  }
}



================================================
FILE: Examples/Demo/Demo/ContentView.swift
================================================
import SwiftUI

struct ContentView: View {
  var body: some View {
    NavigationView {
      Form {
        Section("Formatting") {
          NavigationLink {
            HeadingsView()
              .navigationTitle("Headings")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Headings", systemImage: "textformat.size")
          }
          NavigationLink {
            ListsView()
              .navigationTitle("Lists")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Lists", systemImage: "list.bullet")
          }
          NavigationLink {
            TextStylesView()
              .navigationTitle("Text Styles")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Text Styles", systemImage: "textformat.abc")
          }
          NavigationLink {
            QuotesView()
              .navigationTitle("Quotes")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Quotes", systemImage: "text.quote")
          }
          NavigationLink {
            CodeView()
              .navigationTitle("Code")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Code", systemImage: "curlybraces")
          }
          NavigationLink {
            ImagesView()
              .navigationTitle("Images")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Images", systemImage: "photo")
          }
          NavigationLink {
            TablesView()
              .navigationTitle("Tables")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Tables", systemImage: "tablecells")
          }
        }
        Section("Extensibility") {
          NavigationLink {
            CodeSyntaxHighlightView()
              .navigationTitle("Syntax Highlighting")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Syntax Highlighting", systemImage: "circle.grid.cross.left.filled")
          }
          NavigationLink {
            ImageProvidersView()
              .navigationTitle("Image Providers")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Image Providers", systemImage: "powerplug")
          }
        }
        Section("Other") {
          NavigationLink {
            DingusView()
              .navigationTitle("Dingus")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Dingus", systemImage: "character.cursor.ibeam")
          }
          NavigationLink {
            RepositoryReadmeView()
              .navigationTitle("Repository README")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Repository README", systemImage: "doc.text")
          }
          NavigationLink {
            LazyLoadingView()
              .navigationTitle("Lazy Loading")
              .navigationBarTitleDisplayMode(.inline)
          } label: {
            Label("Lazy Loading", systemImage: "scroll")
          }
        }
      }
      .navigationTitle("MarkdownUI")
    }
  }
}

struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
    ContentView()
  }
}



================================================
FILE: Examples/Demo/Demo/DemoApp.swift
================================================
import SwiftUI

@main
struct DemoApp: App {
  var body: some Scene {
    WindowGroup {
      ContentView()
    }
  }
}



================================================
FILE: Examples/Demo/Demo/DemoView.swift
================================================
import MarkdownUI
import SwiftUI

struct ThemeOption: Hashable {
  let name: String
  let theme: Theme

  static func == (lhs: ThemeOption, rhs: ThemeOption) -> Bool {
    lhs.name == rhs.name
  }

  func hash(into hasher: inout Hasher) {
    hasher.combine(self.name)
  }

  static let basic = ThemeOption(name: "Basic", theme: .basic)
  static let docC = ThemeOption(name: "DocC", theme: .docC)
  static let gitHub = ThemeOption(name: "GitHub", theme: .gitHub)
}

struct DemoView<Content: View>: View {
  private let themeOptions: [ThemeOption]
  private let about: MarkdownContent?
  private let content: Content

  @State private var themeOption = ThemeOption(name: "Basic", theme: .basic)

  init(
    themeOptions: [ThemeOption] = [.gitHub, .docC, .basic],
    @ViewBuilder content: () -> Content
  ) {
    self.themeOptions = themeOptions
    self.about = nil
    self.content = content()
  }

  init(
    themeOptions: [ThemeOption] = [.gitHub, .docC, .basic],
    @MarkdownContentBuilder about: () -> MarkdownContent,
    @ViewBuilder content: () -> Content
  ) {
    self.themeOptions = themeOptions
    self.about = about()
    self.content = content()
  }

  var body: some View {
    Form {
      if let about {
        Section {
          DisclosureGroup("About this demo") {
            Markdown {
              about
            }
          }
        }
      }

      if !self.themeOptions.isEmpty {
        Section {
          Picker("Theme", selection: $themeOption) {
            ForEach(self.themeOptions, id: \.self) { option in
              Text(option.name).tag(option)
            }
          }
        }
      }

      self.content
        .textSelection(.enabled)
        .markdownTheme(self.themeOption.theme)
        // Some themes may have a custom background color that we need to set as
        // the row's background color.
        .listRowBackground(self.themeOption.theme.textBackgroundColor)
        // By resetting the state when the theme changes, we avoid mixing the
        // the previous theme block spacing preferences with the new theme ones,
        // which can only happen in this particular use case.
        .id(self.themeOption.name)
    }
    .onAppear {
      self.themeOption = self.themeOptions.first ?? .basic
    }
  }
}

struct DemoView_Previews: PreviewProvider {
  static var previews: some View {
    DemoView {
      "Add some text **describing** what this demo is about."
    } content: {
      Markdown {
        Heading(.level2) {
          "Title"
        }
        "Show an awesome **MarkdownUI** feature!"
      }
    }

  }
}



================================================
FILE: Examples/Demo/Demo/DingusView.swift
================================================
import MarkdownUI
import SwiftUI

struct DingusView: View {
  @State private var markdown = """
    ## Try GitHub Flavored Markdown

    You can try **GitHub Flavored Markdown** here.  This dingus is powered
    by [MarkdownUI](https://github.com/gonzalezreal/MarkdownUI), a native
    Markdown renderer for SwiftUI.

    1. item one
    1. item two
       - sublist
       - sublist
    """

  var body: some View {
    DemoView {
      Section("Editor") {
        TextEditor(text: $markdown)
          .font(.system(.callout, design: .monospaced))
      }

      Section("Preview") {
        Markdown(self.markdown)
      }
    }
  }
}

struct DingusView_Previews: PreviewProvider {
  static var previews: some View {
    DingusView()
  }
}



================================================
FILE: Examples/Demo/Demo/HeadingsView.swift
================================================
import MarkdownUI
import SwiftUI

struct HeadingsView: View {
  private let content = """
    # Headings
    To create a heading, add one to size `#` symbols before your heading text.
    The number of `#` you use will determine the size of the heading:

    ```
    # The largest heading
    ## The second largest heading
    ###### The smallest heading
    ```

    # The largest heading
    ## The second largest heading
    ###### The smallest heading
    """

  var body: some View {
    DemoView {
      Markdown(self.content)

      Section("Customization Example") {
        Markdown("# One Big Header")
      }
      .markdownBlockStyle(\.heading1) { configuration in
        configuration.label
          .markdownMargin(top: .em(1), bottom: .em(1))
          .markdownTextStyle {
            FontFamily(.custom("Trebuchet MS"))
            FontWeight(.bold)
            FontSize(.em(2.5))
          }
      }
    }
  }
}

struct HeadingsView_Previews: PreviewProvider {
  static var previews: some View {
    HeadingsView()
  }
}



================================================
FILE: Examples/Demo/Demo/ImageProvidersView.swift
================================================
import MarkdownUI
import SDWebImageSwiftUI
import SwiftUI

struct ImageProvidersView: View {
  private let content = """
    You can tell a `Markdown` view to load images using a 3rd party library
    by configuring an `ImageProvider`. This example uses
    [**SDWebImage/SDWebImageSwiftUI**](https://github.com/SDWebImage/SDWebImageSwiftUI)
    to enable animated GIF rendering.

    ![](https://user-images.githubusercontent.com/373190/209442987-2aa9d73d-3bf2-46cb-b03a-5d9c0ab8475f.gif)
    """

  private let otherContent = """
    You can use the built-in `AssetImageProvider` and `AssetInlineImageProvider`
    to load images from image assets.

    ```swift
    Markdown {
      "![A dog](dog)"
      "A ![dog](smallDog) within a line of text."
      "― Photo by André Spieker"
    }
    .markdownImageProvider(.asset)
    .markdownInlineImageProvider(.asset)
    ```

    ![A dog](dog)

    An image ![dog](smallDog) within a line of text.

    ― Photo by André Spieker
    """

  var body: some View {
    DemoView {
      Markdown(self.content)
        .markdownImageProvider(.webImage)

      Section("Image Assets") {
        Markdown(self.otherContent)
          .markdownImageProvider(.asset)
          .markdownInlineImageProvider(.asset)
      }
    }
  }
}

struct ImageProvidersView_Previews: PreviewProvider {
  static var previews: some View {
    ImageProvidersView()
  }
}

// MARK: - WebImageProvider

struct WebImageProvider: ImageProvider {
  func makeImage(url: URL?) -> some View {
    ResizeToFit {
      WebImage(url: url)
        .resizable()
    }
  }
}

extension ImageProvider where Self == WebImageProvider {
  static var webImage: Self {
    .init()
  }
}

// MARK: - ResizeToFit

/// A layout that resizes its content to fit the container **only** if the content width is greater than the container width.
struct ResizeToFit: Layout {
  func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
    guard let view = subviews.first else {
      return .zero
    }

    var size = view.sizeThatFits(.unspecified)

    if let width = proposal.width, size.width > width {
      let aspectRatio = size.width / size.height
      size.width = width
      size.height = width / aspectRatio
    }
    return size
  }

  func placeSubviews(
    in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()
  ) {
    guard let view = subviews.first else { return }
    view.place(at: bounds.origin, proposal: .init(bounds.size))
  }
}



================================================
FILE: Examples/Demo/Demo/ImagesView.swift
================================================
import MarkdownUI
import SwiftUI

struct ImagesView: View {
  private let content = """
    You can display an image by adding `!` and wrapping the alt text in `[ ]`.
    Then wrap the link for the image in parentheses `()`.

    ```
    ![This is an image](https://picsum.photos/id/91/400/300)
    ```

    ![This is an image](https://picsum.photos/id/91/400/300)

    ― Photo by Jennifer Trovato
    """

  private let inlineImageContent = """
    You can also insert images in a line of text, such as
    ![](https://picsum.photos/id/237/50/25) or
    ![](https://picsum.photos/id/433/50/25).

    ```
    You can also insert images in a line of text, such as
    ![](https://picsum.photos/id/237/50/25) or
    ![](https://picsum.photos/id/433/50/25).
    ```

    Note that MarkdownUI **cannot** apply any styling to
    inline images.

    ― Photos by André Spieker and Thomas Lefebvre
    """

  var body: some View {
    DemoView {
      Markdown(self.content)

      Section("Inline images") {
        Markdown(self.inlineImageContent)
      }

      Section("Customization Example") {
        Markdown(self.content)
      }
      .markdownBlockStyle(\.image) { configuration in
        configuration.label
          .clipShape(RoundedRectangle(cornerRadius: 8))
          .shadow(radius: 8, y: 8)
          .markdownMargin(top: .em(1.6), bottom: .em(1.6))
      }
    }
  }
}

struct ImagesView_Previews: PreviewProvider {
  static var previews: some View {
    ImagesView()
  }
}



================================================
FILE: Examples/Demo/Demo/LazyLoadingView.swift
================================================
import MarkdownUI
import SwiftUI

struct LazyLoadingView: View {
  struct Item: Identifiable {
    let id = UUID()
    let content = MarkdownContent {
      Heading(.level2) {
        "Try MarkdownUI"
      }
      Paragraph {
        Strong("MarkdownUI")
        " is a native Markdown renderer for SwiftUI"
        " compatible with the "
        InlineLink(
          "GitHub Flavored Markdown Spec",
          destination: URL(string: "https://github.github.com/gfm/")!
        )
        "."
      }
      Paragraph {
        InlineImage(source: .randomImage())
      }
    }
  }

  private let about = """
    This screen demonstrates how you can use the `Markdown` view inside a `LazyVStack` and
    avoid re-layouts when scrolling up content. By using a custom `ImageProvider` that
    shows a placeholder while the image is loading and fixing the height of the images,
    you can avoid jumps and other weird effects caused by re-layouts when scrolling up.

    > Note that this applies only when you plan to show Markdown content with images inside
    > a `LazyVStack` or a `List`.
    """

  let items = Array(repeating: (), count: 100).map(Item.init)

  var body: some View {
    ScrollView {
      LazyVStack {
        DisclosureGroup("About this demo") {
          Markdown {
            self.about
          }
          .frame(maxWidth: .infinity, alignment: .leading)
        }
        ForEach(self.items) { item in
          Markdown(item.content)
            .padding()
        }
      }
      .padding()
    }
    .markdownTheme(.gitHub)
    // Comment this line to see the effect of having re-layouts while scrolling up.
    .markdownImageProvider(.lazyImage(aspectRatio: 4 / 3))
  }
}

struct LazyLoadingView_Previews: PreviewProvider {
  static var previews: some View {
    LazyLoadingView()
  }
}

struct LazyImageProvider: ImageProvider {
  let aspectRatio: CGFloat

  func makeImage(url: URL?) -> some View {
    AsyncImage(url: url) { phase in
      switch phase {
      case .empty, .failure:
        Color(.secondarySystemBackground)
      case .success(let image):
        image.resizable().scaledToFill()
      @unknown default:
        Color.clear
      }
    }
    .aspectRatio(self.aspectRatio, contentMode: .fill)
  }
}

extension ImageProvider where Self == LazyImageProvider {
  static func lazyImage(aspectRatio: CGFloat) -> Self {
    LazyImageProvider(aspectRatio: aspectRatio)
  }
}

extension URL {
  static func randomImage() -> URL {
    let id: String = [
      "11", "23", "26", "31", "34", "58", "63", "91", "103", "119",
    ].randomElement()!
    return URL(string: "https://picsum.photos/id/\(id)/400/300")!
  }
}



================================================
FILE: Examples/Demo/Demo/ListsView.swift
================================================
import MarkdownUI
import SwiftUI

struct ListsView: View {
  private let content = """
    You can make an unordered list by preceding one or more lines of text with `-`, `*`, or `+`.

    ```
    - George Washington
    - John Adams
    - Thomas Jefferson
    ```

    - George Washington
    - John Adams
    - Thomas Jefferson

    To order your list, precede each line with a number.

    ```
    1. James Madison
    2. James Monroe
    3. John Quincy Adams
    ```

    1. James Madison
    2. James Monroe
    3. John Quincy Adams

    ## Nested Lists

    You can create a nested list by indenting one or more list items below another item.

    ```
    1. First list item
       - First nested list item
         - Second nested list item
    ```

    1. First list item
       - First nested list item
         - Second nested list item

    ## Task lists

    To create a task list, preface list items with a hyphen and space followed by [ ].
    To mark a task as complete, use [x].

    ```
    - [x] Markdown rendering and styling
    - [ ] Documentation and sample code
    - [ ] Release MarkdownUI 2.0
    ```

    - [x] Markdown rendering and styling
    - [ ] Documentation and sample code
    - [ ] Release MarkdownUI 2.0

    Note that the `DocC` theme doesn't have a task list marker style and uses simple
    bullets.
    """

  private let customizedContent = """
    - George Washington
    - John Adams
    - Thomas Jefferson

    10. James Madison
    1. James Monroe
    1. John Quincy Adams

    - [x] Markdown rendering and styling
    - [ ] Documentation and sample code
    - [ ] Release MarkdownUI 2.0
    """

  var body: some View {
    DemoView {
      Markdown(self.content)

      Section("Customization Example") {
        Markdown(self.customizedContent)
      }
      .markdownBulletedListMarker(.dash)
      .markdownNumberedListMarker(.lowerRoman)
      .markdownBlockStyle(\.taskListMarker) { configuration in
        Image(systemName: configuration.isCompleted ? "checkmark.circle.fill" : "circle")
          .relativeFrame(minWidth: .em(1.5), alignment: .trailing)
      }
    }
  }
}

struct ListView_Previews: PreviewProvider {
  static var previews: some View {
    ListsView()
  }
}



================================================
FILE: Examples/Demo/Demo/QuotesView.swift
================================================
import MarkdownUI
import SwiftUI

struct QuotesView: View {
  let content = """
    You can quote text with a `>`.

    > Outside of a dog, a book is man's best friend. Inside of a
    > dog it's too dark to read.

    – Groucho Marx
    """

  var body: some View {
    DemoView {
      Markdown(self.content)

      Section("Customization Example") {
        Markdown(self.content)
      }
      .markdownBlockStyle(\.blockquote) { configuration in
        configuration.label
          .padding()
          .markdownTextStyle {
            FontCapsVariant(.lowercaseSmallCaps)
            FontWeight(.semibold)
            BackgroundColor(nil)
          }
          .overlay(alignment: .leading) {
            Rectangle()
              .fill(Color.teal)
              .frame(width: 4)
          }
          .background(Color.teal.opacity(0.5))
      }
    }
  }
}

struct BlockquotesView_Previews: PreviewProvider {
  static var previews: some View {
    QuotesView()
  }
}



================================================
FILE: Examples/Demo/Demo/RepositoryReadmeView.swift
================================================
import MarkdownUI
import SwiftUI

struct RepositoryReadmeView: View {
  private let about = """
    This screen demonstrates how **MarkdownUI** renders a GitHub repository's
    `README.md` file and how to implement a custom `OpenURLAction` that
    scrolls to the corresponding heading when the user taps on an anchor
    link.

    Additionally, it shows how to use an `ImageRenderer` to render the `README.md`
    file into a PDF.
    """

  @State private var owner = "apple"
  @State private var repo = "swift-format"

  var body: some View {
    Form {
      DisclosureGroup("About this demo") {
        Markdown {
          self.about
        }
      }

      Section("Repository") {
        TextField("Owner", text: $owner)
        TextField("Repo", text: $repo)
        NavigationLink {
          ReadmeView(owner: self.owner, repo: self.repo)
        } label: {
          Text("README.md")
        }
      }
      .autocapitalization(.none)
      .disableAutocorrection(true)
    }
  }
}

struct RepositoryReadmeView_Previews: PreviewProvider {
  static var previews: some View {
    RepositoryReadmeView()
  }
}

// MARK: - ReadmeView

private struct ReadmeView: View {
  let owner: String
  let repo: String

  private let client = RepositoryReadmeClient()

  @State private var response: RepositoryReadmeClient.Response?
  @State private var isLoading = true

  var body: some View {
    Group {
      if self.isLoading {
        ProgressView()
      } else {
        ScrollViewReader { proxy in
          ScrollView {
            content
              .scrollToMarkdownHeadings(using: proxy)
          }
        }
      }
    }
    .onAppear {
      self.loadContent()
    }
    .toolbar {
      if !self.isLoading {
        ShareLink(item: self.renderPDF())
      }
    }
  }

  private var content: some View {
    Group {
      if let response, let content = response.decodedContent {
        Markdown(content, baseURL: response.baseURL, imageBaseURL: response.imageBaseURL)
      } else {
        Markdown("Oops! Something went wrong while fetching the README file.")
      }
    }
    .padding()
    .background(Theme.gitHub.textBackgroundColor)
    .markdownTheme(.gitHub)
  }

  private func loadContent() {
    self.isLoading = true
    Task {
      self.response = try? await self.client.readme(owner: self.owner, repo: self.repo)
      self.isLoading = false
    }
  }

  @MainActor private func renderPDF() -> URL {
    let url = URL.documentsDirectory.appending(path: "README.pdf")
    let renderer = ImageRenderer(content: self.content.padding())
    renderer.proposedSize = .init(width: UIScreen.main.bounds.width, height: nil)

    renderer.render { size, render in
      var mediaBox = CGRect(origin: .zero, size: size)
      guard let context = CGContext(url as CFURL, mediaBox: &mediaBox, nil) else {
        return
      }

      context.beginPDFPage(nil)
      render(context)
      context.endPDFPage()
      context.closePDF()
    }

    return url
  }
}

// MARK: - Heading anchor scrolling

extension View {
  func scrollToMarkdownHeadings(using scrollViewProxy: ScrollViewProxy) -> some View {
    self.environment(
      \.openURL,
      OpenURLAction { url in
        guard let fragment = url.fragment?.lowercased() else {
          return .systemAction
        }
        withAnimation {
          scrollViewProxy.scrollTo(fragment, anchor: .top)
        }
        return .handled
      }
    )
  }
}

// MARK: - RepositoryReadmeClient

private struct RepositoryReadmeClient {
  struct Response: Codable {
    private enum CodingKeys: String, CodingKey {
      case content
      case htmlURL = "html_url"
      case downloadURL = "download_url"
    }

    let content: String
    let htmlURL: URL
    let downloadURL: URL

    var decodedContent: MarkdownContent? {
      Data(base64Encoded: self.content, options: .ignoreUnknownCharacters)
        .flatMap { String(decoding: $0, as: UTF8.self) }
        .map(MarkdownContent.init)
    }

    var baseURL: URL {
      self.htmlURL.deletingLastPathComponent()
    }

    var imageBaseURL: URL {
      self.downloadURL.deletingLastPathComponent()
    }
  }

  private let decoder = JSONDecoder()

  func readme(owner: String, repo: String) async throws -> Response {
    let (data, _) = try await URLSession.shared
      .data(from: URL(string: "https://api.github.com/repos/\(owner)/\(repo)/readme")!)
    return try self.decoder.decode(Response.self, from: data)
  }
}



================================================
FILE: Examples/Demo/Demo/TablesView.swift
================================================
import MarkdownUI
import SwiftUI

struct TablesView: View {
  let content = """
    You can create tables with pipes `|` and hyphens `-`. Hyphens are used to
    create each column's header, while pipes separate each column. You must
    include a blank line before your table for it to render correctly.

    ```
    | First Header  | Second Header |
    | ------------- | ------------- |
    | Content Cell  | Content Cell  |
    | Content Cell  | Content Cell  |
    ```

    | First Header  | Second Header |
    | ------------- | ------------- |
    | Content Cell  | Content Cell  |
    | Content Cell  | Content Cell  |

    ## Formatting content within your table

    You can use formatting such as links, inline code blocks, and text styling
    within your table:

    ```
    | Command | Description |
    | --- | --- |
    | `git status` | List all *new or modified* files |
    | `git diff` | Show file differences that **haven't been** staged |
    ```

    | Command | Description |
    | --- | --- |
    | `git status` | List all *new or modified* files |
    | `git diff` | Show file differences that **haven't been** staged |

    ## Further reading
    - [GitHub Flavored Markdown Spec](https://github.github.com/gfm/)
    """

  var body: some View {
    DemoView {
      Markdown(self.content)
    }
  }
}

struct TablesView_Previews: PreviewProvider {
  static var previews: some View {
    TablesView()
  }
}



================================================
FILE: Examples/Demo/Demo/TextStylesView.swift
================================================
import MarkdownUI
import SwiftUI

struct TextStylesView: View {
  private let content = """
    ```
    **This is bold text**
    ```
    **This is bold text**
    ```
    *This text is italicized*
    ```
    *This text is italicized*
    ```
    ~~This was mistaken text~~
    ```
    ~~This was mistaken text~~
    ```
    **This text is _extremely_ important**
    ```
    **This text is _extremely_ important**
    ```
    ***All this text is important***
    ```
    ***All this text is important***
    ```
    MarkdownUI is fully compliant with the [CommonMark Spec](https://spec.commonmark.org/current/).
    ```
    MarkdownUI is fully compliant with the [CommonMark Spec](https://spec.commonmark.org/current/).
    ```
    Visit https://github.com.
    ```
    Visit https://github.com.
    ```
    Use `git status` to list all new or modified files that haven't yet been committed.
    ```
    Use `git status` to list all new or modified files that haven't yet been committed.
    """

  var body: some View {
    DemoView {
      Markdown(self.content)

      Section("Customization Example") {
        Markdown(self.content)
      }
      .markdownTextStyle(\.code) {
        FontFamilyVariant(.monospaced)
        BackgroundColor(.yellow.opacity(0.5))
      }
      .markdownTextStyle(\.emphasis) {
        FontStyle(.italic)
        UnderlineStyle(.single)
      }
      .markdownTextStyle(\.strong) {
        FontWeight(.heavy)
      }
      .markdownTextStyle(\.strikethrough) {
        StrikethroughStyle(.init(pattern: .solid, color: .red))
      }
      .markdownTextStyle(\.link) {
        ForegroundColor(.mint)
        UnderlineStyle(.init(pattern: .dot))
      }
    }
  }
}

struct TextStylesView_Previews: PreviewProvider {
  static var previews: some View {
    TextStylesView()
  }
}



================================================
FILE: Examples/Demo/Demo/Assets.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Examples/Demo/Demo/Assets.xcassets/AccentColor.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Examples/Demo/Demo/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Examples/Demo/Demo/Assets.xcassets/dog.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "237-200x300.jpg",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Examples/Demo/Demo/Assets.xcassets/smallDog.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "237-30x40.jpg",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Examples/Demo/Demo/Preview Content/Preview Assets.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Examples/Demo/Demo/SyntaxHighlighter/SplashCodeSyntaxHighlighter.swift
================================================
import MarkdownUI
import Splash
import SwiftUI

struct SplashCodeSyntaxHighlighter: CodeSyntaxHighlighter {
  private let syntaxHighlighter: SyntaxHighlighter<TextOutputFormat>

  init(theme: Splash.Theme) {
    self.syntaxHighlighter = SyntaxHighlighter(format: TextOutputFormat(theme: theme))
  }

  func highlightCode(_ content: String, language: String?) -> Text {
    guard language != nil else {
      return Text(content)
    }

    return self.syntaxHighlighter.highlight(content)
  }
}

extension CodeSyntaxHighlighter where Self == SplashCodeSyntaxHighlighter {
  static func splash(theme: Splash.Theme) -> Self {
    SplashCodeSyntaxHighlighter(theme: theme)
  }
}



================================================
FILE: Examples/Demo/Demo/SyntaxHighlighter/TextOutputFormat.swift
================================================
import Splash
import SwiftUI

struct TextOutputFormat: OutputFormat {
  private let theme: Theme

  init(theme: Theme) {
    self.theme = theme
  }

  func makeBuilder() -> Builder {
    Builder(theme: self.theme)
  }
}

extension TextOutputFormat {
  struct Builder: OutputBuilder {
    private let theme: Theme
    private var accumulatedText: [Text]

    fileprivate init(theme: Theme) {
      self.theme = theme
      self.accumulatedText = []
    }

    mutating func addToken(_ token: String, ofType type: TokenType) {
      let color = self.theme.tokenColors[type] ?? self.theme.plainTextColor
      self.accumulatedText.append(Text(token).foregroundColor(.init(uiColor: color)))
    }

    mutating func addPlainText(_ text: String) {
      self.accumulatedText.append(
        Text(text).foregroundColor(.init(uiColor: self.theme.plainTextColor))
      )
    }

    mutating func addWhitespace(_ whitespace: String) {
      self.accumulatedText.append(Text(whitespace))
    }

    func build() -> Text {
      self.accumulatedText.reduce(Text(""), +)
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Documentation.docc/MarkdownUI.md
================================================
# ``MarkdownUI``

Display and customize Markdown text in SwiftUI.

## Overview

MarkdownUI is a powerful library for displaying and customizing Markdown text in SwiftUI. It is
compatible with the [GitHub Flavored Markdown Spec](https://github.github.com/gfm/) and can
display images, headings, lists (including task lists), blockquotes, code blocks, tables,
and thematic breaks, besides styled text and links.

MarkdownUI offers comprehensible theming features to customize how it displays Markdown text.
You can use the built-in themes, create your own or override specific text and block styles.

![A MarkdownUI view that displays a heading, paragraph, code block, and table using different themes](MarkdownUI)

## Topics

### Essentials

- <doc:GettingStarted>

### Upgrade guides

- <doc:MigratingToVersion2>

### Displaying Markdown

- ``Markdown``

### Customizing Appearance

- ``Theme``
- ``TextStyle``
- ``ForegroundColor``
- ``BackgroundColor``
- ``FontFamily``
- ``FontSize``
- ``FontStyle``
- ``FontWeight``
- ``FontWidth``
- ``StrikethroughStyle``
- ``UnderlineStyle``
- ``FontFamilyVariant``
- ``FontCapsVariant``
- ``FontDigitVariant``
- ``TextKerning``
- ``TextTracking``
- ``BlockStyle``
- ``BlockConfiguration``
- ``ListMarkerConfiguration``
- ``TaskListMarkerConfiguration``
- ``TableBackgroundStyle``
- ``TableBorderStyle``
- ``TableCellConfiguration``

### Formatting content

- ``MarkdownContent``
- ``Paragraph``
- ``Heading``
- ``Blockquote``
- ``CodeBlock``
- ``BulletedList``
- ``NumberedList``
- ``ListItem``
- ``TaskList``
- ``TaskListItem``
- ``TextTable``
- ``ThematicBreak``
- ``InlineContent``
- ``Code``
- ``Emphasis``
- ``Strong``
- ``Strikethrough``
- ``InlineImage``
- ``InlineLink``

### Extensibility

- ``ImageProvider``
- ``DefaultImageProvider``
- ``AssetImageProvider``
- ``CodeSyntaxHighlighter``
- ``PlainTextCodeSyntaxHighlighter``



================================================
FILE: Sources/MarkdownUI/Documentation.docc/Articles/GettingStarted.md
================================================
# Getting started

Learn how to display and style Markdown text in SwiftUI.

## Creating a Markdown view

A `Markdown` view displays rich structured text using the Markdown syntax. It can display images,
headings, lists (including task lists), blockquotes, code blocks, tables, and thematic breaks,
besides styled text and links.

The simplest way of creating a `Markdown` view is to pass a Markdown string to the
``Markdown/init(_:baseURL:imageBaseURL:)-63py1`` initializer.

```swift
let markdownString = """
  ## Try MarkdownUI

  **MarkdownUI** is a native Markdown renderer for SwiftUI
  compatible with the
  [GitHub Flavored Markdown Spec](https://github.github.com/gfm/).
  """

var body: some View {
  Markdown(markdownString)
}
```

![](MarkdownString)

A more convenient way to create a `Markdown` view is by using the
``Markdown/init(baseURL:imageBaseURL:content:)`` initializer, which takes a Markdown content
builder in which you can compose the view content, either by providing Markdown strings or by
using an expressive domain-specific language.

```swift
var body: some View {
  Markdown {
    """
    ## Using a Markdown Content Builder
    Use Markdown strings or an expressive domain-specific language
    to build the content.
    """
    Heading(.level2) {
      "Try MarkdownUI"
    }
    Paragraph {
      Strong("MarkdownUI")
      " is a native Markdown renderer for SwiftUI"
      " compatible with the "
      InlineLink(
        "GitHub Flavored Markdown Spec",
        destination: URL(string: "https://github.github.com/gfm/")!
      )
      "."
    }
  }
}
```

![](MarkdownContentBuilder)

You can also create a ``MarkdownContent`` value in your model layer and later create a `Markdown`
view by passing the content value to the ``Markdown/init(_:baseURL:imageBaseURL:)-42bru``
initializer. The ``MarkdownContent`` value pre-parses the Markdown string preventing the view from
doing this step.

```swift
// Somewhere in the model layer
let content = MarkdownContent("You can try **CommonMark** [here](https://spec.commonmark.org/dingus/).")

// Later in the view layer
var body: some View {
  Markdown(self.model.content)
}
```

## Styling Markdown

Markdown views use a basic default theme to display the contents. For more information, read about
the ``Theme/basic`` theme.

```swift
Markdown {
  """
  You can quote text with a `>`.

  > Outside of a dog, a book is man's best friend. Inside of a
  > dog it's too dark to read.

  – Groucho Marx
  """
}
```

![](BlockquoteContent)

You can customize the appearance of Markdown content by applying different themes using the
`markdownTheme(_:)` modifier. For example, you can apply one of the built-in themes, like
``Theme/gitHub``, to either a Markdown view or a view hierarchy that contains Markdown views.

```swift
Markdown {
  """
  You can quote text with a `>`.

  > Outside of a dog, a book is man's best friend. Inside of a
  > dog it's too dark to read.

  – Groucho Marx
  """
}
.markdownTheme(.gitHub)
```

![](GitHubBlockquote)

To override a specific text style from the current theme, use the `markdownTextStyle(_:textStyle:)`
modifier. The following example shows how to override the ``Theme/code`` text style.

```swift
Markdown {
  """
  Use `git status` to list all new or modified files
  that haven't yet been committed.
  """
}
.markdownTextStyle(\.code) {
  FontFamilyVariant(.monospaced)
  FontSize(.em(0.85))
  ForegroundColor(.purple)
  BackgroundColor(.purple.opacity(0.25))
}
```

![](CustomInlineCode)

You can also use the `markdownBlockStyle(_:body:)` modifier to override a specific block style. For
example, you can override only the ``Theme/blockquote`` block style, leaving other block styles
untouched.

```swift
Markdown {
  """
  You can quote text with a `>`.

  > Outside of a dog, a book is man's best friend. Inside of a
  > dog it's too dark to read.

  – Groucho Marx
  """
}
.markdownBlockStyle(\.blockquote) { configuration in
  configuration.label
    .padding()
    .markdownTextStyle {
      FontCapsVariant(.lowercaseSmallCaps)
      FontWeight(.semibold)
      BackgroundColor(nil)
    }
    .overlay(alignment: .leading) {
      Rectangle()
        .fill(Color.teal)
        .frame(width: 4)
    }
    .background(Color.teal.opacity(0.5))
}
```

![](CustomBlockquote)

Another way to customize the appearance of Markdown content is to create your own theme. To create
a theme, start by instantiating an empty ``Theme`` and chain together the different text and block
styles in a single expression.

```swift
extension Theme {
  static let fancy = Theme()
    .code {
      FontFamilyVariant(.monospaced)
      FontSize(.em(0.85))
    }
    .link {
      ForegroundColor(.purple)
    }
    // More text styles...
    .paragraph { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.25))
        .markdownMargin(top: 0, bottom: 16)
    }
    .listItem { configuration in
      configuration.label
        .markdownMargin(top: .em(0.25))
    }
    // More block styles...
}
```



================================================
FILE: Sources/MarkdownUI/Documentation.docc/Articles/MigratingToVersion2.md
================================================
# Migrating to MarkdownUI 2

Learn how to migrate existing apps using MarkdownUI 1.x to the latest version of the library.

## Overview

MarkdownUI 2 has been rewritten from scratch and brings a ton of new features and improvements
like:

- [GitHub Flavored Markdown](https://github.github.com/gfm/) (tables, task lists,
  strikethrough text, and autolinks)
- Native SwiftUI rendering
- Customization support via themes, text styles, and block styles.

These new features come with the cost of a few breaking changes that this guide will help you to
address.

## Minimum requirements

You can use MarkdownUI 2 on the following platforms:

- macOS 12.0+
- iOS 15.0+
- tvOS 15.0+
- watchOS 8.0+

Some features, like displaying tables or multi-image paragraphs, require macOS 13.0+, iOS 16.0+,
tvOS 16.0+, and watchOS 9.0+.

## Creating Markdown content

MarkdownUI 2 introduces a new domain-specific language to create Markdown content and no longer
depends on [gonzalezreal/SwiftCommonMark](https://github.com/gonzalezreal/SwiftCommonMark).

One significant difference when using MarkdownUI 2 is that ``MarkdownContent`` replaces `Document`
by providing similar functionality.

Another thing to be aware of is the different naming of some of the types you use to compose
Markdown content:

- Use ``Blockquote`` instead of `BlockQuote`.
- Use ``NumberedList`` instead of `OrderedList`.
- Use ``BulletedList`` instead of `BulletList`.
- Use ``InlineImage`` instead of `Image`.
- Use ``InlineLink`` instead of `Link`.
- Use ``Code`` instead of `InlineCode`.

## Loading asset images

MarkdownUI 2 introduces the ``ImageProvider`` protocol and its conforming types
``DefaultImageProvider`` and ``AssetImageProvider``. These types and the new
`markdownImageProvider(_:)` modifier replace the `MarkdownImageHandler` type and
the `setImageHandler(_:forURLScheme:)` modifier.

The following example shows how to configure the asset image provider to load images from the
main bundle.

```swift
Markdown {
  "![A dog](dog)"
  "― Photo by André Spieker"
}
.markdownImageProvider(.asset)
```

## Customizing link behavior

The `onOpenMarkdownLink(perform:)` modifier in MarkdownUI 1.x was provided to enable link behavior
customization in macOS 11.0, iOS 14.0, and tvOS 14.0. This modifier is no longer available in
MarkdownUI 2 since it does not support those platforms. However, you can customize the link
behavior by setting the `openURL` environment value with a custom `OpenURLAction`.

## Styling Markdown

MarkdownUI 1.x offered a few options to customize the content appearance. In contrast, MarkdownUI 2
brings the new ``Theme``, ``TextStyle``, and ``BlockStyle`` types that let you apply a custom
appearance to blocks and text inlines in a Markdown view.

Consequently, the `MarkdownStyle` type, all of its subtypes, and the `markdownStyle(_:)` modifier
are no longer available in MarkdownUI 2.



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/Blockquote.swift
================================================
import Foundation

/// A Markdown blockquote element.
///
/// Blockquote elements are typically used to quote text from another source.
///
/// ```swift
/// Markdown {
///   Blockquote {
///     Paragraph {
///       "Outside of a dog, a book is man's best friend."
///       "Inside of a dog, it's too dark to read."
///     }
///   }
///   Paragraph {
///     "– Groucho Marx"
///   }
/// }
/// ```
///
/// ![](BlockquoteContent)
public struct Blockquote: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.blockquote(children: content.blocks)])
  }

  private let content: MarkdownContent

  /// Creates a blockquote element that includes the specified Markdown content.
  /// - Parameter content: A Markdown content builder that returns the content included in the blockquote.
  public init(@MarkdownContentBuilder content: () -> MarkdownContent) {
    self.content = content()
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/BulletedList.swift
================================================
import Foundation

/// A Markdown bulleted list element.
///
/// You can create a bulleted list from a collection of elements.
///
/// ```swift
/// let headgear = ["Hats", "Caps", "Bonnets"]
///
/// var body: some View {
///   Markdown {
///     Paragraph {
///       "This is an incomplete list of headgear:"
///     }
///     BulletedList(of: headgear)
///   }
/// }
/// ```
///
/// ![](BulletedList)
///
/// To create a bulleted list from static items, you provide the items directly rather than the contents of a collection.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "This is an incomplete list of headgear:"
///   }
///   BulletedList {
///     "Hats"
///     "Caps"
///     "Bonnets"
///   }
/// }
/// ```
///
/// Use a ``ListItem`` element to nest a list inside a list item or have multi-paragraph list items.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "List of unusual units of measurement:"
///   }
///   BulletedList {
///     ListItem {
///       "Length"
///       BulletedList {
///         "Hammer unit"
///         "Rack unit"
///         "Hand"
///         ListItem {
///           "Earth"
///           BulletedList {
///             "Radius"
///           }
///         }
///       }
///     }
///   }
/// }
/// ```
///
/// ![](NestedBulletedList)
public struct BulletedList: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.bulletedList(isTight: self.tight, items: self.items)])
  }

  private let tight: Bool
  private let items: [RawListItem]

  init(tight: Bool, items: [ListItem]) {
    // Force loose spacing if any of the items contains more than one paragraph
    let hasItemsWithMultipleParagraphs = items.contains { item in
      item.children.filter(\.isParagraph).count > 1
    }

    self.tight = hasItemsWithMultipleParagraphs ? false : tight
    self.items = items.map(\.children).map(RawListItem.init)
  }

  /// Creates a bulleted list with the specified items.
  /// - Parameters:
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  ///   - items: A list content builder that returns the items included in the list.
  public init(tight: Bool = true, @ListContentBuilder items: () -> [ListItem]) {
    self.init(tight: tight, items: items())
  }

  /// Creates a bulleted list from a sequence of elements.
  /// - Parameters:
  ///   - sequence: The sequence of elements.
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  ///   - items: A list content builder that returns the items for each element in the sequence.
  public init<S: Sequence>(
    of sequence: S,
    tight: Bool = true,
    @ListContentBuilder items: (S.Element) -> [ListItem]
  ) {
    self.init(tight: tight, items: sequence.flatMap { items($0) })
  }

  /// Creates a bulleted list from a sequence of strings.
  /// - Parameters:
  ///   - sequence: The sequence of strings.
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  public init<S: Sequence>(of sequence: S, tight: Bool = true) where S.Element == String {
    self.init(tight: tight, items: sequence.map(ListItem.init(_:)))
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/CodeBlock.swift
================================================
import Foundation

/// A Markdown code block element.
///
/// Pre-formatted code blocks are used for writing about programming or markup source code.
/// Rather than forming normal paragraphs, the lines of a code block are interpreted literally.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "Use a group to collect multiple views into a single instance, "
///     "without affecting the layout of those views."
///   }
///   CodeBlock(language: "swift") {
///     """
///     Group {
///         Text("SwiftUI")
///         Text("Combine")
///         Text("Swift System")
///     }
///     .font(.headline)
///     """
///   }
/// }
/// ```
///
/// ![](CodeBlock)
public struct CodeBlock: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.codeBlock(fenceInfo: self.language, content: self.content)])
  }

  private let language: String?
  private let content: String

  public init(language: String? = nil, content: String) {
    self.language = language
    self.content = content
  }

  public init(language: String? = nil, content: () -> String) {
    self.init(language: language, content: content())
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/Heading.swift
================================================
import Foundation

/// A Markdown heading element.
///
/// You can use heading elements to display titles and subtitles or mark different sections in the content.
///
/// ```swift
/// Markdown {
///   Heading {
///     "The largest heading"
///   }
///   Heading(.level2) {
///     "The second largest heading"
///   }
///   Heading(.level6) {
///     "The smallest heading"
///   }
/// }
/// ```
///
/// ![](Heading)
public struct Heading: MarkdownContentProtocol {
  public enum Level: Int {
    case level1 = 1
    case level2 = 2
    case level3 = 3
    case level4 = 4
    case level5 = 5
    case level6 = 6
  }

  public var _markdownContent: MarkdownContent {
    .init(blocks: [.heading(level: self.level.rawValue, content: self.content.inlines)])
  }

  private let level: Level
  private let content: InlineContent

  /// Creates a heading element with the specified level and inline content.
  /// - Parameters:
  ///   - level: A level that determines the heading size.
  ///   - content: The inline content for the heading.
  public init(_ level: Level = .level1, @InlineContentBuilder content: () -> InlineContent) {
    self.level = level
    self.content = content()
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/ListContentBuilder.swift
================================================
import Foundation

/// A result builder that you can use to compose bulleted and numbered lists.
///
/// You don't call the methods of the result builder directly. Instead, Swift uses them to combine the elements
/// you declare in any closure with the `@ListContentBuilder` attribute. In particular, you rely on this
/// behavior when you declare the `content` inside a list element initializer such as
/// ``NumberedList/init(tight:start:items:)``.
@resultBuilder public enum ListContentBuilder {
  public static func buildBlock(_ components: [ListItem]...) -> [ListItem] {
    components.flatMap { $0 }
  }

  public static func buildExpression(_ expression: String) -> [ListItem] {
    [.init(expression)]
  }

  public static func buildExpression(_ expression: ListItem) -> [ListItem] {
    [expression]
  }

  public static func buildArray(_ components: [[ListItem]]) -> [ListItem] {
    components.flatMap { $0 }
  }

  public static func buildOptional(_ component: [ListItem]?) -> [ListItem] {
    component ?? []
  }

  public static func buildEither(first component: [ListItem]) -> [ListItem] {
    component
  }

  public static func buildEither(second component: [ListItem]) -> [ListItem] {
    component
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/ListItem.swift
================================================
import Foundation

/// A Markdown list item.
///
/// You can use list items to compose bulleted and numbered lists.
///
/// ```swift
/// Markdown {
///   NumberedList {
///     ListItem {
///       "Item one"
///       "Additional paragraph"
///     }
///     ListItem {
///       "Item two"
///       BulletedList {
///         "Subitem one"
///         "Subitem two"
///       }
///     }
///   }
/// }
/// ```
///
/// ![](ListItem)
public struct ListItem: Hashable {
  let children: [BlockNode]

  init(children: [BlockNode]) {
    self.children = children
  }

  init(_ text: String) {
    self.init(children: [.paragraph(content: [.text(text)])])
  }

  public init(@MarkdownContentBuilder content: () -> MarkdownContent) {
    self.init(children: content().blocks)
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/MarkdownContent.swift
================================================
import Foundation

/// A protocol that represents any Markdown content.
public protocol MarkdownContentProtocol {
  var _markdownContent: MarkdownContent { get }
}

/// A Markdown content value.
///
/// A Markdown content value consists of a sequence of blocks – structural elements like paragraphs, blockquotes, lists,
/// headings, thematic breaks, and code blocks. Some blocks, like blockquotes and list items, contain other blocks; others,
/// like headings and paragraphs, have inline text, links, emphasized text, etc.
///
/// You can create a Markdown content value by passing a Markdown-formatted string to ``init(_:)``.
///
/// ```swift
/// let content = MarkdownContent("You can try **CommonMark** [here](https://spec.commonmark.org/dingus/).")
/// ```
///
/// Alternatively, you can build a Markdown content value using a domain-specific language for blocks and inline text.
///
/// ```swift
/// let content = MarkdownContent {
///   Paragraph {
///     "You can try "
///     Strong("CommonMark")
///     SoftBreak()
///     InlineLink("here", destination: URL(string: "https://spec.commonmark.org/dingus/")!)
///     "."
///   }
/// }
/// ```
///
/// Once you have created a Markdown content value, you can display it using a ``Markdown`` view.
///
/// ```swift
/// var body: some View {
///   Markdown(self.content)
/// }
/// ```
///
/// A Markdown view also offers initializers that take a Markdown-formatted string ``Markdown/init(_:baseURL:imageBaseURL:)-63py1``,
/// or a Markdown content builder ``Markdown/init(baseURL:imageBaseURL:content:)``, so you don't need to create a
/// Markdown content value before displaying it.
///
/// ```swift
/// var body: some View {
///   VStack {
///     Markdown("You can try **CommonMark** [here](https://spec.commonmark.org/dingus/).")
///     Markdown {
///       Paragraph {
///         "You can try "
///         Strong("CommonMark")
///         SoftBreak()
///         InlineLink("here", destination: URL(string: "https://spec.commonmark.org/dingus/")!)
///         "."
///       }
///     }
///   }
/// }
/// ```
public struct MarkdownContent: Equatable, MarkdownContentProtocol {
  /// Returns a Markdown content value with the sum of the contents of all the container blocks
  /// present in this content.
  ///
  /// You can use this property to access the contents of a blockquote or a list. Returns `nil` if
  /// there are no container blocks.
  public var childContent: MarkdownContent? {
    let children = self.blocks.map(\.children).flatMap { $0 }
    return children.isEmpty ? nil : .init(blocks: children)
  }

  public var _markdownContent: MarkdownContent { self }
  let blocks: [BlockNode]

  init(blocks: [BlockNode] = []) {
    self.blocks = blocks
  }

  init(block: BlockNode) {
    self.init(blocks: [block])
  }

  init(_ components: [MarkdownContentProtocol]) {
    self.init(blocks: components.map(\._markdownContent).flatMap(\.blocks))
  }

  /// Creates a Markdown content value from a Markdown-formatted string.
  /// - Parameter markdown: A Markdown-formatted string.
  public init(_ markdown: String) {
    self.init(blocks: .init(markdown: markdown))
  }

  /// Creates a Markdown content value composed of any number of blocks.
  /// - Parameter content: A Markdown content builder that returns the blocks that form the Markdown content.
  public init(@MarkdownContentBuilder content: () -> MarkdownContent) {
    self.init(blocks: content().blocks)
  }

  /// Renders this Markdown content value as a Markdown-formatted text.
  public func renderMarkdown() -> String {
    let result = self.blocks.renderMarkdown()
    return result.hasSuffix("\n") ? String(result.dropLast()) : result
  }

  /// Renders this Markdown content value as plain text.
  public func renderPlainText() -> String {
    let result = self.blocks.renderPlainText()
    return result.hasSuffix("\n") ? String(result.dropLast()) : result
  }

  /// Renders this Markdown content value as HTML code.
  public func renderHTML() -> String {
    self.blocks.renderHTML()
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/MarkdownContentBuilder.swift
================================================
import Foundation

/// A result builder that you can use to compose Markdown content.
///
/// You don't call the methods of the result builder directly. Instead, Swift uses them to combine the elements
/// you declare in any closure with the `@MarkdownContentBuilder` attribute. In particular, you rely on
/// this behavior when you declare the `content` inside a Markdown view initializer such as
/// ``Markdown/init(baseURL:imageBaseURL:content:)``.
@resultBuilder public enum MarkdownContentBuilder {
  public static func buildBlock(_ components: MarkdownContentProtocol...) -> MarkdownContent {
    .init(components)
  }

  public static func buildExpression(_ expression: MarkdownContentProtocol) -> MarkdownContent {
    expression._markdownContent
  }

  public static func buildExpression(_ expression: String) -> MarkdownContent {
    .init(expression)
  }

  public static func buildArray(_ components: [MarkdownContentProtocol]) -> MarkdownContent {
    .init(components)
  }

  public static func buildOptional(_ component: MarkdownContentProtocol?) -> MarkdownContent {
    component?._markdownContent ?? .init()
  }

  public static func buildEither(first component: MarkdownContentProtocol) -> MarkdownContent {
    component._markdownContent
  }

  public static func buildEither(second component: MarkdownContentProtocol) -> MarkdownContent {
    component._markdownContent
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/NumberedList.swift
================================================
import Foundation

/// A Markdown numbered list element.
///
/// You can create numbered lists from a collection of elements.
///
/// ```swift
/// let headgear = ["Hats", "Caps", "Bonnets"]
///
/// var body: some View {
///   Markdown {
///     Paragraph {
///       "This is an incomplete list of headgear:"
///     }
///     NumberedList(of: headgear)
///   }
/// }
/// ```
///
/// ![](NumberedList)
///
/// To create a numbered list from static items, you provide the items directly rather than a collection.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "This is an incomplete list of headgear:"
///   }
///   NumberedList {
///     "Hats"
///     "Caps"
///     "Bonnets"
///   }
/// }
/// ```
///
/// Use a ``ListItem`` element to nest a list inside a list item or have multi-paragraph list items.
///
/// ```swift
/// Markdown {
///   NumberedList {
///     ListItem {
///       "Item one"
///       "Additional paragraph"
///     }
///     ListItem {
///       "Item two"
///       BulletedList {
///         "Subitem one"
///         "Subitem two"
///       }
///     }
///   }
/// }
/// ```
///
/// ![](ListItem)
public struct NumberedList: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.numberedList(isTight: self.tight, start: self.start, items: self.items)])
  }

  private let tight: Bool
  private let start: Int
  private let items: [RawListItem]

  init(tight: Bool, start: Int, items: [ListItem]) {
    // Force loose spacing if any of the items contains more than one paragraph
    let hasItemsWithMultipleParagraphs = items.contains { item in
      item.children.filter(\.isParagraph).count > 1
    }
    self.tight = hasItemsWithMultipleParagraphs ? false : tight
    self.start = start
    self.items = items.map(\.children).map(RawListItem.init)
  }

  /// Creates a numbered list with the specified items.
  /// - Parameters:
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  ///   - start: The start number for this list.
  ///   - items: A list content builder that returns the items included in the list.
  public init(tight: Bool = true, start: Int = 1, @ListContentBuilder items: () -> [ListItem]) {
    self.init(tight: tight, start: start, items: items())
  }

  /// Creates a numbered list from a sequence of elements.
  /// - Parameters:
  ///   - sequence: The sequence of elements.
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  ///   - start: The start number for this list.
  ///   - items: A list content builder that returns the items for each element in the sequence.
  public init<S: Sequence>(
    of sequence: S,
    tight: Bool = true,
    start: Int = 1,
    @ListContentBuilder items: (S.Element) -> [ListItem]
  ) {
    self.init(tight: tight, start: start, items: sequence.flatMap { items($0) })
  }

  /// Creates a numbered list from a sequence of strings.
  /// - Parameters:
  ///   - sequence: The sequence of strings.
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  ///   - start: The start number for this list.
  public init<S: Sequence>(
    of sequence: S,
    tight: Bool = true,
    start: Int = 1
  ) where S.Element == String {
    self.init(tight: tight, start: start, items: sequence.map(ListItem.init(_:)))
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/Paragraph.swift
================================================
import Foundation

/// A Markdown paragraph element.
///
/// A paragraph is one structural unit of text. It can contain styled text, links, and images.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "You can try "
///     Strong("CommonMark")
///     SoftBreak()
///     InlineLink("here", destination: URL(string: "https://spec.commonmark.org/dingus/")!)
///     "."
///   }
///   Paragraph {
///     InlineImage(source: URL(string: "https://picsum.photos/id/237/125/75")!)
///   }
///   Paragraph {
///     "― Photo by André Spieker"
///   }
/// }
/// ```
///
/// ![](Paragraph)
public struct Paragraph: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.paragraph(content: self.content.inlines)])
  }

  private let content: InlineContent

  /// Creates a paragraph element.
  /// - Parameter content: An inline content builder that returns the inlines included in the paragraph.
  public init(@InlineContentBuilder content: () -> InlineContent) {
    self.content = content()
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TaskList.swift
================================================
import Foundation

/// A Markdown task list element.
///
/// Task lists allow you to create lists of items with checkboxes.
///
/// You can create a task list from a collection of elements.
///
/// ```swift
/// struct MyTask {
///   var isCompleted: Bool = false
///   var title: String
/// }
///
/// let tasks = [
///   MyTask(isCompleted: true, title: "A finished task"),
///   MyTask(title: "An unfinished task"),
///   MyTask(title: "Another unfinished task"),
/// ]
///
/// var body: some View {
///   Markdown {
///     Paragraph {
///       "Things to do:"
///     }
///     TaskList(of: tasks) { task in
///       TaskListItem(isCompleted: task.isCompleted) {
///         Paragraph {
///           if task.isCompleted {
///             Strikethrough(task.title)
///           } else {
///             task.title
///           }
///         }
///       }
///     }
///   }
/// }
/// ```
///
/// ![](TaskList)
///
/// To create a task list from static items, you provide the items directly rather than a collection of data.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "Things to do:"
///   }
///   TaskList {
///     TaskListItem(isCompleted: true) {
///       Paragraph {
///         Strikethrough("A finished task")
///       }
///     }
///     TaskListItem {
///       "An unfinished task"
///     }
///     "Another unfinished task"
///   }
/// }
/// ```
public struct TaskList: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.taskList(isTight: self.tight, items: self.items)])
  }

  private let tight: Bool
  private let items: [RawTaskListItem]

  init(tight: Bool, items: [TaskListItem]) {
    // Force loose spacing if any of the items contains more than one paragraph
    let hasItemsWithMultipleParagraphs = items.contains { item in
      item.children.filter(\.isParagraph).count > 1
    }

    self.tight = hasItemsWithMultipleParagraphs ? false : tight
    self.items = items.map {
      RawTaskListItem(isCompleted: $0.isCompleted, children: $0.children)
    }
  }

  /// Creates a task list with the given items.
  /// - Parameters:
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  ///   - items: A task list content builder that returns the items included in the list.
  public init(tight: Bool = true, @TaskListContentBuilder items: () -> [TaskListItem]) {
    self.init(tight: tight, items: items())
  }

  /// Creates a task list from a sequence of elements.
  /// - Parameters:
  ///   - sequence: The sequence of elements.
  ///   - tight: A `Boolean` value that indicates if the list is tight or loose. This parameter is ignored if
  ///            any of the list items contain more than one paragraph.
  ///   - items: A task list content builder that returns the items for each element in the sequence.
  public init<S: Sequence>(
    of sequence: S,
    tight: Bool = true,
    @TaskListContentBuilder items: (S.Element) -> [TaskListItem]
  ) {
    self.init(tight: tight, items: sequence.flatMap { items($0) })
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TaskListContentBuilder.swift
================================================
import Foundation

/// A result builder that you can use to compose task lists.
///
/// You don't call the methods of the result builder directly. Instead, Swift uses them to combine the elements
/// you declare in any closure with the `@TaskListContentBuilder` attribute. In particular, you rely on
/// this behavior when you declare the `content` inside a list element initializer such as
/// ``TaskList/init(tight:items:)``.
@resultBuilder public enum TaskListContentBuilder {
  public static func buildBlock(_ components: [TaskListItem]...) -> [TaskListItem] {
    components.flatMap { $0 }
  }

  public static func buildExpression(_ expression: String) -> [TaskListItem] {
    [.init(expression)]
  }

  public static func buildExpression(_ expression: TaskListItem) -> [TaskListItem] {
    [expression]
  }

  public static func buildArray(_ components: [[TaskListItem]]) -> [TaskListItem] {
    components.flatMap { $0 }
  }

  public static func buildOptional(_ component: [TaskListItem]?) -> [TaskListItem] {
    component ?? []
  }

  public static func buildEither(first component: [TaskListItem]) -> [TaskListItem] {
    component
  }

  public static func buildEither(second component: [TaskListItem]) -> [TaskListItem] {
    component
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TaskListItem.swift
================================================
import Foundation

/// A Markdown task list item.
///
/// You can use task list items to compose task lists.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "Things to do:"
///   }
///   TaskList {
///     TaskListItem(isCompleted: true) {
///       Paragraph {
///         Strikethrough("A finished task")
///       }
///     }
///     TaskListItem {
///       "An unfinished task"
///     }
///     "Another unfinished task"
///   }
/// }
/// ```
public struct TaskListItem: Hashable {
  let isCompleted: Bool
  let children: [BlockNode]

  init(isCompleted: Bool, children: [BlockNode]) {
    self.isCompleted = isCompleted
    self.children = children
  }

  init(_ text: String) {
    self.init(isCompleted: false, children: [.paragraph(content: [.text(text)])])
  }

  public init(isCompleted: Bool = false, @MarkdownContentBuilder content: () -> MarkdownContent) {
    self.init(isCompleted: isCompleted, children: content().blocks)
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TextTable.swift
================================================
import Foundation

/// A Markdown table element.
///
/// A table is a grid of cells arranged in rows and columns.
///
/// You typically create tables from collections of data. The following example shows how to create a
/// two-column table from an array of a `Superhero` type.
///
/// ```swift
/// struct Superhero {
///   let name: String
///   let realName: String
/// }
///
/// let superheroes = [
///   Superhero(name: "Black Widow", realName: "Natalia Alianovna Romanova"),
///   Superhero(name: "Moondragon", realName: "Heather Douglas"),
///   Superhero(name: "Invisible Woman", realName: "Susan Storm Richards"),
///   Superhero(name: "She-Hulk", realName: "Jennifer Walters"),
/// ]
///
/// var body: some View {
///   Markdown {
///     TextTable(superheroes) {
///       TextTableColumn(title: "Name", value: \.name)
///       TextTableColumn(title: "Real Name", value: \.realName)
///     }
///   }
/// }
/// ```
///
/// ![](Table-Collection)
///
/// To create a table from static rows, you provide both the columns and the rows rather than the contents
/// of a collection of data.
///
/// ```swift
/// struct Savings {
///   let month: String
///   let amount: Decimal
/// }
///
/// var body: some View {
///   Markdown {
///     TextTable {
///       TextTableColumn(title: "Month", value: \.month)
///       TextTableColumn(alignment: .trailing, title: "Savings") { row in
///         row.amount.formatted(.currency(code: "USD"))
///       }
///     } rows: {
///       TextTableRow(Savings(month: "January", amount: 100))
///       TextTableRow(Savings(month: "February", amount: 80))
///     }
///   }
/// }
/// ```
///
/// ![](Table-Static)
public struct TextTable: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.table(columnAlignments: self.columnAlignments, rows: self.rows)])
  }

  private let columnAlignments: [RawTableColumnAlignment]
  private let rows: [RawTableRow]

  init(columnAlignments: [RawTableColumnAlignment], rows: [RawTableRow]) {
    self.columnAlignments = columnAlignments
    self.rows = rows
  }

  /// Creates a table with the given columns and rows.
  /// - Parameters:
  ///   - columns: The columns to display in the table.
  ///   - rows: The rows to display in the table.
  public init<Value>(
    @TextTableColumnBuilder<Value> columns: () -> [TextTableColumn<Value>],
    @TextTableRowBuilder<Value> rows: () -> [TextTableRow<Value>]
  ) {
    self.init(rows().map(\.value), columns: columns)
  }

  /// Creates a table that computes its rows from a collection of data.
  /// - Parameters:
  ///   - data: The data for computing the table rows.
  ///   - columns: The columns to display in the table.
  public init<Data>(
    _ data: Data,
    @TextTableColumnBuilder<Data.Element> columns: () -> [TextTableColumn<Data.Element>]
  ) where Data: RandomAccessCollection {
    let tableColumns = columns()

    let columnAlignments = tableColumns.map(\.alignment)
      .map(RawTableColumnAlignment.init)
    let header = RawTableRow(
      cells:
        tableColumns
        .map(\.title.inlines)
        .map(RawTableCell.init)
    )
    let body = data.map { value in
      RawTableRow(
        cells: tableColumns.map { column in
          RawTableCell(content: column.content(value).inlines)
        }
      )
    }

    self.init(columnAlignments: columnAlignments, rows: CollectionOfOne(header) + body)
  }
}

extension RawTableColumnAlignment {
  init(_ alignment: TextTableColumnAlignment?) {
    switch alignment {
    case .none:
      self = .none
    case .leading:
      self = .left
    case .center:
      self = .center
    case .trailing:
      self = .right
    }
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TextTableColumn.swift
================================================
import Foundation

/// A column that displays styled text or images for each row in a table element.
///
/// You create a column with an optional alignment, a title, and an inline content builder. The table
/// calls the inline content builder with the value for each row in the table.
///
/// The following example creates a column for a table with `Superhero` rows, displaying each superhero's name.
///
/// ```swift
/// TextTableColumn(alignment: .leading, title: "Name") { superhero in
///   Emphasis(superhero.name)
/// }
/// ```
///
/// You can specify a key path instead of an inline content builder for unstyled `String` properties.
///
/// ```swift
/// TextTableColumn(title: "Name", value: \.name)
/// ```
public struct TextTableColumn<RowValue> {
  let alignment: TextTableColumnAlignment?
  let title: InlineContent
  let content: (RowValue) -> InlineContent

  /// Creates a column with a styled title and values.
  /// - Parameters:
  ///   - alignment: The column alignment. If not specified, the table uses a leading alignment.
  ///   - title: An inline content builder that returns the styled title of the column.
  ///   - content: An inline content builder that returns the styled content for each row value of the column.
  public init(
    alignment: TextTableColumnAlignment? = nil,
    @InlineContentBuilder title: () -> InlineContent,
    @InlineContentBuilder content: @escaping (RowValue) -> InlineContent
  ) {
    self.alignment = alignment
    self.title = title()
    self.content = content
  }

  /// Creates a column with a styled title and unstyled row values.
  /// - Parameters:
  ///   - alignment: The column alignment. If not specified, the table uses a leading alignment.
  ///   - title: An inline content builder that returns the styled title of the column.
  ///   - value: The path to the property associated with the column.
  public init<V>(
    alignment: TextTableColumnAlignment? = nil,
    @InlineContentBuilder title: () -> InlineContent,
    value: KeyPath<RowValue, V>
  ) where V: LosslessStringConvertible {
    self.init(alignment: alignment, title: title) { rowValue in
      rowValue[keyPath: value].description
    }
  }

  /// Creates a column with an unstyled title and styled row values.
  /// - Parameters:
  ///   - alignment: The column alignment. If not specified, the table uses a leading alignment.
  ///   - title: The title of the column.
  ///   - content: An inline content builder that returns the styled content for each row value of the column.
  public init(
    alignment: TextTableColumnAlignment? = nil,
    title: String,
    @InlineContentBuilder content: @escaping (RowValue) -> InlineContent
  ) {
    self.init(alignment: alignment, title: { title }, content: content)
  }

  /// Creates a column with unstyled title and row values.
  /// - Parameters:
  ///   - alignment: The column alignment. If not specified, the table uses a leading alignment.
  ///   - title: The title of the column.
  ///   - value: The path to the property associated with the column.
  public init<V>(
    alignment: TextTableColumnAlignment? = nil,
    title: String,
    value: KeyPath<RowValue, V>
  ) where V: LosslessStringConvertible {
    self.init(alignment: alignment, title: { title }, value: value)
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TextTableColumnAlignment.swift
================================================
import Foundation

/// The position of the contents along the horizontal axis in a table column.
@frozen public enum TextTableColumnAlignment {
  case leading, center, trailing
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TextTableColumnBuilder.swift
================================================
import Foundation

/// A result builder that creates table columns from closures.
///
/// You don't call the methods of the result builder directly. Instead, MarkdownUI annotates the `columns`
/// parameter of the various ``TextTable`` initializers with the `@TextTableColumnBuilder` attribute,
/// implicitly calling this builder for you.
@resultBuilder public enum TextTableColumnBuilder<RowValue> {
  public static func buildBlock(
    _ components: [TextTableColumn<RowValue>]...
  ) -> [TextTableColumn<RowValue>] {
    components.flatMap { $0 }
  }

  public static func buildExpression(
    _ expression: TextTableColumn<RowValue>
  ) -> [TextTableColumn<RowValue>] {
    [expression]
  }

  public static func buildArray(
    _ components: [[TextTableColumn<RowValue>]]
  ) -> [TextTableColumn<RowValue>] {
    components.flatMap { $0 }
  }

  public static func buildOptional(
    _ component: [TextTableColumn<RowValue>]?
  ) -> [TextTableColumn<RowValue>] {
    component ?? []
  }

  public static func buildEither(
    first component: [TextTableColumn<RowValue>]
  ) -> [TextTableColumn<RowValue>] {
    component
  }

  public static func buildEither(
    second component: [TextTableColumn<RowValue>]
  ) -> [TextTableColumn<RowValue>] {
    component
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TextTableRow.swift
================================================
import Foundation

/// A row that represents a data value in a table.
///
/// Create instances of `TextTableRow` in the closure you provide to the `rows` parameter in
/// the ``TextTable/init(columns:rows:)`` initializer. The table provides the value of a
/// row to each column, which produces the cells for each row in the column.
public struct TextTableRow<Value> {
  let value: Value

  /// Creates a table row for the given value.
  ///
  /// The table provides the value of a row to each column, which produces the cells for each row in the column.
  ///
  /// The following example creates a row for one instance of the `Savings` type. The table delivers this
  /// value to its columns, which renders different fields of `Savings`.
  ///
  /// ```swift
  /// TextTableRow(Savings(month: "January", amount: 100))
  /// ```
  ///
  /// - Parameter value: The value of the row.
  public init(_ value: Value) {
    self.value = value
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/TextTableRowBuilder.swift
================================================
import Foundation

/// A result builder that creates table rows from closures.
///
/// You don't call the methods of the result builder directly. Instead, MarkdownUI annotates the `rows`
/// parameter of the ``TextTable/init(columns:rows:)`` initializer with the
/// `@TextTableRowBuilder` attribute, implicitly calling this builder for you.
@resultBuilder public enum TextTableRowBuilder<Value> {
  public static func buildBlock(_ components: [TextTableRow<Value>]...) -> [TextTableRow<Value>] {
    components.flatMap { $0 }
  }

  public static func buildExpression(_ expression: TextTableRow<Value>) -> [TextTableRow<Value>] {
    [expression]
  }

  public static func buildArray(_ components: [[TextTableRow<Value>]]) -> [TextTableRow<Value>] {
    components.flatMap { $0 }
  }

  public static func buildOptional(_ component: [TextTableRow<Value>]?) -> [TextTableRow<Value>] {
    component ?? []
  }

  public static func buildEither(first component: [TextTableRow<Value>]) -> [TextTableRow<Value>] {
    component
  }

  public static func buildEither(second component: [TextTableRow<Value>]) -> [TextTableRow<Value>] {
    component
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Blocks/ThematicBreak.swift
================================================
import Foundation

/// A Markdown thematic break element.
///
/// Use a thematic break element to define thematic changes in the content.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "This is an example of a thematic break."
///   }
///   ThematicBreak()
///   Paragraph {
///     "We have used a thematic break above this paragraph."
///   }
/// }
/// ```
///
/// ![](ThematicBreak)
public struct ThematicBreak: MarkdownContentProtocol {
  public var _markdownContent: MarkdownContent {
    .init(blocks: [.thematicBreak])
  }

  public init() {}
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/Code.swift
================================================
import Foundation

/// A code span in a Markdown content block.
public struct Code: InlineContentProtocol {
  public var _inlineContent: InlineContent {
    .init(inlines: [.code(self.text)])
  }

  private let text: String

  /// Creates a code span inline element.
  /// - Parameter text: The text content inside the code span.
  public init(_ text: String) {
    self.text = text
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/Emphasis.swift
================================================
import Foundation

/// An emphasized text in a Markdown content block.
public struct Emphasis: InlineContentProtocol {
  public var _inlineContent: InlineContent {
    .init(inlines: [.emphasis(children: self.content.inlines)])
  }

  private let content: InlineContent

  init(content: InlineContent) {
    self.content = content
  }

  /// Creates an emphasized inline by applying the emphasis style to a string.
  /// - Parameter text: The text to emphasize
  public init(_ text: String) {
    self.init(content: .init(inlines: [.text(text)]))
  }

  /// Creates an emphasized inline by applying the emphasis style to other inline content.
  /// - Parameter content: An inline content builder that returns the inlines to emphasize.
  public init(@InlineContentBuilder content: () -> InlineContent) {
    self.init(content: content())
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/InlineContent.swift
================================================
import Foundation

/// A protocol that represents any Markdown inline content.
public protocol InlineContentProtocol {
  var _inlineContent: InlineContent { get }
}

/// A Markdown inline content value.
///
/// A Markdown inline content value represents the inline text inside a leaf Markdown block,
/// like a paragraph, heading, or table cell. Some inline elements, like emphasized or strong
/// text, can contain other inlines, allowing a piece of text to have multiple styles
/// simultaneously.
///
/// You don't use this type directly to create Markdown inline content. Instead, you create
/// inline content by composing specific inline instances inside a closure annotated with
/// the `@InlineContentBuilder` attribute. Types like ``Paragraph``,
/// ``Heading`` or ``TextTableColumn`` provide initializers for composing
/// inline content.
///
/// The following example shows how you can create a paragraph by composing inline
/// content.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "You can try "
///     Strong("CommonMark")
///     SoftBreak()
///     InlineLink("here", destination: URL(string: "https://spec.commonmark.org/dingus/")!)
///     "."
///   }
/// }
/// ```
public struct InlineContent: Equatable, InlineContentProtocol {
  public var _inlineContent: InlineContent { self }
  let inlines: [InlineNode]

  init(inlines: [InlineNode] = []) {
    self.inlines = inlines
  }

  init(_ components: [InlineContentProtocol]) {
    self.init(inlines: components.map(\._inlineContent).flatMap(\.inlines))
  }

  init(_ text: String) {
    self.init(inlines: [.text(text)])
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/InlineContentBuilder.swift
================================================
import Foundation

/// A result builder that you can use to compose Markdown inline content.
///
/// You don't call the methods of the result builder directly. Instead, MarkdownUI annotates the `content` parameter of the
/// ``Paragraph``, ``Heading``, and ``TextTableColumn`` initializers with the `@InlineContentBuilder` attribute,
/// implicitly calling this builder for you.
@resultBuilder public enum InlineContentBuilder {
  public static func buildBlock(_ components: InlineContentProtocol...) -> InlineContent {
    .init(components)
  }

  public static func buildExpression(_ expression: InlineContentProtocol) -> InlineContent {
    expression._inlineContent
  }

  public static func buildExpression(_ expression: String) -> InlineContent {
    .init(expression)
  }

  public static func buildArray(_ components: [InlineContentProtocol]) -> InlineContent {
    .init(components)
  }

  public static func buildOptional(_ component: InlineContentProtocol?) -> InlineContent {
    component?._inlineContent ?? .init()
  }

  public static func buildEither(first component: InlineContentProtocol) -> InlineContent {
    component._inlineContent
  }

  public static func buildEither(second component: InlineContentProtocol) -> InlineContent {
    component._inlineContent
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/InlineImage.swift
================================================
import Foundation

/// An image in a Markdown content block.
///
/// You can use an image inline to embed an image in a paragraph.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "A picture of a black lab puppy:"
///   }
///   Paragraph {
///     InlineImage(source: URL(string: "https://picsum.photos/id/237/100/150")!)
///     InlineLink(destination: URL(string: "https://en.wikipedia.org/wiki/Labrador_Retriever")!) {
///       InlineImage(source: URL(string: "https://picsum.photos/id/237/100/150")!)
///     }
///   }
///   Paragraph {
///     "You can also insert images in a line of text, such as "
///     InlineImage(source: URL(string: "https://picsum.photos/id/237/100/150")!)
///     "."
///   }
/// }
/// ```
///
/// ![](InlineImage)
public struct InlineImage: InlineContentProtocol {
  public var _inlineContent: InlineContent {
    .init(inlines: [.image(source: self.source, children: self.content.inlines)])
  }

  private let source: String
  private let content: InlineContent

  init(source: String, content: InlineContent) {
    self.source = source
    self.content = content
  }

  /// Creates an inline image with the given source
  /// - Parameter source: The absolute or relative path to the image.
  public init(source: URL) {
    self.init(source: source.absoluteString, content: .init())
  }

  /// Creates an inline image with an alternate text.
  /// - Parameters:
  ///   - text: The alternate text for the image. A ``Markdown`` view uses this text
  ///           as the accessibility label of the image.
  ///   - source: The absolute or relative path to the image.
  public init(_ text: String, source: URL) {
    self.init(source: source.absoluteString, content: .init(inlines: [.text(text)]))
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/InlineLink.swift
================================================
import Foundation

/// An inline content that can navigate to a URL.
///
/// You can create a link by providing a destination URL and a title. The title tells the purpose of the link and
/// can be any inline content, including an image.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "A picture of a black lab puppy:"
///   }
///   Paragraph {
///     InlineLink(destination: URL(string: "https://en.wikipedia.org/wiki/Labrador_Retriever")!) {
///       InlineImage(source: URL(string: "237-100x150")!)
///     }
///   }
/// }
/// ```
///
/// You can directly provide the title text for links with an unstyled title.
///
/// ```swift
/// Markdown {
///   Paragraph {
///     "Visit "
///     InlineLink("our site.", destination: URL(string: "https://www.example.com")!)
///   }
/// }
/// ```
public struct InlineLink: InlineContentProtocol {
  public var _inlineContent: InlineContent {
    .init(inlines: [.link(destination: self.destination, children: self.content.inlines)])
  }

  private let destination: String
  private let content: InlineContent

  init(destination: String, content: InlineContent) {
    self.destination = destination
    self.content = content
  }

  /// Creates a link to a given destination with an unstyled text title.
  /// - Parameters:
  ///   - text: The title of the link.
  ///   - destination: The URL for the link.
  public init(_ text: String, destination: URL) {
    self.init(destination: destination.absoluteString, content: .init(inlines: [.text(text)]))
  }

  /// Creates a link to a given destination with a title composed of other inlines.
  /// - Parameters:
  ///   - destination: The URL for the link.
  ///   - content: An inline content builder that returns the title of the link.
  public init(destination: URL, @InlineContentBuilder content: () -> InlineContent) {
    self.init(destination: destination.absoluteString, content: content())
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/LineBreak.swift
================================================
import Foundation

/// A line break in a Markdown content block.
///
/// You can use a line break inline to force line breaks in a text.
public struct LineBreak: InlineContentProtocol {
  /// Creates a line break inline.
  public init() {}

  public var _inlineContent: InlineContent {
    .init(inlines: [.lineBreak])
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/SoftBreak.swift
================================================
import Foundation

/// A soft break in a Markdown content block.
///
/// A ``Markdown`` view will display a soft break as a space.
public struct SoftBreak: InlineContentProtocol {
  /// Creates a soft break inline element.
  public init() {}

  public var _inlineContent: InlineContent {
    .init(inlines: [.softBreak])
  }
}

extension SoftBreak {
  public enum Mode {
    /// Treat a soft break as a space
    case space

    /// Treat a soft break as a line break
    case lineBreak
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/Strikethrough.swift
================================================
import Foundation

/// A deleted or redacted text in a Markdown content block.
public struct Strikethrough: InlineContentProtocol {
  public var _inlineContent: InlineContent {
    .init(inlines: [.strikethrough(children: self.content.inlines)])
  }

  private let content: InlineContent

  init(content: InlineContent) {
    self.content = content
  }

  /// Creates a deleted inline by applying the deleted style to a string.
  /// - Parameter text: The text to delete.
  public init(_ text: String) {
    self.init(content: .init(inlines: [.text(text)]))
  }

  /// Creates a deleted inline by applying the deleted style to other inline content.
  /// - Parameter content: An inline content builder that returns the inlines to delete.
  public init(@InlineContentBuilder content: () -> InlineContent) {
    self.init(content: content())
  }
}



================================================
FILE: Sources/MarkdownUI/DSL/Inlines/Strong.swift
================================================
import Foundation

/// A strong text in a Markdown content block.
public struct Strong: InlineContentProtocol {
  public var _inlineContent: InlineContent {
    .init(inlines: [.strong(children: self.content.inlines)])
  }

  private let content: InlineContent

  init(content: InlineContent) {
    self.content = content
  }

  /// Creates a strong inline by applying the strong style to a string.
  /// - Parameter text: The text to make strong.
  public init(_ text: String) {
    self.init(content: .init(inlines: [.text(text)]))
  }

  /// Creates a strong inline by applying the strong style to other inline content.
  /// - Parameter content: An inline content builder that returns the inlines to make strong.
  public init(@InlineContentBuilder content: () -> InlineContent) {
    self.init(content: content())
  }
}



================================================
FILE: Sources/MarkdownUI/Extensibility/AssetImageProvider.swift
================================================
import SwiftUI

/// An image provider that loads images from resources located in an app or a module.
///
/// The following example shows how to configure the asset image provider to load images
/// from the main bundle.
///
/// ```swift
/// Markdown {
///   "![A dog](dog)"
///   "― Photo by André Spieker"
/// }
/// .markdownImageProvider(.asset)
/// ```
public struct AssetImageProvider: ImageProvider {
  private let name: (URL) -> String
  private let bundle: Bundle?

  /// Creates an asset image provider.
  /// - Parameters:
  ///   - name: A closure that extracts the image resource name from the URL in the Markdown content.
  ///   - bundle: The bundle where the image resources are located. Specify `nil` to search the app’s main bundle.
  public init(
    name: @escaping (URL) -> String = \.lastPathComponent,
    bundle: Bundle? = nil
  ) {
    self.name = name
    self.bundle = bundle
  }

  public func makeImage(url: URL?) -> some View {
    if let url = url, let image = self.image(url: url) {
      ResizeToFit(idealSize: image.size) {
        Image(platformImage: image)
          .resizable()
      }
    }
  }

  private func image(url: URL) -> PlatformImage? {
    #if canImport(UIKit)
      return UIImage(named: self.name(url), in: self.bundle, with: nil)
    #elseif canImport(AppKit)
      if let bundle, bundle != .main {
        return bundle.image(forResource: self.name(url))
      } else {
        return NSImage(named: self.name(url))
      }
    #endif
  }
}

extension ImageProvider where Self == AssetImageProvider {
  /// An image provider that loads images from resources located in an app or a module.
  ///
  /// Use the `markdownImageProvider(_:)` modifier to configure this image provider for a view hierarchy.
  public static var asset: Self {
    .init()
  }
}

#if canImport(UIKit)
  private typealias PlatformImage = UIImage
#elseif canImport(AppKit)
  private typealias PlatformImage = NSImage
#endif

extension Image {
  fileprivate init(platformImage: PlatformImage) {
    #if canImport(UIKit)
      self.init(uiImage: platformImage)
    #elseif canImport(AppKit)
      self.init(nsImage: platformImage)
    #endif
  }
}



================================================
FILE: Sources/MarkdownUI/Extensibility/AssetInlineImageProvider.swift
================================================
import SwiftUI

/// An inline image provider that loads images from resources located in an app or a module.
public struct AssetInlineImageProvider: InlineImageProvider {
  private let name: (URL) -> String
  private let bundle: Bundle?

  /// Creates an asset inline image provider.
  /// - Parameters:
  ///   - name: A closure that extracts the image resource name from the URL in the Markdown content.
  ///   - bundle: The bundle where the image resources are located. Specify `nil` to search the app’s main bundle.
  public init(
    name: @escaping (URL) -> String = \.lastPathComponent,
    bundle: Bundle? = nil
  ) {
    self.name = name
    self.bundle = bundle
  }

  public func image(with url: URL, label: String) async throws -> Image {
    .init(self.name(url), bundle: self.bundle, label: Text(label))
  }
}

extension InlineImageProvider where Self == AssetInlineImageProvider {
  /// An inline image provider that loads images from resources located in an app or a module.
  ///
  /// Use the `markdownInlineImageProvider(_:)` modifier to configure this image provider for a view hierarchy.
  public static var asset: Self {
    .init()
  }
}



================================================
FILE: Sources/MarkdownUI/Extensibility/CodeSyntaxHighlighter.swift
================================================
import SwiftUI

/// A type that provides syntax highlighting to code blocks in a Markdown view.
///
/// To configure the current code syntax highlighter for a view hierarchy, use the
/// `markdownCodeSyntaxHighlighter(_:)` modifier.
public protocol CodeSyntaxHighlighter {
  /// Returns a text view configured with the syntax highlighted code.
  /// - Parameters:
  ///   - code: The code block.
  ///   - language: The language of the code block.
  func highlightCode(_ code: String, language: String?) -> Text
}

/// A code syntax highlighter that returns unstyled code blocks.
public struct PlainTextCodeSyntaxHighlighter: CodeSyntaxHighlighter {
  /// Creates a plain text code syntax highlighter.
  public init() {}

  public func highlightCode(_ code: String, language: String?) -> Text {
    Text(code)
  }
}

extension CodeSyntaxHighlighter where Self == PlainTextCodeSyntaxHighlighter {
  /// A code syntax highlighter that returns unstyled code blocks.
  public static var plainText: Self {
    PlainTextCodeSyntaxHighlighter()
  }
}



================================================
FILE: Sources/MarkdownUI/Extensibility/DefaultImageProvider.swift
================================================
import NetworkImage
import SwiftUI

/// The default image provider, which loads images from the network.
public struct DefaultImageProvider: ImageProvider {
  public func makeImage(url: URL?) -> some View {
    NetworkImage(url: url) { state in
      switch state {
      case .empty, .failure:
        Color.clear
          .frame(width: 0, height: 0)
      case .success(let image, let idealSize):
        ResizeToFit(idealSize: idealSize) {
          image.resizable()
        }
      }
    }
  }
}

extension ImageProvider where Self == DefaultImageProvider {
  /// The default image provider, which loads images from the network.
  ///
  /// Use the `markdownImageProvider(_:)` modifier to configure this image provider for a view hierarchy.
  public static var `default`: Self {
    .init()
  }
}



================================================
FILE: Sources/MarkdownUI/Extensibility/DefaultInlineImageProvider.swift
================================================
import NetworkImage
import SwiftUI

/// The default inline image provider, which loads images from the network.
public struct DefaultInlineImageProvider: InlineImageProvider {
  public func image(with url: URL, label: String) async throws -> Image {
    try await Image(
      DefaultNetworkImageLoader.shared.image(from: url),
      scale: 1,
      label: Text(label)
    )
  }
}

extension InlineImageProvider where Self == DefaultInlineImageProvider {
  /// The default inline image provider, which loads images from the network.
  ///
  /// Use the `markdownInlineImageProvider(_:)` modifier to configure
  /// this image provider for a view hierarchy.
  public static var `default`: Self {
    .init()
  }
}



================================================
FILE: Sources/MarkdownUI/Extensibility/ImageProvider.swift
================================================
import SwiftUI

/// A type that provides a view that asynchronously loads and displays an image in a Markdown view.
///
/// To configure the current image provider for a view hierarchy, use the `markdownImageProvider(_:)` modifier.
///
/// The following example shows how to configure the ``AssetImageProvider`` to load images from the main bundle.
///
/// ```swift
/// Markdown {
///   "![A dog](dog)"
///   "― Photo by André Spieker"
/// }
/// .markdownImageProvider(.asset)
/// ```
public protocol ImageProvider {
  /// A view that loads and displays an image.
  associatedtype Body: View

  /// Creates a view that asynchronously loads and displays the image on a given URL.
  ///
  /// The ``Markdown`` views in a view hierarchy where this provider is the current image provider
  /// will call this method for each image in their contents.
  ///
  /// - Parameter url: The URL of the image to display.
  @ViewBuilder func makeImage(url: URL?) -> Body
}

struct AnyImageProvider: ImageProvider {
  private let _makeImage: (URL?) -> AnyView

  init<I: ImageProvider>(_ imageProvider: I) {
    self._makeImage = {
      AnyView(imageProvider.makeImage(url: $0))
    }
  }

  func makeImage(url: URL?) -> some View {
    self._makeImage(url)
  }
}



================================================
FILE: Sources/MarkdownUI/Extensibility/InlineImageProvider.swift
================================================
import SwiftUI

/// A type that loads images that are displayed within a line of text.
///
/// To configure the current inline image provider for a view hierarchy,
/// use the `markdownInlineImageProvider(_:)` modifier.
public protocol InlineImageProvider {
  /// Returns an image for the given URL.
  ///
  /// ``Markdown`` views call this method to load images within a line of text.
  ///
  /// - Parameters:
  ///   - url: The URL of the image to display.
  ///   - label: The accessibility label associated with the image.
  func image(with url: URL, label: String) async throws -> Image
}



================================================
FILE: Sources/MarkdownUI/Parser/BlockNode+Rewrite.swift
================================================
import Foundation

extension Sequence where Element == BlockNode {
  func rewrite(_ r: (BlockNode) throws -> [BlockNode]) rethrows -> [BlockNode] {
    try self.flatMap { try $0.rewrite(r) }
  }

  func rewrite(_ r: (InlineNode) throws -> [InlineNode]) rethrows -> [BlockNode] {
    try self.flatMap { try $0.rewrite(r) }
  }
}

extension BlockNode {
  func rewrite(_ r: (BlockNode) throws -> [BlockNode]) rethrows -> [BlockNode] {
    switch self {
    case .blockquote(let children):
      return try r(.blockquote(children: children.rewrite(r)))
    case .bulletedList(let isTight, let items):
      return try r(
        .bulletedList(
          isTight: isTight,
          items: try items.map {
            RawListItem(children: try $0.children.rewrite(r))
          }
        )
      )
    case .numberedList(let isTight, let start, let items):
      return try r(
        .numberedList(
          isTight: isTight,
          start: start,
          items: try items.map {
            RawListItem(children: try $0.children.rewrite(r))
          }
        )
      )
    case .taskList(let isTight, let items):
      return try r(
        .taskList(
          isTight: isTight,
          items: try items.map {
            RawTaskListItem(isCompleted: $0.isCompleted, children: try $0.children.rewrite(r))
          }
        )
      )
    default:
      return try r(self)
    }
  }

  func rewrite(_ r: (InlineNode) throws -> [InlineNode]) rethrows -> [BlockNode] {
    switch self {
    case .blockquote(let children):
      return [.blockquote(children: try children.rewrite(r))]
    case .bulletedList(let isTight, let items):
      return [
        .bulletedList(
          isTight: isTight,
          items: try items.map {
            RawListItem(children: try $0.children.rewrite(r))
          }
        )
      ]
    case .numberedList(let isTight, let start, let items):
      return [
        .numberedList(
          isTight: isTight,
          start: start,
          items: try items.map {
            RawListItem(children: try $0.children.rewrite(r))
          }
        )
      ]
    case .taskList(let isTight, let items):
      return [
        .taskList(
          isTight: isTight,
          items: try items.map {
            RawTaskListItem(isCompleted: $0.isCompleted, children: try $0.children.rewrite(r))
          }
        )
      ]
    case .paragraph(let content):
      return [.paragraph(content: try content.rewrite(r))]
    case .heading(let level, let content):
      return [.heading(level: level, content: try content.rewrite(r))]
    case .table(let columnAlignments, let rows):
      return [
        .table(
          columnAlignments: columnAlignments,
          rows: try rows.map {
            RawTableRow(
              cells: try $0.cells.map {
                RawTableCell(content: try $0.content.rewrite(r))
              }
            )
          }
        )
      ]
    default:
      return [self]
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Parser/BlockNode.swift
================================================
import Foundation

enum BlockNode: Hashable {
  case blockquote(children: [BlockNode])
  case bulletedList(isTight: Bool, items: [RawListItem])
  case numberedList(isTight: Bool, start: Int, items: [RawListItem])
  case taskList(isTight: Bool, items: [RawTaskListItem])
  case codeBlock(fenceInfo: String?, content: String)
  case htmlBlock(content: String)
  case paragraph(content: [InlineNode])
  case heading(level: Int, content: [InlineNode])
  case table(columnAlignments: [RawTableColumnAlignment], rows: [RawTableRow])
  case thematicBreak
}

extension BlockNode {
  var children: [BlockNode] {
    switch self {
    case .blockquote(let children):
      return children
    case .bulletedList(_, let items):
      return items.map(\.children).flatMap { $0 }
    case .numberedList(_, _, let items):
      return items.map(\.children).flatMap { $0 }
    case .taskList(_, let items):
      return items.map(\.children).flatMap { $0 }
    default:
      return []
    }
  }

  var isParagraph: Bool {
    guard case .paragraph = self else { return false }
    return true
  }
}

struct RawListItem: Hashable {
  let children: [BlockNode]
}

struct RawTaskListItem: Hashable {
  let isCompleted: Bool
  let children: [BlockNode]
}

enum RawTableColumnAlignment: Character {
  case none = "\0"
  case left = "l"
  case center = "c"
  case right = "r"
}

struct RawTableRow: Hashable {
  let cells: [RawTableCell]
}

struct RawTableCell: Hashable {
  let content: [InlineNode]
}



================================================
FILE: Sources/MarkdownUI/Parser/HTMLTag.swift
================================================
import Foundation

struct HTMLTag {
  let name: String
}

extension HTMLTag {
  private enum Constants {
    static let tagExpression = try! NSRegularExpression(pattern: "<\\/?([a-zA-Z0-9]+)[^>]*>")
  }

  init?(_ description: String) {
    guard
      let match = Constants.tagExpression.firstMatch(
        in: description,
        range: NSRange(description.startIndex..., in: description)
      ),
      let nameRange = Range(match.range(at: 1), in: description)
    else {
      return nil
    }

    self.name = String(description[nameRange])
  }
}



================================================
FILE: Sources/MarkdownUI/Parser/InlineNode+Collect.swift
================================================
import Foundation

extension Sequence where Element == InlineNode {
  func collect<Result>(_ c: (InlineNode) throws -> [Result]) rethrows -> [Result] {
    try self.flatMap { try $0.collect(c) }
  }
}

extension InlineNode {
  func collect<Result>(_ c: (InlineNode) throws -> [Result]) rethrows -> [Result] {
    try self.children.collect(c) + c(self)
  }
}



================================================
FILE: Sources/MarkdownUI/Parser/InlineNode+Rewrite.swift
================================================
import Foundation

extension Sequence where Element == InlineNode {
  func rewrite(_ r: (InlineNode) throws -> [InlineNode]) rethrows -> [InlineNode] {
    try self.flatMap { try $0.rewrite(r) }
  }
}

extension InlineNode {
  func rewrite(_ r: (InlineNode) throws -> [InlineNode]) rethrows -> [InlineNode] {
    var inline = self
    inline.children = try self.children.rewrite(r)
    return try r(inline)
  }
}



================================================
FILE: Sources/MarkdownUI/Parser/InlineNode.swift
================================================
import Foundation

enum InlineNode: Hashable, Sendable {
  case text(String)
  case softBreak
  case lineBreak
  case code(String)
  case html(String)
  case emphasis(children: [InlineNode])
  case strong(children: [InlineNode])
  case strikethrough(children: [InlineNode])
  case link(destination: String, children: [InlineNode])
  case image(source: String, children: [InlineNode])
}

extension InlineNode {
  var children: [InlineNode] {
    get {
      switch self {
      case .emphasis(let children):
        return children
      case .strong(let children):
        return children
      case .strikethrough(let children):
        return children
      case .link(_, let children):
        return children
      case .image(_, let children):
        return children
      default:
        return []
      }
    }

    set {
      switch self {
      case .emphasis:
        self = .emphasis(children: newValue)
      case .strong:
        self = .strong(children: newValue)
      case .strikethrough:
        self = .strikethrough(children: newValue)
      case .link(let destination, _):
        self = .link(destination: destination, children: newValue)
      case .image(let source, _):
        self = .image(source: source, children: newValue)
      default:
        break
      }
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Parser/MarkdownParser.swift
================================================
import Foundation
@_implementationOnly import cmark_gfm
@_implementationOnly import cmark_gfm_extensions

extension Array where Element == BlockNode {
  init(markdown: String) {
    let blocks = UnsafeNode.parseMarkdown(markdown) { document in
      document.children.compactMap(BlockNode.init(unsafeNode:))
    }
    self.init(blocks ?? .init())
  }

  func renderMarkdown() -> String {
    UnsafeNode.makeDocument(self) { document in
      String(cString: cmark_render_commonmark(document, CMARK_OPT_DEFAULT, 0))
    } ?? ""
  }

  func renderPlainText() -> String {
    UnsafeNode.makeDocument(self) { document in
      String(cString: cmark_render_plaintext(document, CMARK_OPT_DEFAULT, 0))
    } ?? ""
  }

  func renderHTML() -> String {
    UnsafeNode.makeDocument(self) { document in
      String(cString: cmark_render_html(document, CMARK_OPT_DEFAULT, nil))
    } ?? ""
  }
}

extension BlockNode {
  fileprivate init?(unsafeNode: UnsafeNode) {
    switch unsafeNode.nodeType {
    case .blockquote:
      self = .blockquote(children: unsafeNode.children.compactMap(BlockNode.init(unsafeNode:)))
    case .list:
      if unsafeNode.children.contains(where: \.isTaskListItem) {
        self = .taskList(
          isTight: unsafeNode.isTightList,
          items: unsafeNode.children.map(RawTaskListItem.init(unsafeNode:))
        )
      } else {
        switch unsafeNode.listType {
        case CMARK_BULLET_LIST:
          self = .bulletedList(
            isTight: unsafeNode.isTightList,
            items: unsafeNode.children.map(RawListItem.init(unsafeNode:))
          )
        case CMARK_ORDERED_LIST:
          self = .numberedList(
            isTight: unsafeNode.isTightList,
            start: unsafeNode.listStart,
            items: unsafeNode.children.map(RawListItem.init(unsafeNode:))
          )
        default:
          fatalError("cmark reported a list node without a list type.")
        }
      }
    case .codeBlock:
      self = .codeBlock(fenceInfo: unsafeNode.fenceInfo, content: unsafeNode.literal ?? "")
    case .htmlBlock:
      self = .htmlBlock(content: unsafeNode.literal ?? "")
    case .paragraph:
      self = .paragraph(content: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:)))
    case .heading:
      self = .heading(
        level: unsafeNode.headingLevel,
        content: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:))
      )
    case .table:
      self = .table(
        columnAlignments: unsafeNode.tableAlignments,
        rows: unsafeNode.children.map(RawTableRow.init(unsafeNode:))
      )
    case .thematicBreak:
      self = .thematicBreak
    default:
      assertionFailure("Unhandled node type '\(unsafeNode.nodeType)' in BlockNode.")
      return nil
    }
  }
}

extension RawListItem {
  fileprivate init(unsafeNode: UnsafeNode) {
    guard unsafeNode.nodeType == .item else {
      fatalError("Expected a list item but got a '\(unsafeNode.nodeType)' instead.")
    }
    self.init(children: unsafeNode.children.compactMap(BlockNode.init(unsafeNode:)))
  }
}

extension RawTaskListItem {
  fileprivate init(unsafeNode: UnsafeNode) {
    guard unsafeNode.nodeType == .taskListItem || unsafeNode.nodeType == .item else {
      fatalError("Expected a list item but got a '\(unsafeNode.nodeType)' instead.")
    }
    self.init(
      isCompleted: unsafeNode.isTaskListItemChecked,
      children: unsafeNode.children.compactMap(BlockNode.init(unsafeNode:))
    )
  }
}

extension RawTableRow {
  fileprivate init(unsafeNode: UnsafeNode) {
    guard unsafeNode.nodeType == .tableRow || unsafeNode.nodeType == .tableHead else {
      fatalError("Expected a table row but got a '\(unsafeNode.nodeType)' instead.")
    }
    self.init(cells: unsafeNode.children.map(RawTableCell.init(unsafeNode:)))
  }
}

extension RawTableCell {
  fileprivate init(unsafeNode: UnsafeNode) {
    guard unsafeNode.nodeType == .tableCell else {
      fatalError("Expected a table cell but got a '\(unsafeNode.nodeType)' instead.")
    }
    self.init(content: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:)))
  }
}

extension InlineNode {
  fileprivate init?(unsafeNode: UnsafeNode) {
    switch unsafeNode.nodeType {
    case .text:
      self = .text(unsafeNode.literal ?? "")
    case .softBreak:
      self = .softBreak
    case .lineBreak:
      self = .lineBreak
    case .code:
      self = .code(unsafeNode.literal ?? "")
    case .html:
      self = .html(unsafeNode.literal ?? "")
    case .emphasis:
      self = .emphasis(children: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:)))
    case .strong:
      self = .strong(children: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:)))
    case .strikethrough:
      self = .strikethrough(children: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:)))
    case .link:
      self = .link(
        destination: unsafeNode.url ?? "",
        children: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:))
      )
    case .image:
      self = .image(
        source: unsafeNode.url ?? "",
        children: unsafeNode.children.compactMap(InlineNode.init(unsafeNode:))
      )
    default:
      assertionFailure("Unhandled node type '\(unsafeNode.nodeType)' in InlineNode.")
      return nil
    }
  }
}

private typealias UnsafeNode = UnsafeMutablePointer<cmark_node>

extension UnsafeNode {
  fileprivate var nodeType: NodeType {
    let typeString = String(cString: cmark_node_get_type_string(self))
    guard let nodeType = NodeType(rawValue: typeString) else {
      fatalError("Unknown node type '\(typeString)' found.")
    }
    return nodeType
  }

  fileprivate var children: UnsafeNodeSequence {
    .init(cmark_node_first_child(self))
  }

  fileprivate var literal: String? {
    cmark_node_get_literal(self).map(String.init(cString:))
  }

  fileprivate var url: String? {
    cmark_node_get_url(self).map(String.init(cString:))
  }

  fileprivate var isTaskListItem: Bool {
    self.nodeType == .taskListItem
  }

  fileprivate var listType: cmark_list_type {
    cmark_node_get_list_type(self)
  }

  fileprivate var listStart: Int {
    Int(cmark_node_get_list_start(self))
  }

  fileprivate var isTaskListItemChecked: Bool {
    cmark_gfm_extensions_get_tasklist_item_checked(self)
  }

  fileprivate var isTightList: Bool {
    cmark_node_get_list_tight(self) != 0
  }

  fileprivate var fenceInfo: String? {
    cmark_node_get_fence_info(self).map(String.init(cString:))
  }

  fileprivate var headingLevel: Int {
    Int(cmark_node_get_heading_level(self))
  }

  fileprivate var tableColumns: Int {
    Int(cmark_gfm_extensions_get_table_columns(self))
  }

  fileprivate var tableAlignments: [RawTableColumnAlignment] {
    (0..<self.tableColumns).map { column in
      let ascii = cmark_gfm_extensions_get_table_alignments(self)[column]
      let scalar = UnicodeScalar(ascii)
      let character = Character(scalar)
      return .init(rawValue: character) ?? .none
    }
  }

  fileprivate static func parseMarkdown<ResultType>(
    _ markdown: String,
    body: (UnsafeNode) throws -> ResultType
  ) rethrows -> ResultType? {
    cmark_gfm_core_extensions_ensure_registered()

    // Create a Markdown parser and attach the GitHub syntax extensions

    let parser = cmark_parser_new(CMARK_OPT_DEFAULT)
    defer { cmark_parser_free(parser) }

    let extensionNames: Set<String>

    if #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) {
      extensionNames = ["autolink", "strikethrough", "tagfilter", "tasklist", "table"]
    } else {
      extensionNames = ["autolink", "strikethrough", "tagfilter", "tasklist"]
    }

    for extensionName in extensionNames {
      guard let syntaxExtension = cmark_find_syntax_extension(extensionName) else {
        continue
      }
      cmark_parser_attach_syntax_extension(parser, syntaxExtension)
    }

    // Parse the Markdown document

    cmark_parser_feed(parser, markdown, markdown.utf8.count)

    guard let document = cmark_parser_finish(parser) else {
      return nil
    }

    defer { cmark_node_free(document) }
    return try body(document)
  }

  fileprivate static func makeDocument<ResultType>(
    _ blocks: [BlockNode],
    body: (UnsafeNode) throws -> ResultType
  ) rethrows -> ResultType? {
    cmark_gfm_core_extensions_ensure_registered()
    guard let document = cmark_node_new(CMARK_NODE_DOCUMENT) else { return nil }
    blocks.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(document, $0) }

    defer { cmark_node_free(document) }
    return try body(document)
  }

  fileprivate static func make(_ block: BlockNode) -> UnsafeNode? {
    switch block {
    case .blockquote(let children):
      guard let node = cmark_node_new(CMARK_NODE_BLOCK_QUOTE) else { return nil }
      children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .bulletedList(let isTight, let items):
      guard let node = cmark_node_new(CMARK_NODE_LIST) else { return nil }
      cmark_node_set_list_type(node, CMARK_BULLET_LIST)
      cmark_node_set_list_tight(node, isTight ? 1 : 0)
      items.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .numberedList(let isTight, let start, let items):
      guard let node = cmark_node_new(CMARK_NODE_LIST) else { return nil }
      cmark_node_set_list_type(node, CMARK_ORDERED_LIST)
      cmark_node_set_list_tight(node, isTight ? 1 : 0)
      cmark_node_set_list_start(node, Int32(start))
      items.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .taskList(let isTight, let items):
      guard let node = cmark_node_new(CMARK_NODE_LIST) else { return nil }
      cmark_node_set_list_type(node, CMARK_BULLET_LIST)
      cmark_node_set_list_tight(node, isTight ? 1 : 0)
      items.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .codeBlock(let fenceInfo, let content):
      guard let node = cmark_node_new(CMARK_NODE_CODE_BLOCK) else { return nil }
      if let fenceInfo {
        cmark_node_set_fence_info(node, fenceInfo)
      }
      cmark_node_set_literal(node, content)
      return node
    case .htmlBlock(let content):
      guard let node = cmark_node_new(CMARK_NODE_HTML_BLOCK) else { return nil }
      cmark_node_set_literal(node, content)
      return node
    case .paragraph(let content):
      guard let node = cmark_node_new(CMARK_NODE_PARAGRAPH) else { return nil }
      content.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .heading(let level, let content):
      guard let node = cmark_node_new(CMARK_NODE_HEADING) else { return nil }
      cmark_node_set_heading_level(node, Int32(level))
      content.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .table(let columnAlignments, let rows):
      guard let table = cmark_find_syntax_extension("table"),
        let node = cmark_node_new_with_ext(ExtensionNodeTypes.shared.CMARK_NODE_TABLE, table)
      else {
        return nil
      }
      cmark_gfm_extensions_set_table_columns(node, UInt16(columnAlignments.count))
      var alignments = columnAlignments.map { $0.rawValue.asciiValue! }
      cmark_gfm_extensions_set_table_alignments(node, UInt16(columnAlignments.count), &alignments)
      rows.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      if let header = cmark_node_first_child(node) {
        cmark_gfm_extensions_set_table_row_is_header(header, 1)
      }
      return node
    case .thematicBreak:
      guard let node = cmark_node_new(CMARK_NODE_THEMATIC_BREAK) else { return nil }
      return node
    }
  }

  fileprivate static func make(_ item: RawListItem) -> UnsafeNode? {
    guard let node = cmark_node_new(CMARK_NODE_ITEM) else { return nil }
    item.children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
    return node
  }

  fileprivate static func make(_ item: RawTaskListItem) -> UnsafeNode? {
    guard let tasklist = cmark_find_syntax_extension("tasklist"),
      let node = cmark_node_new_with_ext(CMARK_NODE_ITEM, tasklist)
    else {
      return nil
    }
    cmark_gfm_extensions_set_tasklist_item_checked(node, item.isCompleted)
    item.children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
    return node
  }

  fileprivate static func make(_ tableRow: RawTableRow) -> UnsafeNode? {
    guard let table = cmark_find_syntax_extension("table"),
      let node = cmark_node_new_with_ext(ExtensionNodeTypes.shared.CMARK_NODE_TABLE_ROW, table)
    else {
      return nil
    }
    tableRow.cells.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
    return node
  }

  fileprivate static func make(_ tableCell: RawTableCell) -> UnsafeNode? {
    guard let table = cmark_find_syntax_extension("table"),
      let node = cmark_node_new_with_ext(ExtensionNodeTypes.shared.CMARK_NODE_TABLE_CELL, table)
    else {
      return nil
    }
    tableCell.content.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
    return node
  }

  fileprivate static func make(_ inline: InlineNode) -> UnsafeNode? {
    switch inline {
    case .text(let content):
      guard let node = cmark_node_new(CMARK_NODE_TEXT) else { return nil }
      cmark_node_set_literal(node, content)
      return node
    case .softBreak:
      return cmark_node_new(CMARK_NODE_SOFTBREAK)
    case .lineBreak:
      return cmark_node_new(CMARK_NODE_LINEBREAK)
    case .code(let content):
      guard let node = cmark_node_new(CMARK_NODE_CODE) else { return nil }
      cmark_node_set_literal(node, content)
      return node
    case .html(let content):
      guard let node = cmark_node_new(CMARK_NODE_HTML_INLINE) else { return nil }
      cmark_node_set_literal(node, content)
      return node
    case .emphasis(let children):
      guard let node = cmark_node_new(CMARK_NODE_EMPH) else { return nil }
      children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .strong(let children):
      guard let node = cmark_node_new(CMARK_NODE_STRONG) else { return nil }
      children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .strikethrough(let children):
      guard let strikethrough = cmark_find_syntax_extension("strikethrough"),
        let node = cmark_node_new_with_ext(
          ExtensionNodeTypes.shared.CMARK_NODE_STRIKETHROUGH, strikethrough)
      else {
        return nil
      }
      children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .link(let destination, let children):
      guard let node = cmark_node_new(CMARK_NODE_LINK) else { return nil }
      cmark_node_set_url(node, destination)
      children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    case .image(let source, let children):
      guard let node = cmark_node_new(CMARK_NODE_IMAGE) else { return nil }
      cmark_node_set_url(node, source)
      children.compactMap(UnsafeNode.make).forEach { cmark_node_append_child(node, $0) }
      return node
    }
  }
}

private enum NodeType: String {
  case document
  case blockquote = "block_quote"
  case list
  case item
  case codeBlock = "code_block"
  case htmlBlock = "html_block"
  case customBlock = "custom_block"
  case paragraph
  case heading
  case thematicBreak = "thematic_break"
  case text
  case softBreak = "softbreak"
  case lineBreak = "linebreak"
  case code
  case html = "html_inline"
  case customInline = "custom_inline"
  case emphasis = "emph"
  case strong
  case link
  case image
  case inlineAttributes = "attribute"
  case none = "NONE"
  case unknown = "<unknown>"

  // Extensions

  case strikethrough
  case table
  case tableHead = "table_header"
  case tableRow = "table_row"
  case tableCell = "table_cell"
  case taskListItem = "tasklist"
}

private struct UnsafeNodeSequence: Sequence {
  struct Iterator: IteratorProtocol {
    private var node: UnsafeNode?

    init(_ node: UnsafeNode?) {
      self.node = node
    }

    mutating func next() -> UnsafeNode? {
      guard let node else { return nil }
      defer { self.node = cmark_node_next(node) }
      return node
    }
  }

  private let node: UnsafeNode?

  init(_ node: UnsafeNode?) {
    self.node = node
  }

  func makeIterator() -> Iterator {
    .init(self.node)
  }
}

// Extension node types are not exported in `cmark_gfm_extensions`,
// so we need to look for them in the symbol table
private struct ExtensionNodeTypes {
  let CMARK_NODE_TABLE: cmark_node_type
  let CMARK_NODE_TABLE_ROW: cmark_node_type
  let CMARK_NODE_TABLE_CELL: cmark_node_type
  let CMARK_NODE_STRIKETHROUGH: cmark_node_type

  static let shared = ExtensionNodeTypes()

  private init() {
    func findNodeType(_ name: String, in handle: UnsafeMutableRawPointer!) -> cmark_node_type? {
      guard let symbol = dlsym(handle, name) else {
        return nil
      }
      return symbol.assumingMemoryBound(to: cmark_node_type.self).pointee
    }

    let handle = dlopen(nil, RTLD_LAZY)

    self.CMARK_NODE_TABLE = findNodeType("CMARK_NODE_TABLE", in: handle) ?? CMARK_NODE_NONE
    self.CMARK_NODE_TABLE_ROW = findNodeType("CMARK_NODE_TABLE_ROW", in: handle) ?? CMARK_NODE_NONE
    self.CMARK_NODE_TABLE_CELL =
      findNodeType("CMARK_NODE_TABLE_CELL", in: handle) ?? CMARK_NODE_NONE
    self.CMARK_NODE_STRIKETHROUGH =
      findNodeType("CMARK_NODE_STRIKETHROUGH", in: handle) ?? CMARK_NODE_NONE

    dlclose(handle)
  }
}



================================================
FILE: Sources/MarkdownUI/Renderer/AttributedStringInlineRenderer.swift
================================================
import Foundation

extension InlineNode {
  func renderAttributedString(
    baseURL: URL?,
    textStyles: InlineTextStyles,
    softBreakMode: SoftBreak.Mode,
    attributes: AttributeContainer
  ) -> AttributedString {
    var renderer = AttributedStringInlineRenderer(
      baseURL: baseURL,
      textStyles: textStyles,
      softBreakMode: softBreakMode,
      attributes: attributes
    )
    renderer.render(self)
    return renderer.result.resolvingFonts()
  }
}

private struct AttributedStringInlineRenderer {
  var result = AttributedString()

  private let baseURL: URL?
  private let textStyles: InlineTextStyles
  private let softBreakMode: SoftBreak.Mode
  private var attributes: AttributeContainer
  private var shouldSkipNextWhitespace = false

  init(
    baseURL: URL?,
    textStyles: InlineTextStyles,
    softBreakMode: SoftBreak.Mode,
    attributes: AttributeContainer
  ) {
    self.baseURL = baseURL
    self.textStyles = textStyles
    self.softBreakMode = softBreakMode
    self.attributes = attributes
  }

  mutating func render(_ inline: InlineNode) {
    switch inline {
    case .text(let content):
      self.renderText(content)
    case .softBreak:
      self.renderSoftBreak()
    case .lineBreak:
      self.renderLineBreak()
    case .code(let content):
      self.renderCode(content)
    case .html(let content):
      self.renderHTML(content)
    case .emphasis(let children):
      self.renderEmphasis(children: children)
    case .strong(let children):
      self.renderStrong(children: children)
    case .strikethrough(let children):
      self.renderStrikethrough(children: children)
    case .link(let destination, let children):
      self.renderLink(destination: destination, children: children)
    case .image(let source, let children):
      self.renderImage(source: source, children: children)
    }
  }

  private mutating func renderText(_ text: String) {
    var text = text

    if self.shouldSkipNextWhitespace {
      self.shouldSkipNextWhitespace = false
      text = text.replacingOccurrences(of: "^\\s+", with: "", options: .regularExpression)
    }

    self.result += .init(text, attributes: self.attributes)
  }

  private mutating func renderSoftBreak() {
    switch softBreakMode {
    case .space where self.shouldSkipNextWhitespace:
      self.shouldSkipNextWhitespace = false
    case .space:
      self.result += .init(" ", attributes: self.attributes)
    case .lineBreak:
      self.renderLineBreak()
    }
  }

  private mutating func renderLineBreak() {
    self.result += .init("\n", attributes: self.attributes)
  }

  private mutating func renderCode(_ code: String) {
    self.result += .init(code, attributes: self.textStyles.code.mergingAttributes(self.attributes))
  }

  private mutating func renderHTML(_ html: String) {
    let tag = HTMLTag(html)

    switch tag?.name.lowercased() {
    case "br":
      self.renderLineBreak()
      self.shouldSkipNextWhitespace = true
    default:
      self.renderText(html)
    }
  }

  private mutating func renderEmphasis(children: [InlineNode]) {
    let savedAttributes = self.attributes
    self.attributes = self.textStyles.emphasis.mergingAttributes(self.attributes)

    for child in children {
      self.render(child)
    }

    self.attributes = savedAttributes
  }

  private mutating func renderStrong(children: [InlineNode]) {
    let savedAttributes = self.attributes
    self.attributes = self.textStyles.strong.mergingAttributes(self.attributes)

    for child in children {
      self.render(child)
    }

    self.attributes = savedAttributes
  }

  private mutating func renderStrikethrough(children: [InlineNode]) {
    let savedAttributes = self.attributes
    self.attributes = self.textStyles.strikethrough.mergingAttributes(self.attributes)

    for child in children {
      self.render(child)
    }

    self.attributes = savedAttributes
  }

  private mutating func renderLink(destination: String, children: [InlineNode]) {
    let savedAttributes = self.attributes
    self.attributes = self.textStyles.link.mergingAttributes(self.attributes)
    self.attributes.link = URL(string: destination, relativeTo: self.baseURL)

    for child in children {
      self.render(child)
    }

    self.attributes = savedAttributes
  }

  private mutating func renderImage(source: String, children: [InlineNode]) {
    // AttributedString does not support images
  }
}

extension TextStyle {
  fileprivate func mergingAttributes(_ attributes: AttributeContainer) -> AttributeContainer {
    var newAttributes = attributes
    self._collectAttributes(in: &newAttributes)
    return newAttributes
  }
}



================================================
FILE: Sources/MarkdownUI/Renderer/InlineTextStyles.swift
================================================
import Foundation

struct InlineTextStyles {
  let code: TextStyle
  let emphasis: TextStyle
  let strong: TextStyle
  let strikethrough: TextStyle
  let link: TextStyle
}



================================================
FILE: Sources/MarkdownUI/Renderer/TextInlineRenderer.swift
================================================
import SwiftUI

extension Sequence where Element == InlineNode {
  func renderText(
    baseURL: URL?,
    textStyles: InlineTextStyles,
    images: [String: Image],
    softBreakMode: SoftBreak.Mode,
    attributes: AttributeContainer
  ) -> Text {
    var renderer = TextInlineRenderer(
      baseURL: baseURL,
      textStyles: textStyles,
      images: images,
      softBreakMode: softBreakMode,
      attributes: attributes
    )
    renderer.render(self)
    return renderer.result
  }
}

private struct TextInlineRenderer {
  var result = Text("")

  private let baseURL: URL?
  private let textStyles: InlineTextStyles
  private let images: [String: Image]
  private let softBreakMode: SoftBreak.Mode
  private let attributes: AttributeContainer
  private var shouldSkipNextWhitespace = false

  init(
    baseURL: URL?,
    textStyles: InlineTextStyles,
    images: [String: Image],
    softBreakMode: SoftBreak.Mode,
    attributes: AttributeContainer
  ) {
    self.baseURL = baseURL
    self.textStyles = textStyles
    self.images = images
    self.softBreakMode = softBreakMode
    self.attributes = attributes
  }

  mutating func render<S: Sequence>(_ inlines: S) where S.Element == InlineNode {
    for inline in inlines {
      self.render(inline)
    }
  }

  private mutating func render(_ inline: InlineNode) {
    switch inline {
    case .text(let content):
      self.renderText(content)
    case .softBreak:
      self.renderSoftBreak()
    case .html(let content):
      self.renderHTML(content)
    case .image(let source, _):
      self.renderImage(source)
    default:
      self.defaultRender(inline)
    }
  }

  private mutating func renderText(_ text: String) {
    var text = text

    if self.shouldSkipNextWhitespace {
      self.shouldSkipNextWhitespace = false
      text = text.replacingOccurrences(of: "^\\s+", with: "", options: .regularExpression)
    }

    self.defaultRender(.text(text))
  }

  private mutating func renderSoftBreak() {
    switch self.softBreakMode {
    case .space where self.shouldSkipNextWhitespace:
      self.shouldSkipNextWhitespace = false
    case .space:
      self.defaultRender(.softBreak)
    case .lineBreak:
      self.shouldSkipNextWhitespace = true
      self.defaultRender(.lineBreak)
    }
  }

  private mutating func renderHTML(_ html: String) {
    let tag = HTMLTag(html)

    switch tag?.name.lowercased() {
    case "br":
      self.defaultRender(.lineBreak)
      self.shouldSkipNextWhitespace = true
    default:
      self.defaultRender(.html(html))
    }
  }

  private mutating func renderImage(_ source: String) {
    if let image = self.images[source] {
      self.result = self.result + Text(image)
    }
  }

  private mutating func defaultRender(_ inline: InlineNode) {
    self.result =
      self.result
      + Text(
        inline.renderAttributedString(
          baseURL: self.baseURL,
          textStyles: self.textStyles,
          softBreakMode: self.softBreakMode,
          attributes: self.attributes
        )
      )
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/Theme+Basic.swift
================================================
import SwiftUI

extension Theme {
  /// The default Markdown theme.
  ///
  /// Style | Preview
  /// --- | ---
  /// Inline text | ![](BasicInlines)
  /// Headings | ![](Heading)
  /// Blockquote | ![](BlockquoteContent)
  /// Code block | ![](CodeBlock)
  /// Image | ![](Paragraph)
  /// Task list | ![](TaskList)
  /// Bulleted list | ![](NestedBulletedList)
  /// Numbered list | ![](NumberedList)
  /// Table | ![](Table-Collection)
  public static let basic = Theme()
    .code {
      FontFamilyVariant(.monospaced)
      FontSize(.em(0.94))
    }
    .heading1 { configuration in
      configuration.label
        .markdownMargin(top: .rem(1.5), bottom: .rem(1))
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(2))
        }
    }
    .heading2 { configuration in
      configuration.label
        .markdownMargin(top: .rem(1.5), bottom: .rem(1))
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1.5))
        }
    }
    .heading3 { configuration in
      configuration.label
        .markdownMargin(top: .rem(1.5), bottom: .rem(1))
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1.17))
        }
    }
    .heading4 { configuration in
      configuration.label
        .markdownMargin(top: .rem(1.5), bottom: .rem(1))
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1))
        }
    }
    .heading5 { configuration in
      configuration.label
        .markdownMargin(top: .rem(1.5), bottom: .rem(1))
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(0.83))
        }
    }
    .heading6 { configuration in
      configuration.label
        .markdownMargin(top: .rem(1.5), bottom: .rem(1))
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(0.67))
        }
    }
    .paragraph { configuration in
      configuration.label
        .fixedSize(horizontal: false, vertical: true)
        .relativeLineSpacing(.em(0.15))
        .markdownMargin(top: .zero, bottom: .em(1))
    }
    .blockquote { configuration in
      configuration.label
        .markdownTextStyle {
          FontStyle(.italic)
        }
        .relativePadding(.leading, length: .em(2))
        .relativePadding(.trailing, length: .em(1))
    }
    .codeBlock { configuration in
      ScrollView(.horizontal) {
        configuration.label
          .fixedSize(horizontal: false, vertical: true)
          .relativeLineSpacing(.em(0.15))
          .relativePadding(.leading, length: .rem(1))
          .markdownTextStyle {
            FontFamilyVariant(.monospaced)
            FontSize(.em(0.94))
          }
      }
      .markdownMargin(top: .zero, bottom: .em(1))
    }
    .table { configuration in
      configuration.label
        .fixedSize(horizontal: false, vertical: true)
        .markdownMargin(top: .zero, bottom: .em(1))
    }
    .tableCell { configuration in
      configuration.label
        .markdownTextStyle {
          if configuration.row == 0 {
            FontWeight(.semibold)
          }
        }
        .fixedSize(horizontal: false, vertical: true)
        .relativeLineSpacing(.em(0.15))
        .relativePadding(.horizontal, length: .em(0.72))
        .relativePadding(.vertical, length: .em(0.35))
    }
    .thematicBreak {
      Divider().markdownMargin(top: .em(2), bottom: .em(2))
    }
}



================================================
FILE: Sources/MarkdownUI/Theme/Theme+DocC.swift
================================================
import SwiftUI

extension Theme {
  /// A theme that mimics the DocC style.
  ///
  /// Style | Preview
  /// --- | ---
  /// Inline text | ![](DocCInlines)
  /// Headings | ![](DocCHeading)
  /// Blockquote | ![](DocCBlockquote)
  /// Code block | ![](DocCCodeBlock)
  /// Image | ![](DocCImage)
  /// Task list | Not applicable
  /// Bulleted list | ![](DocCNestedBulletedList)
  /// Numbered list | ![](DocCNumberedList)
  /// Table | ![](DocCTable)
  public static let docC = Theme()
    .text {
      ForegroundColor(.text)
    }
    .link {
      ForegroundColor(.link)
    }
    .heading1 { configuration in
      configuration.label
        .markdownMargin(top: .em(0.8), bottom: .zero)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(2))
        }
    }
    .heading2 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.0625))
        .markdownMargin(top: .em(1.6), bottom: .zero)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1.88235))
        }
    }
    .heading3 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.07143))
        .markdownMargin(top: .em(1.6), bottom: .zero)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1.64706))
        }
    }
    .heading4 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.083335))
        .markdownMargin(top: .em(1.6), bottom: .zero)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1.41176))
        }
    }
    .heading5 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.09091))
        .markdownMargin(top: .em(1.6), bottom: .zero)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1.29412))
        }
    }
    .heading6 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.235295))
        .markdownMargin(top: .em(1.6), bottom: .zero)
        .markdownTextStyle {
          FontWeight(.semibold)
        }
    }
    .paragraph { configuration in
      configuration.label
        .fixedSize(horizontal: false, vertical: true)
        .relativeLineSpacing(.em(0.235295))
        .markdownMargin(top: .em(0.8), bottom: .zero)
    }
    .blockquote { configuration in
      configuration.label
        .relativePadding(length: .rem(0.94118))
        .frame(maxWidth: .infinity, alignment: .leading)
        .background {
          ZStack {
            RoundedRectangle.container
              .fill(Color.asideNoteBackground)
            RoundedRectangle.container
              .strokeBorder(Color.asideNoteBorder)
          }
        }
        .markdownMargin(top: .em(1.6), bottom: .zero)
    }
    .codeBlock { configuration in
      ScrollView(.horizontal) {
        configuration.label
          .fixedSize(horizontal: false, vertical: true)
          .relativeLineSpacing(.em(0.333335))
          .markdownTextStyle {
            FontFamilyVariant(.monospaced)
            FontSize(.rem(0.88235))
          }
          .padding(.vertical, 8)
          .padding(.leading, 14)
      }
      .background(Color.codeBackground)
      .clipShape(.container)
      .markdownMargin(top: .em(0.8), bottom: .zero)
    }
    .image { configuration in
      configuration.label
        .frame(maxWidth: .infinity)
        .markdownMargin(top: .em(1.6), bottom: .em(1.6))
    }
    .listItem { configuration in
      configuration.label
        .markdownMargin(top: .em(0.8))
    }
    .taskListMarker { _ in
      // DocC renders task lists as bullet lists
      ListBullet.disc
        .relativeFrame(minWidth: .em(1.5), alignment: .trailing)
    }
    .table { configuration in
      configuration.label
        .fixedSize(horizontal: false, vertical: true)
        .markdownTableBorderStyle(.init(.horizontalBorders, color: .grid))
        .markdownMargin(top: .em(1.6), bottom: .zero)
    }
    .tableCell { configuration in
      configuration.label
        .markdownTextStyle {
          if configuration.row == 0 {
            FontWeight(.semibold)
          }
        }
        .fixedSize(horizontal: false, vertical: true)
        .relativeLineSpacing(.em(0.235295))
        .relativePadding(length: .rem(0.58824))
    }
    .thematicBreak {
      Divider()
        .overlay(Color.grid)
        .markdownMargin(top: .em(2.35), bottom: .em(2.35))
    }
}

extension Shape where Self == RoundedRectangle {
  fileprivate static var container: Self {
    .init(cornerRadius: 15, style: .continuous)
  }
}

extension Color {
  fileprivate static let text = Color(
    light: Color(rgba: 0x1d1d_1fff), dark: Color(rgba: 0xf5f5_f7ff)
  )
  fileprivate static let secondaryLabel = Color(
    light: Color(rgba: 0x6e6e_73ff), dark: Color(rgba: 0x8686_8bff)
  )
  fileprivate static let link = Color(
    light: Color(rgba: 0x0066_ccff), dark: Color(rgba: 0x2997_ffff)
  )
  fileprivate static let asideNoteBackground = Color(
    light: Color(rgba: 0xf5f5_f7ff), dark: Color(rgba: 0x3232_32ff)
  )
  fileprivate static let asideNoteBorder = Color(
    light: Color(rgba: 0x6969_69ff), dark: Color(rgba: 0x9a9a_9eff)
  )
  fileprivate static let codeBackground = Color(
    light: Color(rgba: 0xf5f5_f7ff), dark: Color(rgba: 0x3333_36ff)
  )
  fileprivate static let grid = Color(
    light: Color(rgba: 0xd2d2_d7ff), dark: Color(rgba: 0x4242_45ff)
  )
}



================================================
FILE: Sources/MarkdownUI/Theme/Theme+GitHub.swift
================================================
import SwiftUI

extension Theme {
  /// A theme that mimics the GitHub style.
  ///
  /// Style | Preview
  /// --- | ---
  /// Inline text | ![](GitHubInlines)
  /// Headings | ![](GitHubHeading)
  /// Blockquote | ![](GitHubBlockquote)
  /// Code block | ![](GitHubCodeBlock)
  /// Image | ![](GitHubImage)
  /// Task list | ![](GitHubTaskList)
  /// Bulleted list | ![](GitHubNestedBulletedList)
  /// Numbered list | ![](GitHubNumberedList)
  /// Table | ![](GitHubTable)
  public static let gitHub = Theme()
    .text {
      ForegroundColor(.text)
      BackgroundColor(.background)
      FontSize(16)
    }
    .code {
      FontFamilyVariant(.monospaced)
      FontSize(.em(0.85))
      BackgroundColor(.secondaryBackground)
    }
    .strong {
      FontWeight(.semibold)
    }
    .link {
      ForegroundColor(.link)
    }
    .heading1 { configuration in
      VStack(alignment: .leading, spacing: 0) {
        configuration.label
          .relativePadding(.bottom, length: .em(0.3))
          .relativeLineSpacing(.em(0.125))
          .markdownMargin(top: 24, bottom: 16)
          .markdownTextStyle {
            FontWeight(.semibold)
            FontSize(.em(2))
          }
        Divider().overlay(Color.divider)
      }
    }
    .heading2 { configuration in
      VStack(alignment: .leading, spacing: 0) {
        configuration.label
          .relativePadding(.bottom, length: .em(0.3))
          .relativeLineSpacing(.em(0.125))
          .markdownMargin(top: 24, bottom: 16)
          .markdownTextStyle {
            FontWeight(.semibold)
            FontSize(.em(1.5))
          }
        Divider().overlay(Color.divider)
      }
    }
    .heading3 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.125))
        .markdownMargin(top: 24, bottom: 16)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(1.25))
        }
    }
    .heading4 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.125))
        .markdownMargin(top: 24, bottom: 16)
        .markdownTextStyle {
          FontWeight(.semibold)
        }
    }
    .heading5 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.125))
        .markdownMargin(top: 24, bottom: 16)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(0.875))
        }
    }
    .heading6 { configuration in
      configuration.label
        .relativeLineSpacing(.em(0.125))
        .markdownMargin(top: 24, bottom: 16)
        .markdownTextStyle {
          FontWeight(.semibold)
          FontSize(.em(0.85))
          ForegroundColor(.tertiaryText)
        }
    }
    .paragraph { configuration in
      configuration.label
        .fixedSize(horizontal: false, vertical: true)
        .relativeLineSpacing(.em(0.25))
        .markdownMargin(top: 0, bottom: 16)
    }
    .blockquote { configuration in
      HStack(spacing: 0) {
        RoundedRectangle(cornerRadius: 6)
          .fill(Color.border)
          .relativeFrame(width: .em(0.2))
        configuration.label
          .markdownTextStyle { ForegroundColor(.secondaryText) }
          .relativePadding(.horizontal, length: .em(1))
      }
      .fixedSize(horizontal: false, vertical: true)
    }
    .codeBlock { configuration in
      ScrollView(.horizontal) {
        configuration.label
          .fixedSize(horizontal: false, vertical: true)
          .relativeLineSpacing(.em(0.225))
          .markdownTextStyle {
            FontFamilyVariant(.monospaced)
            FontSize(.em(0.85))
          }
          .padding(16)
      }
      .background(Color.secondaryBackground)
      .clipShape(RoundedRectangle(cornerRadius: 6))
      .markdownMargin(top: 0, bottom: 16)
    }
    .listItem { configuration in
      configuration.label
        .markdownMargin(top: .em(0.25))
    }
    .taskListMarker { configuration in
      Image(systemName: configuration.isCompleted ? "checkmark.square.fill" : "square")
        .symbolRenderingMode(.hierarchical)
        .foregroundStyle(Color.checkbox, Color.checkboxBackground)
        .imageScale(.small)
        .relativeFrame(minWidth: .em(1.5), alignment: .trailing)
    }
    .table { configuration in
      configuration.label
        .fixedSize(horizontal: false, vertical: true)
        .markdownTableBorderStyle(.init(color: .border))
        .markdownTableBackgroundStyle(
          .alternatingRows(Color.background, Color.secondaryBackground)
        )
        .markdownMargin(top: 0, bottom: 16)
    }
    .tableCell { configuration in
      configuration.label
        .markdownTextStyle {
          if configuration.row == 0 {
            FontWeight(.semibold)
          }
          BackgroundColor(nil)
        }
        .fixedSize(horizontal: false, vertical: true)
        .padding(.vertical, 6)
        .padding(.horizontal, 13)
        .relativeLineSpacing(.em(0.25))
    }
    .thematicBreak {
      Divider()
        .relativeFrame(height: .em(0.25))
        .overlay(Color.border)
        .markdownMargin(top: 24, bottom: 24)
    }
}

extension Color {
  fileprivate static let text = Color(
    light: Color(rgba: 0x0606_06ff), dark: Color(rgba: 0xfbfb_fcff)
  )
  fileprivate static let secondaryText = Color(
    light: Color(rgba: 0x6b6e_7bff), dark: Color(rgba: 0x9294_a0ff)
  )
  fileprivate static let tertiaryText = Color(
    light: Color(rgba: 0x6b6e_7bff), dark: Color(rgba: 0x6d70_7dff)
  )
  fileprivate static let background = Color(
    light: .white, dark: Color(rgba: 0x1819_1dff)
  )
  fileprivate static let secondaryBackground = Color(
    light: Color(rgba: 0xf7f7_f9ff), dark: Color(rgba: 0x2526_2aff)
  )
  fileprivate static let link = Color(
    light: Color(rgba: 0x2c65_cfff), dark: Color(rgba: 0x4c8e_f8ff)
  )
  fileprivate static let border = Color(
    light: Color(rgba: 0xe4e4_e8ff), dark: Color(rgba: 0x4244_4eff)
  )
  fileprivate static let divider = Color(
    light: Color(rgba: 0xd0d0_d3ff), dark: Color(rgba: 0x3334_38ff)
  )
  fileprivate static let checkbox = Color(rgba: 0xb9b9_bbff)
  fileprivate static let checkboxBackground = Color(rgba: 0xeeee_efff)
}



================================================
FILE: Sources/MarkdownUI/Theme/Theme.swift
================================================
import SwiftUI

/// A type that applies a custom appearance to blocks and text inlines in a Markdown view.
///
/// A theme combines the different text and block styles you can customize in a ``Markdown`` view.
///
/// You can set the current Markdown theme in a view hierarchy by using the `markdownTheme(_:)` modifier.
///
/// ```swift
/// Markdown {
///   """
///   You can quote text with a `>`.
///
///   > Outside of a dog, a book is man's best friend. Inside of a
///   > dog it's too dark to read.
///
///   – Groucho Marx
///   """
/// }
/// .markdownTheme(.gitHub)
/// ```
///
/// ![](GitHubBlockquote)
///
/// To override a specific text style from the current theme, use the `markdownTextStyle(_:textStyle:)`
/// modifier.  The following example shows how to override the ``Theme/code`` text style.
///
/// ```swift
/// Markdown {
///   """
///   Use `git status` to list all new or modified files
///   that haven't yet been committed.
///   """
/// }
/// .markdownTextStyle(\.code) {
///   FontFamilyVariant(.monospaced)
///   FontSize(.em(0.85))
///   ForegroundColor(.purple)
///   BackgroundColor(.purple.opacity(0.25))
/// }
/// ```
///
/// ![](CustomInlineCode)
///
/// You can also use the `markdownBlockStyle(_:body:)` modifier to override a specific block style. For example, you can
/// override only the ``Theme/blockquote`` block style, leaving other block styles untouched.
///
/// ```swift
/// Markdown {
///   """
///   You can quote text with a `>`.
///
///   > Outside of a dog, a book is man's best friend. Inside of a
///   > dog it's too dark to read.
///
///   – Groucho Marx
///   """
/// }
/// .markdownBlockStyle(\.blockquote) { configuration in
///   configuration.label
///     .padding()
///     .markdownTextStyle {
///       FontCapsVariant(.lowercaseSmallCaps)
///       FontWeight(.semibold)
///       BackgroundColor(nil)
///     }
///     .overlay(alignment: .leading) {
///       Rectangle()
///         .fill(Color.teal)
///         .frame(width: 4)
///     }
///     .background(Color.teal.opacity(0.5))
/// }
/// ```
///
/// ![](CustomBlockquote)
///
/// To create a theme, start by instantiating an empty `Theme` and chain together the different text and
/// block styles in a single expression.
///
/// ```swift
/// let myTheme = Theme()
///   .code {
///     FontFamilyVariant(.monospaced)
///     FontSize(.em(0.85))
///   }
///   .link {
///     ForegroundColor(.purple)
///   }
///   // More text styles...
///   .paragraph { configuration in
///     configuration.label
///       .relativeLineSpacing(.em(0.25))
///       .markdownMargin(top: 0, bottom: 16)
///   }
///   .listItem { configuration in
///     configuration.label
///       .markdownMargin(top: .em(0.25))
///   }
///   // More block styles...
/// ```
public struct Theme: Sendable {
  /// The default text style.
  public var text: TextStyle = EmptyTextStyle()

  /// The inline code style.
  public var code: TextStyle = FontFamilyVariant(.monospaced)

  /// The emphasis style.
  public var emphasis: TextStyle = FontStyle(.italic)

  /// The strong style.
  public var strong: TextStyle = FontWeight(.semibold)

  /// The strikethrough style.
  public var strikethrough: TextStyle = StrikethroughStyle(.single)

  /// The link style.
  public var link: TextStyle = EmptyTextStyle()

  var headings = Array(
    repeating: BlockStyle<BlockConfiguration> { $0.label },
    count: 6
  )

  /// The level 1 heading style.
  public var heading1: BlockStyle<BlockConfiguration> {
    get { self.headings[0] }
    set { self.headings[0] = newValue }
  }

  /// The level 2 heading style.
  public var heading2: BlockStyle<BlockConfiguration> {
    get { self.headings[1] }
    set { self.headings[1] = newValue }
  }

  /// The level 3 heading style.
  public var heading3: BlockStyle<BlockConfiguration> {
    get { self.headings[2] }
    set { self.headings[2] = newValue }
  }

  /// The level 4 heading style.
  public var heading4: BlockStyle<BlockConfiguration> {
    get { self.headings[3] }
    set { self.headings[3] = newValue }
  }

  /// The level 5 heading style.
  public var heading5: BlockStyle<BlockConfiguration> {
    get { self.headings[4] }
    set { self.headings[4] = newValue }
  }

  /// The level 6 heading style.
  public var heading6: BlockStyle<BlockConfiguration> {
    get { self.headings[5] }
    set { self.headings[5] = newValue }
  }

  /// The paragraph style.
  public var paragraph = BlockStyle<BlockConfiguration> { $0.label }

  /// The blockquote style.
  public var blockquote = BlockStyle<BlockConfiguration> { $0.label }

  /// The code block style.
  public var codeBlock = BlockStyle<CodeBlockConfiguration> { $0.label }

  /// The image style.
  public var image = BlockStyle<BlockConfiguration> { $0.label }

  /// The list style.
  public var list = BlockStyle<BlockConfiguration> { $0.label }

  /// The list item style.
  public var listItem = BlockStyle<BlockConfiguration> { $0.label }

  /// The task list marker style.
  public var taskListMarker = BlockStyle.checkmarkSquare

  /// The bulleted list marker style.
  public var bulletedListMarker = BlockStyle.discCircleSquare

  /// The numbered list marker style.
  public var numberedListMarker = BlockStyle.decimal

  /// The table style.
  public var table = BlockStyle<BlockConfiguration> { $0.label }

  /// The table cell style.
  public var tableCell = BlockStyle<TableCellConfiguration> { $0.label }

  /// The thematic break style.
  public var thematicBreak = BlockStyle { Divider() }

  /// Creates a theme with default text styles.
  public init() {}
}

extension Theme {
  /// Adds a default text style to the theme.
  /// - Parameter text: A text style builder that returns the default text style.
  public func text<S: TextStyle>(@TextStyleBuilder text: () -> S) -> Theme {
    var theme = self
    theme.text = text()
    return theme
  }

  /// Adds an inline code style to the theme.
  /// - Parameter code: A text style builder that returns the inline code style.
  public func code<S: TextStyle>(@TextStyleBuilder code: () -> S) -> Theme {
    var theme = self
    theme.code = code()
    return theme
  }

  /// Adds an emphasis style to the theme.
  /// - Parameter emphasis: A text style builder that returns the emphasis style.
  public func emphasis<S: TextStyle>(@TextStyleBuilder emphasis: () -> S) -> Theme {
    var theme = self
    theme.emphasis = emphasis()
    return theme
  }

  /// Adds a strong style to the theme.
  /// - Parameter strong: A text style builder that returns the strong style.
  public func strong<S: TextStyle>(@TextStyleBuilder strong: () -> S) -> Theme {
    var theme = self
    theme.strong = strong()
    return theme
  }

  /// Adds a strikethrough style to the theme.
  /// - Parameter strikethrough: A text style builder that returns the strikethrough style.
  public func strikethrough<S: TextStyle>(@TextStyleBuilder strikethrough: () -> S) -> Theme {
    var theme = self
    theme.strikethrough = strikethrough()
    return theme
  }

  /// Adds a link style to the theme.
  /// - Parameter link: A text style builder that returns the link style.
  public func link<S: TextStyle>(@TextStyleBuilder link: () -> S) -> Theme {
    var theme = self
    theme.link = link()
    return theme
  }
}

extension Theme {
  /// Adds a level 1 heading style to the theme.
  /// - Parameter body: A view builder that returns a customized level 1 heading.
  public func heading1<Body: View>(
    @ViewBuilder body: @escaping (_ configuration: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.heading1 = .init(body: body)
    return theme
  }

  /// Adds a level 2 heading style to the theme.
  /// - Parameter body: A view builder that returns a customized level 2 heading.
  public func heading2<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.heading2 = .init(body: body)
    return theme
  }

  /// Adds a level 3 heading style to the theme.
  /// - Parameter body: A view builder that returns a customized level 3 heading.
  public func heading3<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.heading3 = .init(body: body)
    return theme
  }

  /// Adds a level 4 heading style to the theme.
  /// - Parameter body: A view builder that returns a customized level 4 heading.
  public func heading4<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.heading4 = .init(body: body)
    return theme
  }

  /// Adds a level 5 heading style to the theme.
  /// - Parameter body: A view builder that returns a customized level 5 heading.
  public func heading5<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.heading5 = .init(body: body)
    return theme
  }

  /// Adds a level 6 heading style to the theme.
  /// - Parameter body: A view builder that returns a customized level 6 heading.
  public func heading6<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.heading6 = .init(body: body)
    return theme
  }

  /// Adds a paragraph style to the theme.
  /// - Parameter body: A view builder that returns a customized paragraph.
  public func paragraph<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.paragraph = .init(body: body)
    return theme
  }

  /// Adds a blockquote style to the theme.
  /// - Parameter body: A view builder that returns a customized blockquote.
  public func blockquote<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.blockquote = .init(body: body)
    return theme
  }

  /// Adds a code block style to the theme.
  /// - Parameter body: A view builder that returns a customized code block.
  public func codeBlock<Body: View>(
    @ViewBuilder body: @escaping (_ configuration: CodeBlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.codeBlock = .init(body: body)
    return theme
  }

  /// Adds an image style to the theme.
  /// - Parameter body: A view builder that returns a customized image.
  public func image<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.image = .init(body: body)
    return theme
  }

  /// Adds a list style to the theme.
  /// - Parameter body: A view builder that returns a customized list.
  public func list<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.list = .init(body: body)
    return theme
  }

  /// Adds a list item style to the theme.
  /// - Parameter body: A view builder that returns a customized list item.
  public func listItem<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.listItem = .init(body: body)
    return theme
  }

  /// Adds a task list marker style to the theme.
  /// - Parameter body: A view builder that returns a customized task list marker.
  public func taskListMarker(_ taskListMarker: BlockStyle<TaskListMarkerConfiguration>) -> Theme {
    var theme = self
    theme.taskListMarker = taskListMarker
    return theme
  }

  /// Adds a task list marker style to the theme.
  /// - Parameter body: A view builder that returns a customized task list marker.
  public func taskListMarker<Body: View>(
    @ViewBuilder body: @escaping (_ configuration: TaskListMarkerConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.taskListMarker = .init(body: body)
    return theme
  }

  /// Adds a bulleted list marker style to the theme.
  /// - Parameter body: A view builder that returns a customized bulleted list marker.
  public func bulletedListMarker(
    _ bulletedListMarker: BlockStyle<ListMarkerConfiguration>
  ) -> Theme {
    var theme = self
    theme.bulletedListMarker = bulletedListMarker
    return theme
  }

  /// Adds a bulleted list marker style to the theme.
  /// - Parameter body: A view builder that returns a customized bulleted list marker.
  public func bulletedListMarker<Body: View>(
    @ViewBuilder body: @escaping (_ configuration: ListMarkerConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.bulletedListMarker = .init(body: body)
    return theme
  }

  /// Adds a numbered list marker style to the theme.
  /// - Parameter body: A view builder that returns a customized numbered list marker.
  public func numberedListMarker(
    _ numberedListMarker: BlockStyle<ListMarkerConfiguration>
  ) -> Theme {
    var theme = self
    theme.numberedListMarker = numberedListMarker
    return theme
  }

  /// Adds a numbered list marker style to the theme.
  /// - Parameter body: A view builder that returns a customized numbered list marker.
  public func numberedListMarker<Body: View>(
    @ViewBuilder body: @escaping (_ configuration: ListMarkerConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.numberedListMarker = .init(body: body)
    return theme
  }

  /// Adds a table style to the theme.
  /// - Parameter body: A view builder that returns a customized table.
  public func table<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.table = .init(body: body)
    return theme
  }

  /// Adds a table cell style to the theme.
  /// - Parameter body: A view builder that returns a customized table cell.
  public func tableCell<Body: View>(
    @ViewBuilder body: @escaping (_ configuration: TableCellConfiguration) -> Body
  ) -> Theme {
    var theme = self
    theme.tableCell = .init(body: body)
    return theme
  }

  /// Adds a thematic break style to the theme.
  /// - Parameter body: A view builder that returns a customized thematic break.
  public func thematicBreak<Body: View>(@ViewBuilder body: @escaping () -> Body) -> Theme {
    var theme = self
    theme.thematicBreak = .init(body: body)
    return theme
  }
}

extension Theme {
  /// The text background color of the theme extracted from the ``Theme/text`` style.
  public var textBackgroundColor: Color? {
    var attributes = AttributeContainer()
    self.text._collectAttributes(in: &attributes)
    return attributes.backgroundColor
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/BlockConfiguration.swift
================================================
import SwiftUI

/// The properties of a Markdown block.
///
/// Most theme ``BlockStyle`` instances receive a `BlockConfiguration` input in their
/// `body` closure. The configuration ``BlockConfiguration/label-swift.property``
/// property reflects the block's content.
public struct BlockConfiguration {
  /// A type-erased view of a Markdown block.
  public struct Label: View {
    init<L: View>(_ label: L) {
      self.body = AnyView(label)
    }

    public let body: AnyView
  }

  /// The Markdown block view.
  public let label: Label

  /// The content of the Markdown block.
  ///
  /// This property provides access to different representations of the block content.
  /// For example, you can use ``MarkdownContent/renderMarkdown()``
  /// to get the Markdown formatted text or ``MarkdownContent/renderPlainText()``
  /// to get the plain text of the block content.
  public let content: MarkdownContent
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/BlockStyle.swift
================================================
import SwiftUI

/// A type that applies a custom appearance to specific types of blocks in a Markdown view.
///
/// The styles of the different block types are brought together in a ``Theme``. You can customize
/// the style of a specific block type by using the `markdownBlockStyle(_:body:)` modifier.
///
/// The following example applies a custom appearance to each ``Theme/blockquote`` in
/// a ``Markdown`` view:
///
/// ```swift
/// Markdown {
///   """
///   You can quote text with a `>`.
///
///   > Outside of a dog, a book is man's best friend. Inside of a
///   > dog it's too dark to read.
///
///   – Groucho Marx
///   """
/// }
/// .markdownBlockStyle(\.blockquote) { configuration in
///   configuration.label
///     .padding()
///     .markdownTextStyle {
///       FontCapsVariant(.lowercaseSmallCaps)
///       FontWeight(.semibold)
///       BackgroundColor(nil)
///     }
///     .overlay(alignment: .leading) {
///       Rectangle()
///         .fill(Color.teal)
///         .frame(width: 4)
///     }
///     .background(Color.teal.opacity(0.5))
/// }
/// ```
///
/// ![](CustomBlockquote)
public struct BlockStyle<Configuration> {
  private let body: (Configuration) -> AnyView

  /// Creates a block style that customizes a block by applying the given body.
  /// - Parameter body: A view builder that returns the customized block.
  public init<Body: View>(@ViewBuilder body: @escaping (_ configuration: Configuration) -> Body) {
    self.body = { AnyView(body($0)) }
  }

  func makeBody(configuration: Configuration) -> AnyView {
    self.body(configuration)
  }
}

extension BlockStyle where Configuration == Void {
  /// Creates a block style for a block with no content, like a thematic break.
  /// - Parameter body: A view builder that returns the customized block.
  public init<Body: View>(@ViewBuilder body: @escaping () -> Body) {
    self.init { _ in
      body()
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/CodeBlockConfiguration.swift
================================================
import SwiftUI

/// The properties of a Markdown code block.
///
/// The theme ``Theme/codeBlock`` block style receives a `CodeBlockConfiguration`
/// input in its `body` closure.
public struct CodeBlockConfiguration {
  /// A type-erased view of a Markdown code block.
  public struct Label: View {
    init<L: View>(_ label: L) {
      self.body = AnyView(label)
    }

    public let body: AnyView
  }

  /// The code block language, if present.
  public let language: String?

  /// The code block contents.
  public let content: String

  /// The code block view.
  public let label: Label
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/ListBullet.swift
================================================
import SwiftUI

struct ListBullet: View {
  private let image: Image

  var body: some View {
    TextStyleAttributesReader { attributes in
      let fontSize = attributes.fontProperties?.scaledSize ?? FontProperties.defaultSize
      self.image.font(.system(size: round(fontSize / 3)))
    }
  }

  static var disc: Self {
    .init(image: .init(systemName: "circle.fill"))
  }

  static var circle: Self {
    .init(image: .init(systemName: "circle"))
  }

  static var square: Self {
    .init(image: .init(systemName: "square.fill"))
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/ListMarkerConfiguration.swift
================================================
import SwiftUI

/// The properties of a list marker in a markdown list.
///
/// The theme ``Theme/bulletedListMarker`` and ``Theme/numberedListMarker``
/// block styles receive a `ListMarkerConfiguration` input in their `body` closure.
public struct ListMarkerConfiguration {
  /// The list level (one-based) of the item to which the marker applies.
  public let listLevel: Int

  /// The position (one-based) of the item to which the marker applies.
  public let itemNumber: Int
}

extension BlockStyle where Configuration == ListMarkerConfiguration {
  /// A list marker style that uses decimal numbers beginning with 1.
  public static var decimal: Self {
    decimal(minWidth: .em(1.5), alignment: .trailing)
  }

  /// A list marker style that uses uppercase roman numerals beginning with `I`.
  public static var upperRoman: Self {
    upperRoman(minWidth: .em(1.5), alignment: .trailing)
  }

  /// A list marker style that uses lowercase roman numerals beginning with `i`.
  public static var lowerRoman: Self {
    lowerRoman(minWidth: .em(1.5), alignment: .trailing)
  }

  /// A list marker style that uses a dash.
  public static var dash: Self {
    dash(minWidth: .em(1.5), alignment: .trailing)
  }

  /// A list marker style that uses a filled circle.
  public static var disc: Self {
    disc(minWidth: .em(1.5), alignment: .trailing)
  }

  /// A list marker style that uses a hollow circle.
  public static var circle: Self {
    circle(minWidth: .em(1.5), alignment: .trailing)
  }

  /// A list marker style that uses a filled square.
  public static var square: Self {
    square(minWidth: .em(1.5), alignment: .trailing)
  }

  /// A list marker style that alternates between disc, circle, and square, depending on the list level.
  public static var discCircleSquare: Self {
    BlockStyle { configuration in
      let styles: [Self] = [.disc, .circle, .square]
      styles[min(configuration.listLevel, styles.count) - 1]
        .makeBody(configuration: configuration)
    }
  }
}

// MARK: Dynamic

extension BlockStyle where Configuration == ListMarkerConfiguration {
  /// A list marker style that uses decimal numbers beginning with 1.
  public static func decimal(minWidth: RelativeSize, alignment: Alignment = .center) -> Self {
    BlockStyle { configuration in
      Text("\(configuration.itemNumber).")
        .monospacedDigit()
        .relativeFrame(minWidth: minWidth, alignment: alignment)
    }
  }

  /// A list marker style that uses uppercase roman numerals beginning with `I`.
  public static func upperRoman(minWidth: RelativeSize, alignment: Alignment = .center) -> Self {
    BlockStyle { configuration in
      Text(configuration.itemNumber.roman + ".")
        .relativeFrame(minWidth: minWidth, alignment: alignment)
    }
  }

  /// A list marker style that uses lowercase roman numerals beginning with `i`.
  public static func lowerRoman(minWidth: RelativeSize, alignment: Alignment = .center) -> Self {
    BlockStyle { configuration in
      Text(configuration.itemNumber.roman.lowercased() + ".")
        .relativeFrame(minWidth: minWidth, alignment: alignment)
    }
  }

  /// A list marker style that uses a dash.
  public static func dash(minWidth: RelativeSize, alignment: Alignment = .center) -> Self {
    BlockStyle { _ in
      Text("-")
        .relativeFrame(minWidth: minWidth, alignment: alignment)
    }
  }

  /// A list marker style that uses a filled circle.
  public static func disc(minWidth: RelativeSize, alignment: Alignment = .center) -> Self {
    BlockStyle { _ in
      ListBullet.disc
        .relativeFrame(minWidth: minWidth, alignment: alignment)
    }
  }

  /// A list marker style that uses a hollow circle.
  public static func circle(minWidth: RelativeSize, alignment: Alignment = .center) -> Self {
    BlockStyle { _ in
      ListBullet.circle
        .relativeFrame(minWidth: minWidth, alignment: alignment)
    }
  }

  /// A list marker style that uses a filled square.
  public static func square(minWidth: RelativeSize, alignment: Alignment = .center) -> Self {
    BlockStyle { _ in
      ListBullet.square
        .relativeFrame(minWidth: minWidth, alignment: alignment)
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/TableBackgroundStyle.swift
================================================
import SwiftUI

/// A type that applies a custom background to tables in a Markdown view.
///
/// To customize the background of tables in a ``Markdown`` view, use the
/// `markdownTableBackgroundStyle(_:)` modifier inside the body of
/// the ``Theme/table`` block style.
///
/// The following example customizes the background of the odd rows in a table.
///
/// ```swift
/// Markdown {
///   """
///   | First Header  | Second Header |
///   | ------------- | ------------- |
///   | Content Cell  | Content Cell  |
///   | Content Cell  | Content Cell  |
///   | Content Cell  | Content Cell  |
///   """
/// }
/// .markdownBlockStyle(\.table) { configuration in
///   configuration.label
///     .markdownTableBackgroundStyle(
///       .alternatingRows(Color.teal.opacity(0.5), .clear, header: .clear)
///     )
/// }
/// ```
///
/// ![](CustomTableBackground)
public struct TableBackgroundStyle {
  let background: (_ row: Int, _ column: Int) -> AnyShapeStyle

  /// Creates a table background style that customizes table backgrounds by applying a given closure
  /// to the background of each cell.
  /// - Parameter background: A closure that returns a shape style for a given table cell location.
  public init<S: ShapeStyle>(background: @escaping (_ row: Int, _ column: Int) -> S) {
    self.background = { row, column in
      AnyShapeStyle(background(row, column))
    }
  }
}

extension TableBackgroundStyle {
  /// A clear color table background style.
  public static var clear: Self {
    TableBackgroundStyle { _, _ in Color.clear }
  }

  /// A table background style that alternates row background shape styles.
  /// - Parameters:
  ///   - odd: The shape style for odd rows.
  ///   - even: The shape style for even rows.
  ///   - header: The shape style for the header row. If `nil`, the odd row shape style is used.
  public static func alternatingRows<S: ShapeStyle>(_ odd: S, _ even: S, header: S? = nil) -> Self {
    TableBackgroundStyle { row, _ in
      guard row > 0 else {
        return header ?? odd
      }

      return row.isMultiple(of: 2) ? even : odd
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/TableBorderStyle.swift
================================================
import SwiftUI

/// A type that represents the appearance of table borders.
///
/// To customize the table borders in a ``Markdown`` view, use the `markdownTableBorderStyle(_:)`
/// modifier inside the body of the ``Theme/table`` block style.
///
/// The following example customizes the table style to display only the outside borders with a dashed stroke style.
///
/// ```swift
/// Markdown {
///   """
///   | First Header  | Second Header |
///   | ------------- | ------------- |
///   | Content Cell  | Content Cell  |
///   | Content Cell  | Content Cell  |
///   | Content Cell  | Content Cell  |
///   """
/// }
/// .markdownBlockStyle(\.table) { configuration in
///   configuration.label
///     .markdownTableBorderStyle(
///       TableBorderStyle(
///         .outsideBorders,
///         color: Color.mint,
///         strokeStyle: .init(lineWidth: 2, lineJoin: .round, dash: [4])
///       )
///     )
/// }
/// ```
///
/// ![](CustomTableBorders)
public struct TableBorderStyle {
  /// The visible table borders.
  public var visibleBorders: TableBorderSelector

  /// The table border color.
  public var color: Color

  /// The table border stroke style.
  public var strokeStyle: StrokeStyle

  /// Creates a table border style with the given visible borders, color, and stroke style.
  /// - Parameters:
  ///   - visibleBorders: The visible table borders.
  ///   - color: The table border color.
  ///   - strokeStyle: The table border stroke style.
  public init(
    _ visibleBorders: TableBorderSelector = .allBorders,
    color: Color,
    strokeStyle: StrokeStyle
  ) {
    self.visibleBorders = visibleBorders
    self.color = color
    self.strokeStyle = strokeStyle
  }

  /// Creates a table border style with the given visible borders, color, and line width.
  /// - Parameters:
  ///   - visibleBorders: The visible table borders.
  ///   - color: The table border color.
  ///   - width: The table border line width.
  public init(
    _ visibleBorders: TableBorderSelector = .allBorders,
    color: Color,
    width: CGFloat = 1
  ) {
    self.init(visibleBorders, color: color, strokeStyle: .init(lineWidth: width))
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/TableCellConfiguration.swift
================================================
import SwiftUI

/// The properties of a Markdown table cell.
///
/// The theme ``Theme/tableCell`` block style receives a `TableCellConfiguration`
/// input in its `body` closure.
public struct TableCellConfiguration {
  /// A type-erased view of a Markdown table cell.
  public struct Label: View {
    init<L: View>(_ label: L) {
      self.body = AnyView(label)
    }

    public let body: AnyView
  }

  /// The table cell row index.
  public let row: Int

  /// The table cell column index.
  public let column: Int

  /// The table cell view.
  public let label: Label

  /// The table cell content.
  public let content: MarkdownContent
}



================================================
FILE: Sources/MarkdownUI/Theme/BlockStyle/TaskListMarkerConfiguration.swift
================================================
import SwiftUI

/// The properties of a task list marker in a Markdown list.
///
/// The theme ``Theme/taskListMarker`` block style receives a `TaskListMarkerConfiguration`
/// input in its `body` closure.
public struct TaskListMarkerConfiguration {
  /// Determines whether the item to which the marker applies is completed or not.
  public let isCompleted: Bool
}

extension BlockStyle where Configuration == TaskListMarkerConfiguration {
  /// A task list marker style that displays a checkmark inside a square if the item is completed
  /// or a hollow square if the item is not completed.
  public static var checkmarkSquare: Self {
    BlockStyle { configuration in
      Image(systemName: configuration.isCompleted ? "checkmark.square.fill" : "square")
        .symbolRenderingMode(.hierarchical)
        .imageScale(.small)
        .relativeFrame(minWidth: .em(1.5), alignment: .trailing)
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/TextStyle.swift
================================================
import SwiftUI

/// The appearance of a text inline in a Markdown view.
///
/// The styles of the different text inline types are brought together in a ``Theme``. You can customize the style of a
/// specific inline type by using the `markdownTextStyle(_:textStyle:)` modifier and combining one or more
/// built-in text styles like ``ForegroundColor`` or ``FontWeight``.
///
/// The following example applies a custom text style to each ``Theme/code`` inline in a ``Markdown`` view.
///
/// ```swift
/// Markdown {
///   """
///   Use `git status` to list all new or modified files
///   that haven't yet been committed.
///   """
/// }
/// .markdownTextStyle(\.code) {
///   FontFamilyVariant(.monospaced)
///   FontSize(.em(0.85))
///   ForegroundColor(.purple)
///   BackgroundColor(.purple.opacity(0.25))
/// }
/// ```
///
/// ![](CustomInlineCode)
///
/// You can also override the default text style inside the body of any block style by using the `markdownTextStyle(textStyle:)`
/// modifier. For example, you can define a ``Theme/blockquote`` style that uses a semibold lowercase small-caps text style:
///
/// ```swift
/// Markdown {
///   """
///   You can quote text with a `>`.
///
///   > Outside of a dog, a book is man's best friend. Inside of a
///   > dog it's too dark to read.
///
///   – Groucho Marx
///   """
/// }
/// .markdownBlockStyle(\.blockquote) { configuration in
///   configuration.label
///     .padding()
///     .markdownTextStyle {
///       FontCapsVariant(.lowercaseSmallCaps)
///       FontWeight(.semibold)
///       BackgroundColor(nil)
///     }
///     .overlay(alignment: .leading) {
///       Rectangle()
///         .fill(Color.teal)
///         .frame(width: 4)
///     }
///     .background(Color.teal.opacity(0.5))
/// }
/// ```
///
/// ![](CustomBlockquote)
public protocol TextStyle {
  func _collectAttributes(in attributes: inout AttributeContainer)
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/TextStyleBuilder.swift
================================================
import Foundation

/// A result builder you can use to compose text styles.
@resultBuilder public enum TextStyleBuilder {
  public static func buildBlock() -> some TextStyle {
    EmptyTextStyle()
  }

  public static func buildBlock(_ component: some TextStyle) -> some TextStyle {
    component
  }

  public static func buildEither<S0: TextStyle, S1: TextStyle>(
    first component: S0
  ) -> _Conditional<S0, S1> {
    _Conditional<S0, S1>.first(component)
  }

  public static func buildEither<S0: TextStyle, S1: TextStyle>(
    second component: S1
  ) -> _Conditional<S0, S1> {
    _Conditional<S0, S1>.second(component)
  }

  public static func buildLimitedAvailability(
    _ component: some TextStyle
  ) -> any TextStyle {
    component
  }

  public static func buildOptional(_ component: (some TextStyle)?) -> some TextStyle {
    component
  }

  public static func buildPartialBlock(first: some TextStyle) -> some TextStyle {
    first
  }

  public static func buildPartialBlock(
    accumulated: some TextStyle,
    next: some TextStyle
  ) -> some TextStyle {
    Pair(accumulated, next)
  }

  public enum _Conditional<First: TextStyle, Second: TextStyle>: TextStyle {
    case first(First)
    case second(Second)

    public func _collectAttributes(in attributes: inout AttributeContainer) {
      switch self {
      case .first(let first):
        first._collectAttributes(in: &attributes)
      case .second(let second):
        second._collectAttributes(in: &attributes)
      }
    }
  }

  private struct Pair<S0: TextStyle, S1: TextStyle>: TextStyle {
    let s0: S0
    let s1: S1

    init(_ s0: S0, _ s1: S1) {
      self.s0 = s0
      self.s1 = s1
    }

    func _collectAttributes(in attributes: inout AttributeContainer) {
      s0._collectAttributes(in: &attributes)
      s1._collectAttributes(in: &attributes)
    }
  }
}

extension Optional: TextStyle where Wrapped: TextStyle {
  public func _collectAttributes(in attributes: inout AttributeContainer) {
    self?._collectAttributes(in: &attributes)
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/BackgroundColor.swift
================================================
import SwiftUI

/// A text style that sets the text background color.
public struct BackgroundColor: TextStyle {
  private let backgroundColor: Color?

  /// Creates a background color text style.
  /// - Parameter backgroundColor: The background color.
  public init(_ backgroundColor: Color?) {
    self.backgroundColor = backgroundColor
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.backgroundColor = self.backgroundColor
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/EmptyTextStyle.swift
================================================
import Foundation

/// A text style that doesn't apply any text style.
public struct EmptyTextStyle: TextStyle {
  /// Creates an empty text style.
  public init() {}

  public func _collectAttributes(in: inout AttributeContainer) {}
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/Font+FontProperties.swift
================================================
import SwiftUI

extension Font {
  static func withProperties(_ fontProperties: FontProperties) -> Font {
    var font: Font
    let size = round(fontProperties.size * fontProperties.scale)

    switch fontProperties.family {
    case .system(let design):
      font = .system(size: size, design: design)
    case .custom(let name):
      font = .custom(name, fixedSize: size)
    }

    switch fontProperties.familyVariant {
    case .normal:
      break  // do nothing
    case .monospaced:
      font = font.monospaced()
    }

    switch fontProperties.capsVariant {
    case .normal:
      break  // do nothing
    case .smallCaps:
      font = font.smallCaps()
    case .lowercaseSmallCaps:
      font = font.lowercaseSmallCaps()
    case .uppercaseSmallCaps:
      font = font.uppercaseSmallCaps()
    }

    switch fontProperties.digitVariant {
    case .normal:
      break  // do nothing
    case .monospaced:
      font = font.monospacedDigit()
    }

    if fontProperties.weight != .regular {
      font = font.weight(fontProperties.weight)
    }

    if #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) {
      if fontProperties.width != .standard {
        font = font.width(fontProperties.width)
      }
    }

    switch fontProperties.style {
    case .normal:
      break  // do nothing
    case .italic:
      font = font.italic()
    }

    return font
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontCapsVariant.swift
================================================
import Foundation

/// A text style that adjusts the font to use alternate glyphs for capital letters.
public struct FontCapsVariant: TextStyle {
  private let capsVariant: FontProperties.CapsVariant

  /// Creates a font caps variant text style.
  /// - Parameter capsVariant: The font caps variant.
  public init(_ capsVariant: FontProperties.CapsVariant) {
    self.capsVariant = capsVariant
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties?.capsVariant = self.capsVariant
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontDigitVariant.swift
================================================
import Foundation

/// A text style that adjusts the font to use alternate glyphs for digits.
public struct FontDigitVariant: TextStyle {
  private let digitVariant: FontProperties.DigitVariant

  /// Creates a font digit variant text style.
  /// - Parameter digitVariant: The font digit variant.
  public init(_ digitVariant: FontProperties.DigitVariant) {
    self.digitVariant = digitVariant
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties?.digitVariant = self.digitVariant
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontFamily.swift
================================================
import Foundation

/// A text style that sets the text font family.
public struct FontFamily: TextStyle {
  private let family: FontProperties.Family

  /// Creates a font family text style.
  /// - Parameter family: The font family.
  public init(_ family: FontProperties.Family) {
    self.family = family
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties?.family = self.family
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontFamilyVariant.swift
================================================
import Foundation

/// A text style that adjusts the font to use an alternate variant.
public struct FontFamilyVariant: TextStyle {
  private let familyVariant: FontProperties.FamilyVariant

  /// Creates a font family variant text style.
  /// - Parameter familyVariant: The font family variant.
  public init(_ familyVariant: FontProperties.FamilyVariant) {
    self.familyVariant = familyVariant
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties?.familyVariant = self.familyVariant
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontProperties.swift
================================================
import SwiftUI

/// The characteristics of a font.
public struct FontProperties: Hashable {
  /// The font family.
  public enum Family: Hashable {
    /// The system font family.
    case system(Font.Design = .default)

    /// A custom font family with the given name.
    case custom(String)
  }

  /// The font family variant.
  public enum FamilyVariant: Hashable {
    /// No variant. Use the current font family.
    case normal

    /// A fixed-width font from the current family, if available.
    case monospaced
  }

  /// The font caps variant.
  public enum CapsVariant: Hashable {
    /// Don't use a font caps variant.
    case normal

    /// Enable all small capitals.
    case smallCaps

    /// Enable lowercase small capitals.
    case lowercaseSmallCaps

    /// Enable uppercase small capitals.
    case uppercaseSmallCaps
  }

  /// The font digit variant.
  public enum DigitVariant: Hashable {
    /// Don't use a font digit variant.
    case normal

    /// Enable monospaced digits.
    case monospaced
  }

  /// The font style.
  public enum Style {
    /// Don't use a font style.
    case normal

    /// Select an italic font.
    case italic
  }

  /// A platform-dependent default font size.
  public static var defaultSize: CGFloat {
    #if os(macOS)
      return 13
    #elseif os(iOS)
      return 17
    #elseif os(tvOS)
      return 29
    #elseif os(watchOS)
      return 16
    #else
      return 16
    #endif
  }

  /// A platform-dependent default font weight.
  public static var defaultWeight: Font.Weight {
    #if os(tvOS)
      return .medium
    #else
      return .regular
    #endif
  }

  /// The font family.
  public var family: Family = .system()

  /// The font family variant.
  public var familyVariant: FamilyVariant = .normal

  /// The font caps variant.
  public var capsVariant: CapsVariant = .normal

  /// The font digit variant.
  public var digitVariant: DigitVariant = .normal

  /// The font style.
  public var style: Style = .normal

  /// The font weight.
  public var weight: Font.Weight = Self.defaultWeight

  /// The font width.
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
  public var width: Font.Width {
    get { (self.widthStorage as? Font.Width) ?? .standard }
    set { self.widthStorage = newValue }
  }

  private var widthStorage: AnyHashable?

  /// The font size.
  public var size: CGFloat = Self.defaultSize

  /// The font scale.
  public var scale: CGFloat = 1

  /// The scaled font size.
  public var scaledSize: CGFloat {
    round(self.size * self.scale)
  }

  /// Creates a font  properties value.
  /// - Parameters:
  ///   - family: The font family.
  ///   - familyVariant: The font family variant.
  ///   - capsVariant: The font caps variant.
  ///   - digitVariant: The font digit variant.
  ///   - style: The font style.
  ///   - weight: The font weight.
  ///   - width: The font width
  ///   - size: The font size.
  ///   - scale: The font scale.
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
  public init(
    family: FontProperties.Family = .system(),
    familyVariant: FontProperties.FamilyVariant = .normal,
    capsVariant: FontProperties.CapsVariant = .normal,
    digitVariant: FontProperties.DigitVariant = .normal,
    style: FontProperties.Style = .normal,
    weight: Font.Weight = Self.defaultWeight,
    width: Font.Width,
    size: CGFloat = Self.defaultSize,
    scale: CGFloat = 1
  ) {
    self.init(
      family: family,
      familyVariant: familyVariant,
      capsVariant: capsVariant,
      digitVariant: digitVariant,
      style: style,
      weight: weight,
      size: size,
      scale: scale
    )
    self.width = width
  }

  /// Creates a font  properties value.
  /// - Parameters:
  ///   - family: The font family.
  ///   - familyVariant: The font family variant.
  ///   - capsVariant: The font caps variant.
  ///   - digitVariant: The font digit variant.
  ///   - style: The font style.
  ///   - weight: The font weight.
  ///   - size: The font size.
  ///   - scale: The font scale.
  public init(
    family: FontProperties.Family = .system(),
    familyVariant: FontProperties.FamilyVariant = .normal,
    capsVariant: FontProperties.CapsVariant = .normal,
    digitVariant: FontProperties.DigitVariant = .normal,
    style: FontProperties.Style = .normal,
    weight: Font.Weight = Self.defaultWeight,
    size: CGFloat = Self.defaultSize,
    scale: CGFloat = 1
  ) {
    self.family = family
    self.familyVariant = familyVariant
    self.capsVariant = capsVariant
    self.digitVariant = digitVariant
    self.style = style
    self.weight = weight
    self.size = size
    self.scale = scale
  }
}

extension FontProperties: TextStyle {
  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties = self
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontPropertiesAttribute.swift
================================================
import Foundation

enum FontPropertiesAttribute: AttributedStringKey {
  typealias Value = FontProperties
  static let name = "fontProperties"
}

extension AttributeScopes {
  var markdownUI: MarkdownUIAttributes.Type {
    MarkdownUIAttributes.self
  }

  struct MarkdownUIAttributes: AttributeScope {
    let swiftUI: SwiftUIAttributes
    let fontProperties: FontPropertiesAttribute
  }
}

extension AttributeDynamicLookup {
  subscript<T: AttributedStringKey>(
    dynamicMember keyPath: KeyPath<AttributeScopes.MarkdownUIAttributes, T>
  ) -> T {
    return self[T.self]
  }
}

extension AttributedString {
  func resolvingFonts() -> AttributedString {
    var output = self

    for run in output.runs {
      guard let fontProperties = run.fontProperties else {
        continue
      }
      output[run.range].font = .withProperties(fontProperties)
      output[run.range].fontProperties = nil
    }

    return output
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontSize.swift
================================================
import Foundation

/// A text style that sets the font size.
public struct FontSize: TextStyle {
  private enum Size {
    case points(CGFloat)
    case relative(RelativeSize)
  }

  private let size: Size

  /// Creates a font size text style that sets the size to a relative value.
  /// - Parameter relativeSize: The relative size of the font.
  public init(_ relativeSize: RelativeSize) {
    self.size = .relative(relativeSize)
  }

  /// Creates a font size text style that sets the size to a given value.
  /// - Parameter size: The size of the font measured in points.
  public init(_ size: CGFloat) {
    self.size = .points(size)
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    switch self.size {
    case .points(let value):
      attributes.fontProperties?.size = value
      attributes.fontProperties?.scale = 1
    case .relative(let relativeSize):
      switch relativeSize.unit {
      case .em:
        attributes.fontProperties?.scale *= relativeSize.value
      case .rem:
        attributes.fontProperties?.scale = relativeSize.value
      }
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontStyle.swift
================================================
import Foundation

/// A text style that sets whether the font should be styled with a normal or italic face from its font family.
public struct FontStyle: TextStyle {
  private let style: FontProperties.Style

  /// Creates a font style text style.
  /// - Parameter style: The font style.
  public init(_ style: FontProperties.Style) {
    self.style = style
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties?.style = self.style
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontWeight.swift
================================================
import SwiftUI

/// A text style that adjusts the font weight.
public struct FontWeight: TextStyle {
  private let weight: Font.Weight

  /// Creates a font weight text style.
  /// - Parameter weight: The font weight.
  public init(_ weight: Font.Weight) {
    self.weight = weight
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties?.weight = self.weight
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/FontWidth.swift
================================================
import SwiftUI

/// A text style that adjusts the font width.
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct FontWidth: TextStyle {
  private let width: Font.Width

  /// Creates a font width text style.
  /// - Parameter width: The font width.
  public init(_ width: Font.Width) {
    self.width = width
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.fontProperties?.width = self.width
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/ForegroundColor.swift
================================================
import SwiftUI

/// A text style that sets the foreground color of the text.
public struct ForegroundColor: TextStyle {
  private let foregroundColor: Color?

  /// Creates a foreground color text style.
  /// - Parameter foregroundColor: The foreground color.
  public init(_ foregroundColor: Color?) {
    self.foregroundColor = foregroundColor
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.foregroundColor = self.foregroundColor
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/StrikethroughStyle.swift
================================================
import SwiftUI

/// A text style that sets the strikethrough line style of the text.
public struct StrikethroughStyle: TextStyle {
  private let lineStyle: Text.LineStyle?

  /// Creates a strikethrough text style.
  /// - Parameter lineStyle: The line style.
  public init(_ lineStyle: Text.LineStyle?) {
    self.lineStyle = lineStyle
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.strikethroughStyle = self.lineStyle
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/TextKerning.swift
================================================
import Foundation

/// A text style that sets the spacing, or kerning, between the characters of the text.
public struct TextKerning: TextStyle {
  private let kern: CGFloat?

  /// Creates a text kerning text style.
  /// - Parameter kern: The spacing to use between individual characters in the text.
  public init(_ kern: CGFloat?) {
    self.kern = kern
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.kern = self.kern
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/TextTracking.swift
================================================
import Foundation

/// A text style that sets the tracking of the text.
public struct TextTracking: TextStyle {
  private let tracking: CGFloat?

  /// Creates a text tracking text style.
  /// - Parameter tracking: The amount of additional space, in points, that is added to each character cluster.
  public init(_ tracking: CGFloat?) {
    self.tracking = tracking
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.tracking = self.tracking
  }
}



================================================
FILE: Sources/MarkdownUI/Theme/TextStyle/Styles/UnderlineStyle.swift
================================================
import SwiftUI

/// A text style that sets the underline line style of the text.
public struct UnderlineStyle: TextStyle {
  private let lineStyle: Text.LineStyle?

  /// Creates an underline style text style.
  /// - Parameter lineStyle: The line style.
  public init(_ lineStyle: Text.LineStyle?) {
    self.lineStyle = lineStyle
  }

  public func _collectAttributes(in attributes: inout AttributeContainer) {
    attributes.underlineStyle = self.lineStyle
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/BlockNode+ColorSchemeImage.swift
================================================
import SwiftUI

extension Sequence where Element == BlockNode {
  func filterImagesMatching(colorScheme: ColorScheme) -> [BlockNode] {
    self.rewrite { inline in
      switch inline {
      case .image(let source, _):
        guard let url = URL(string: source), url.matchesColorScheme(colorScheme) else {
          return []
        }
        return [inline]
      default:
        return [inline]
      }
    }
  }
}

extension URL {
  fileprivate func matchesColorScheme(_ colorScheme: ColorScheme) -> Bool {
    guard let fragment = self.fragment?.lowercased() else {
      return true
    }

    switch colorScheme {
    case .light:
      return fragment != "gh-dark-mode-only"
    case .dark:
      return fragment != "gh-light-mode-only"
    @unknown default:
      return true
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/Color+RGBA.swift
================================================
import SwiftUI

extension Color {
  /// Creates a constant color from an RGBA value.
  /// - Parameter rgba: A 32-bit value that represents the red, green, blue, and alpha components of the color.
  public init(rgba: UInt32) {
    self.init(
      red: CGFloat((rgba & 0xff00_0000) >> 24) / 255.0,
      green: CGFloat((rgba & 0x00ff_0000) >> 16) / 255.0,
      blue: CGFloat((rgba & 0x0000_ff00) >> 8) / 255.0,
      opacity: CGFloat(rgba & 0x0000_00ff) / 255.0
    )
  }

  /// Creates a context-dependent color with different values for light and dark appearances.
  /// - Parameters:
  ///   - light: The light appearance color value.
  ///   - dark: The dark appearance color value.
  public init(light: @escaping @autoclosure () -> Color, dark: @escaping @autoclosure () -> Color) {
    #if os(watchOS)
      self = dark()
    #elseif canImport(UIKit)
      self.init(
        uiColor: .init { traitCollection in
          switch traitCollection.userInterfaceStyle {
          case .unspecified, .light:
            return UIColor(light())
          case .dark:
            return UIColor(dark())
          @unknown default:
            return UIColor(light())
          }
        }
      )
    #elseif canImport(AppKit)
      self.init(
        nsColor: .init(name: nil) { appearance in
          if appearance.bestMatch(from: [.aqua, .darkAqua]) == .aqua {
            return NSColor(light())
          } else {
            return NSColor(dark())
          }
        }
      )
    #endif
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/Deprecations.swift
================================================
import SwiftUI

// MARK: - Deprecated after 2.1.0:

extension DefaultImageProvider {
  @available(*, deprecated, message: "Use the 'default' static property")
  public init(urlSession: URLSession = .shared) {
    self.init()
  }
}

extension DefaultInlineImageProvider {
  @available(*, deprecated, message: "Use the 'default' static property")
  public init(urlSession: URLSession = .shared) {
    self.init()
  }
}

// MARK: - Deprecated after 2.0.2:

extension BlockStyle where Configuration == BlockConfiguration {
  @available(
    *,
    deprecated,
    message: "Use the initializer that takes a closure receiving a 'Configuration' value."
  )
  public init<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) {
    self.init { configuration in
      body(configuration.label)
    }
  }

  @available(
    *,
    deprecated,
    message: "Use the initializer that takes a closure receiving a 'Configuration' value."
  )
  public init() {
    self.init { $0 }
  }
}

extension View {
  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a generic 'Configuration'
      value.
      """
  )
  public func markdownBlockStyle<Body: View>(
    _ keyPath: WritableKeyPath<Theme, BlockStyle<BlockConfiguration>>,
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> some View {
    self.environment((\EnvironmentValues.theme).appending(path: keyPath), .init(body: body))
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a generic 'Configuration'
      value.
      """
  )
  public func markdownBlockStyle<Body: View>(
    _ keyPath: WritableKeyPath<Theme, BlockStyle<CodeBlockConfiguration>>,
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> some View {
    self.environment(
      (\EnvironmentValues.theme).appending(path: keyPath),
      .init { configuration in
        body(.init(configuration.label))
      }
    )
  }
}

extension Theme {
  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func heading1<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.heading1 = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func heading2<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.heading2 = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func heading3<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.heading3 = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func heading4<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.heading4 = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func heading5<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.heading5 = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func heading6<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.heading6 = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func paragraph<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.paragraph = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func blockquote<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.blockquote = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'CodeBlockConfiguration'
      value.
      """
  )
  public func codeBlock<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.codeBlock = .init { configuration in
      body(.init(configuration.label))
    }
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func image<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.image = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func list<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.list = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func listItem<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.listItem = .init(body: body)
    return theme
  }

  @available(
    *,
    deprecated,
    message: """
      Use the version of this function that takes a closure receiving a 'BlockConfiguration'
      value.
      """
  )
  public func table<Body: View>(
    @ViewBuilder body: @escaping (_ label: BlockConfiguration.Label) -> Body
  ) -> Theme {
    var theme = self
    theme.table = .init(body: body)
    return theme
  }
}

// MARK: - Unavailable after 1.1.1:

extension Heading {
  @available(*, unavailable, message: "Use 'init(_ level:content:)'")
  public init(level: Int, @InlineContentBuilder content: () -> InlineContent) {
    fatalError("Unimplemented")
  }
}

@available(*, unavailable, renamed: "Blockquote")
public typealias BlockQuote = Blockquote

@available(*, unavailable, renamed: "NumberedList")
public typealias OrderedList = NumberedList

@available(*, unavailable, renamed: "BulletedList")
public typealias BulletList = BulletedList

@available(*, unavailable, renamed: "Code")
public typealias InlineCode = Code

@available(
  *,
  unavailable,
  message: """
    "MarkdownImageHandler" has been superseded by the "ImageProvider" protocol and its conforming
    types "DefaultImageProvider" and "AssetImageProvider".
    """
)
public struct MarkdownImageHandler {
  public static var networkImage: Self {
    fatalError("Unimplemented")
  }

  public static func assetImage(
    name: @escaping (URL) -> String = \.lastPathComponent,
    in bundle: Bundle? = nil
  ) -> Self {
    fatalError("Unimplemented")
  }
}

extension Markdown {
  @available(
    *,
    unavailable,
    message: """
      "MarkdownImageHandler" has been superseded by the "ImageProvider" protocol and its conforming
      types "DefaultImageProvider" and "AssetImageProvider".
      """
  )
  public func setImageHandler(
    _ imageHandler: MarkdownImageHandler,
    forURLScheme urlScheme: String
  ) -> Markdown {
    fatalError("Unimplemented")
  }
}

extension View {
  @available(
    *,
    unavailable,
    message: "You can create a custom link action by overriding the \"openURL\" environment value."
  )
  public func onOpenMarkdownLink(perform action: ((URL) -> Void)? = nil) -> some View {
    self
  }
}

@available(
  *,
  unavailable,
  message: """
    "MarkdownStyle" and its subtypes have been superseded by the "Theme", "TextStyle", and
    "BlockStyle" types.
    """
)
public struct MarkdownStyle: Hashable {
  public struct Font: Hashable {
    public static var largeTitle: Self { fatalError("Unimplemented") }
    public static var title: Self { fatalError("Unimplemented") }
    public static var title2: Self { fatalError("Unimplemented") }
    public static var title3: Self { fatalError("Unimplemented") }
    public static var headline: Self { fatalError("Unimplemented") }
    public static var subheadline: Self { fatalError("Unimplemented") }
    public static var body: Self { fatalError("Unimplemented") }
    public static var callout: Self { fatalError("Unimplemented") }
    public static var footnote: Self { fatalError("Unimplemented") }
    public static var caption: Self { fatalError("Unimplemented") }
    public static var caption2: Self { fatalError("Unimplemented") }

    public static func system(
      size: CGFloat,
      weight: SwiftUI.Font.Weight = .regular,
      design: SwiftUI.Font.Design = .default
    ) -> Self {
      fatalError("Unimplemented")
    }

    public static func system(
      _ style: SwiftUI.Font.TextStyle,
      design: SwiftUI.Font.Design = .default
    ) -> Self {
      fatalError("Unimplemented")
    }

    public static func custom(_ name: String, size: CGFloat) -> Self {
      fatalError("Unimplemented")
    }

    public func bold() -> Self {
      fatalError("Unimplemented")
    }

    public func italic() -> Self {
      fatalError("Unimplemented")
    }

    public func monospacedDigit() -> Self {
      fatalError("Unimplemented")
    }

    public func monospaced() -> Self {
      fatalError("Unimplemented")
    }

    public func scale(_ scale: CGFloat) -> Self {
      fatalError("Unimplemented")
    }
  }

  public struct HeadingScales: Hashable {
    public init(
      h1: CGFloat,
      h2: CGFloat,
      h3: CGFloat,
      h4: CGFloat,
      h5: CGFloat,
      h6: CGFloat
    ) {
      fatalError("Unimplemented")
    }

    public subscript(index: Int) -> CGFloat {
      fatalError("Unimplemented")
    }

    public static var `default`: Self {
      fatalError("Unimplemented")
    }
  }

  public struct Measurements: Hashable {
    public var codeFontScale: CGFloat
    public var headIndentStep: CGFloat
    public var tailIndentStep: CGFloat
    public var paragraphSpacing: CGFloat
    public var listMarkerSpacing: CGFloat
    public var headingScales: HeadingScales
    public var headingSpacing: CGFloat

    public init(
      codeFontScale: CGFloat = 0.94,
      headIndentStep: CGFloat = 1.97,
      tailIndentStep: CGFloat = -1,
      paragraphSpacing: CGFloat = 1,
      listMarkerSpacing: CGFloat = 0.47,
      headingScales: HeadingScales = .default,
      headingSpacing: CGFloat = 0.67
    ) {
      fatalError("Unimplemented")
    }
  }

  public var font: MarkdownStyle.Font
  public var foregroundColor: SwiftUI.Color
  public var measurements: Measurements

  public init(
    font: MarkdownStyle.Font = .body,
    foregroundColor: SwiftUI.Color = .primary,
    measurements: MarkdownStyle.Measurements = .init()
  ) {
    fatalError("Unimplemented")
  }
}

extension View {
  @available(
    *,
    unavailable,
    message: """
      "MarkdownStyle" and its subtypes have been superseded by the "Theme", "TextStyle", and
      "BlockStyle" types.
      """
  )
  public func markdownStyle(_ markdownStyle: MarkdownStyle) -> some View {
    self
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/FlowLayout.swift
================================================
import SwiftUI

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
struct FlowLayout: Layout {
  let horizontalSpacing: CGFloat
  let verticalSpacing: CGFloat

  func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout Void) -> CGSize {
    let rows = self.computeLayout(for: proposal, subviews: subviews)
    return self.sizeThatFits(rows: rows)
  }

  func placeSubviews(
    in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout Void
  ) {
    let rows = self.computeLayout(for: proposal, subviews: subviews)
    var position = bounds.origin

    for row in rows {
      for item in row.items {
        // align to bottom
        let itemBounds = CGRect(origin: position, size: item.size)
          .offsetBy(dx: 0, dy: row.size.height - item.size.height)
        subviews[item.index].place(at: itemBounds.origin, proposal: .init(itemBounds.size))
        position.x += item.size.width + self.horizontalSpacing
      }

      position.x = bounds.origin.x
      position.y += row.size.height + self.verticalSpacing
    }
  }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension FlowLayout {
  private struct Item {
    let index: Int
    let size: CGSize
  }

  private struct Row {
    var size: CGSize = .zero
    var items: [Item] = []
  }

  private func computeLayout(for proposal: ProposedViewSize, subviews: Subviews) -> [Row] {
    var rows: [Row] = []
    var currentRow = Row()

    for (index, view) in zip(subviews.indices, subviews) {
      // propose the remainder of the width for low prioriy views, otherwise the full width
      // this way we can use a spacer view for hard line breaks
      let proposedWidth =
        view.priority < 0 ? proposal.width.map { $0 - currentRow.size.width } : proposal.width
      let item = Item(
        index: index,
        size: view.sizeThatFits(.init(width: proposedWidth, height: nil))
      )

      if currentRow.size.width > 0,
        currentRow.size.width + item.size.width > (proposal.width ?? .infinity)
      {
        // Remove the spacing for the last item
        currentRow.size.width -= self.horizontalSpacing
        rows.append(currentRow)
        currentRow = Row()
      }

      currentRow.items.append(item)
      currentRow.size.width += item.size.width + self.horizontalSpacing
      currentRow.size.height = max(item.size.height, currentRow.size.height)
    }

    if !currentRow.items.isEmpty {
      // Remove the spacing for the last item
      currentRow.size.width -= self.horizontalSpacing
      rows.append(currentRow)
    }

    return rows
  }

  private func sizeThatFits(rows: [Row]) -> CGSize {
    zip(rows.indices, rows).reduce(CGSize.zero) { size, tuple in
      let (index, row) = tuple
      let spacing = index < rows.endIndex - 1 ? self.verticalSpacing : 0
      return CGSize(
        width: max(size.width, row.size.width),
        height: size.height + row.size.height + spacing
      )
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/Indexed.swift
================================================
import Foundation

struct Indexed<Value> {
  let index: Int
  let value: Value
}

extension Indexed: Equatable where Value: Equatable {}
extension Indexed: Hashable where Value: Hashable {}

extension Sequence {
  func indexed() -> [Indexed<Element>] {
    zip(0..., self).map { index, value in
      Indexed(index: index, value: value)
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/InlineNode+PlainText.swift
================================================
import Foundation

extension Sequence where Element == InlineNode {
  func renderPlainText() -> String {
    self.collect { inline in
      switch inline {
      case .text(let content):
        return [content]
      case .softBreak:
        return [" "]
      case .lineBreak:
        return ["\n"]
      case .code(let content):
        return [content]
      case .html(let content):
        return [content]
      default:
        return []
      }
    }
    .joined()
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/InlineNode+RawImageData.swift
================================================
import Foundation

struct RawImageData: Hashable {
  var source: String
  var alt: String
  var destination: String?
}

extension InlineNode {
  var imageData: RawImageData? {
    switch self {
    case .image(let source, let children):
      return .init(source: source, alt: children.renderPlainText())
    case .link(let destination, let children) where children.count == 1:
      guard var imageData = children.first?.imageData else { return nil }
      imageData.destination = destination
      return imageData
    default:
      return nil
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/Int+Roman.swift
================================================
import Foundation

extension Int {
  var roman: String {
    guard self > 0, self < 4000 else {
      return "\(self)"
    }

    let decimals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    let numerals = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]

    var number = self
    var result = ""

    for (decimal, numeral) in zip(decimals, numerals) {
      let repeats = number / decimal
      if repeats > 0 {
        result += String(repeating: numeral, count: repeats)
      }
      number = number % decimal
    }

    return result
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/RelativeSize.swift
================================================
import SwiftUI

/// Represents a relative size or length, such as a width, padding, or font size.
///
/// `RelativeSize` values can be used in text styles like ``FontSize`` or modifiers like
/// `markdownMargin(top:bottom:)`, `relativeFrame(width:height:alignment:)`,
/// `relativeFrame(minWidth:alignment:)`, `relativePadding(_:length:)`,
/// and `relativeLineSpacing(_:)` to express parameters relative to the font size.
///
/// Use the ``em(_:)`` and the ``rem(_:)`` methods to create values relative to the current and
/// root font sizes, respectively. For example, in the following snippet, with a root font size of 17 points,
/// the line spacing will be resolved to 4.25 points (`17 * 2 * 0.125`) and the padding to 8.5 points
/// (`17 * 0.5`).
///
/// ```swift
/// label
///   .relativeLineSpacing(.em(0.125))
///   .relativePadding(length: .rem(0.5))
///   .markdownTextStyle {
///     FontWeight(.semibold)
///     FontSize(.em(2))
///   }
/// ```
public struct RelativeSize: Hashable {
  enum Unit: Hashable {
    case em
    case rem
  }

  var value: CGFloat
  var unit: Unit
}

extension RelativeSize {
  /// A size with a value of zero.
  public static let zero = RelativeSize(value: 0, unit: .rem)

  /// Creates a size value relative to the current font size.
  public static func em(_ value: CGFloat) -> RelativeSize {
    .init(value: value, unit: .em)
  }

  /// Creates a size value relative to the root font size.
  public static func rem(_ value: CGFloat) -> RelativeSize {
    .init(value: value, unit: .rem)
  }

  func points(relativeTo fontProperties: FontProperties? = nil) -> CGFloat {
    let fontProperties = fontProperties ?? .init()

    switch self.unit {
    case .em:
      return round(value * fontProperties.scaledSize)
    case .rem:
      return round(value * fontProperties.size)
    }
  }
}

extension View {
  /// Positions this view within an invisible frame with the specified size.
  ///
  /// This method behaves like the one in SwiftUI but takes `RelativeSize`
  /// values instead of `CGFloat` for the width and height.
  public func relativeFrame(
    width: RelativeSize? = nil,
    height: RelativeSize? = nil,
    alignment: Alignment = .center
  ) -> some View {
    TextStyleAttributesReader { attributes in
      self.frame(
        width: width?.points(relativeTo: attributes.fontProperties),
        height: height?.points(relativeTo: attributes.fontProperties),
        alignment: alignment
      )
    }
  }

  /// Positions this view within an invisible frame having the specified size constraints.
  ///
  /// This method behaves like the one in SwiftUI but takes `RelativeSize`
  /// values instead of `CGFloat` for the width and height.
  public func relativeFrame(
    minWidth: RelativeSize,
    alignment: Alignment = .center
  ) -> some View {
    TextStyleAttributesReader { attributes in
      self.frame(
        minWidth: minWidth.points(relativeTo: attributes.fontProperties),
        alignment: alignment
      )
    }
  }

  /// Adds an equal padding amount to specific edges of this view.
  ///
  /// This method behaves like the one in SwiftUI except that it takes a `RelativeSize`
  /// value instead of a `CGFloat` for the padding amount.
  public func relativePadding(_ edges: Edge.Set = .all, length: RelativeSize) -> some View {
    TextStyleAttributesReader { attributes in
      self.padding(edges, length.points(relativeTo: attributes.fontProperties))
    }
  }

  /// Sets the amount of space between lines of text in this view.
  ///
  /// This method behaves like the one in SwiftUI except that it takes a `RelativeSize`
  /// value instead of a `CGFloat` for the spacing amount.
  public func relativeLineSpacing(_ lineSpacing: RelativeSize) -> some View {
    TextStyleAttributesReader { attributes in
      self.lineSpacing(lineSpacing.points(relativeTo: attributes.fontProperties))
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/ResizeToFit.swift
================================================
import SwiftUI

struct ResizeToFit<Content>: View where Content: View {
  private let idealSize: CGSize
  private let content: Content

  init(idealSize: CGSize, @ViewBuilder content: () -> Content) {
    self.idealSize = idealSize
    self.content = content()
  }

  var body: some View {
    if #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) {
      ResizeToFit2 { self.content }
    } else {
      ResizeToFit1(idealSize: self.idealSize, content: self.content)
    }
  }
}

// MARK: - Geometry reader based

private struct ResizeToFit1<Content>: View where Content: View {
  @State private var size: CGSize?

  let idealSize: CGSize
  let content: Content

  var body: some View {
    GeometryReader { proxy in
      let size = self.sizeThatFits(proposal: proxy.size)
      self.content
        .frame(width: size.width, height: size.height)
        .preference(key: SizePreference.self, value: size)
    }
    .frame(width: size?.width, height: size?.height)
    .onPreferenceChange(SizePreference.self) { size in
      self.size = size
    }
  }

  private func sizeThatFits(proposal: CGSize) -> CGSize {
    guard proposal.width < idealSize.width else {
      return idealSize
    }

    let aspectRatio = idealSize.width / idealSize.height
    return CGSize(width: proposal.width, height: proposal.width / aspectRatio)
  }
}

private struct SizePreference: PreferenceKey {
  static let defaultValue: CGSize? = nil

  static func reduce(value: inout CGSize?, nextValue: () -> CGSize?) {
    value = value ?? nextValue()
  }
}

// MARK: - Layout based

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
private struct ResizeToFit2: Layout {
  func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
    guard let view = subviews.first else {
      return .zero
    }

    var size = view.sizeThatFits(.unspecified)

    if let width = proposal.width, size.width > width {
      let aspectRatio = size.width / size.height
      size.width = width
      size.height = width / aspectRatio
    }
    return size
  }

  func placeSubviews(
    in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()
  ) {
    guard let view = subviews.first else { return }
    view.place(at: bounds.origin, proposal: .init(bounds.size))
  }
}



================================================
FILE: Sources/MarkdownUI/Utility/String+KebabCase.swift
================================================
import Foundation

extension String {
  func kebabCased() -> String {
    self.components(separatedBy: .alphanumerics.inverted)
      .map { $0.lowercased() }
      .joined(separator: "-")
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Markdown.swift
================================================
import SwiftUI

/// A view that displays read-only Markdown content.
///
/// A `Markdown` view displays rich structured text using the Markdown syntax. It is compatible with the
/// [GitHub Flavored Markdown Spec](https://github.github.com/gfm/) and can display
/// images, headings, lists (including task lists), blockquotes, code blocks, tables, and thematic breaks,
/// besides styled text and links.
///
/// The simplest way of creating a `Markdown` view is to pass a Markdown string to the
/// ``Markdown/init(_:baseURL:imageBaseURL:)-63py1`` initializer.
///
/// ```swift
/// let markdownString = """
///   ## Try MarkdownUI
///
///   **MarkdownUI** is a native Markdown renderer for SwiftUI
///   compatible with the
///   [GitHub Flavored Markdown Spec](https://github.github.com/gfm/).
///   """
///
/// var body: some View {
///   Markdown(markdownString)
/// }
/// ```
///
/// ![](MarkdownString)
///
/// A more convenient way to create a `Markdown` view is by using the ``Markdown/init(baseURL:imageBaseURL:content:)``
/// initializer, which takes a Markdown content builder in which you can compose the view content, either by providing Markdown strings
/// or by using an expressive domain-specific language.
///
/// ```swift
/// var body: some View {
///   Markdown {
///     """
///     ## Using a Markdown Content Builder
///     Use Markdown strings or an expressive domain-specific language
///     to build the content.
///     """
///     Heading(.level2) {
///       "Try MarkdownUI"
///     }
///     Paragraph {
///       Strong("MarkdownUI")
///       " is a native Markdown renderer for SwiftUI"
///       " compatible with the "
///       InlineLink(
///         "GitHub Flavored Markdown Spec",
///         destination: URL(string: "https://github.github.com/gfm/")!
///       )
///       "."
///     }
///   }
/// }
/// ```
///
/// ![](MarkdownContentBuilder)
///
/// You can also create a ``MarkdownContent`` value in your model layer and later create a `Markdown` view by passing
/// the content value to the ``Markdown/init(_:baseURL:imageBaseURL:)-42bru`` initializer. The ``MarkdownContent``
/// value pre-parses the Markdown string preventing the view from doing this step.
///
/// ```swift
/// // Somewhere in the model layer
/// let content = MarkdownContent("You can try **CommonMark** [here](https://spec.commonmark.org/dingus/).")
///
/// // Later in the view layer
/// var body: some View {
///   Markdown(self.model.content)
/// }
/// ```
///
/// ### Styling Markdown
///
/// Markdown views use a basic default theme to display the contents. For more information, read about the ``Theme/basic`` theme.
///
/// ```swift
/// Markdown {
///   """
///   You can quote text with a `>`.
///
///   > Outside of a dog, a book is man's best friend. Inside of a
///   > dog it's too dark to read.
///
///   – Groucho Marx
///   """
/// }
/// ```
///
/// ![](BlockquoteContent)
///
/// You can customize the appearance of Markdown content by applying different themes using the `markdownTheme(_:)` modifier.
/// For example, you can apply one of the built-in themes, like ``Theme/gitHub``, to either a Markdown view or a view hierarchy that
/// contains Markdown views.
///
/// ```swift
/// Markdown {
///   """
///   You can quote text with a `>`.
///
///   > Outside of a dog, a book is man's best friend. Inside of a
///   > dog it's too dark to read.
///
///   – Groucho Marx
///   """
/// }
/// .markdownTheme(.gitHub)
/// ```
///
/// ![](GitHubBlockquote)
///
/// To override a specific text style from the current theme, use the `markdownTextStyle(_:textStyle:)`
/// modifier.  The following example shows how to override the ``Theme/code`` text style.
///
/// ```swift
/// Markdown {
///   """
///   Use `git status` to list all new or modified files
///   that haven't yet been committed.
///   """
/// }
/// .markdownTextStyle(\.code) {
///   FontFamilyVariant(.monospaced)
///   FontSize(.em(0.85))
///   ForegroundColor(.purple)
///   BackgroundColor(.purple.opacity(0.25))
/// }
/// ```
///
/// ![](CustomInlineCode)
///
/// You can also use the `markdownBlockStyle(_:body:)` modifier to override a specific block style. For example, you can
/// override only the ``Theme/blockquote`` block style, leaving other block styles untouched.
///
/// ```swift
/// Markdown {
///   """
///   You can quote text with a `>`.
///
///   > Outside of a dog, a book is man's best friend. Inside of a
///   > dog it's too dark to read.
///
///   – Groucho Marx
///   """
/// }
/// .markdownBlockStyle(\.blockquote) { configuration in
///   configuration.label
///     .padding()
///     .markdownTextStyle {
///       FontCapsVariant(.lowercaseSmallCaps)
///       FontWeight(.semibold)
///       BackgroundColor(nil)
///     }
///     .overlay(alignment: .leading) {
///       Rectangle()
///         .fill(Color.teal)
///         .frame(width: 4)
///     }
///     .background(Color.teal.opacity(0.5))
/// }
/// ```
///
/// ![](CustomBlockquote)
///
/// Another way to customize the appearance of Markdown content is to create your own theme. See the documentation of the
/// ``Theme`` type for more information on this subject.
///
/// ### Customizing link behavior
///
/// When a user taps or clicks on a Markdown link, the default behavior is to open Safari. However, you can customize this behavior
/// by setting the `openURL` environment value with a custom `OpenURLAction`.
///
/// ```swift
/// Markdown {
///   """
///   ## Try MarkdownUI
///   **MarkdownUI** is a native Markdown renderer for SwiftUI
///   compatible with the
///   [GitHub Flavored Markdown Spec](https://github.github.com/gfm/).
///   """
/// }
/// .environment(
///   \.openURL,
///   OpenURLAction { url in
///     print("Open \(url)")
///     return .handled
///   }
/// )
/// ```
public struct Markdown: View {
  @Environment(\.colorScheme) private var colorScheme
  @Environment(\.theme.text) private var text

  private let content: MarkdownContent
  private let baseURL: URL?
  private let imageBaseURL: URL?

  /// Creates a Markdown view from a Markdown content value.
  /// - Parameters:
  ///   - content: The Markdown content value.
  ///   - baseURL: The base URL to use when resolving Markdown URLs. If this value is `nil`, the initializer will consider all
  ///              URLs absolute. The default is `nil`.
  ///   - imageBaseURL: The base URL to use when resolving Markdown image URLs. If this value is `nil`, the initializer will
  ///                   determine image URLs using the `baseURL` parameter. The default is `nil`.
  public init(_ content: MarkdownContent, baseURL: URL? = nil, imageBaseURL: URL? = nil) {
    self.content = content
    self.baseURL = baseURL
    self.imageBaseURL = imageBaseURL ?? baseURL
  }

  public var body: some View {
    TextStyleAttributesReader { attributes in
      BlockSequence(self.blocks)
        .foregroundColor(attributes.foregroundColor)
        .background(attributes.backgroundColor)
        .modifier(ScaledFontSizeModifier(attributes.fontProperties?.size))
    }
    .textStyle(self.text)
    .environment(\.baseURL, self.baseURL)
    .environment(\.imageBaseURL, self.imageBaseURL)
  }

  private var blocks: [BlockNode] {
    self.content.blocks.filterImagesMatching(colorScheme: self.colorScheme)
  }
}

extension Markdown {
  /// Creates a Markdown view from a Markdown-formatted string.
  /// - Parameters:
  ///   - markdown: The string that contains the Markdown formatting.
  ///   - baseURL: The base URL to use when resolving Markdown URLs. If this value is `nil`, the initializer will consider all
  ///              URLs absolute. The default is `nil`.
  ///   - imageBaseURL: The base URL to use when resolving Markdown image URLs. If this value is `nil`, the initializer will
  ///                   determine image URLs using the `baseURL` parameter. The default is `nil`.
  public init(_ markdown: String, baseURL: URL? = nil, imageBaseURL: URL? = nil) {
    self.init(MarkdownContent(markdown), baseURL: baseURL, imageBaseURL: imageBaseURL)
  }

  /// Creates a Markdown view composed of any number of blocks.
  ///
  /// Using this initializer, you can compose the Markdown view content either by providing Markdown strings or with an expressive
  /// domain-specific language.
  ///
  /// ```swift
  /// var body: some View {
  ///   Markdown {
  ///     """
  ///     ## Using a Markdown Content Builder
  ///
  ///     Use Markdown strings or an expressive domain-specific language
  ///     to build the content.
  ///     """
  ///     Heading(.level2) {
  ///       "Try MarkdownUI"
  ///     }
  ///     Paragraph {
  ///       Strong("MarkdownUI")
  ///       " is a native Markdown renderer for SwiftUI"
  ///       " compatible with the "
  ///       InlineLink(
  ///         "GitHub Flavored Markdown Spec",
  ///         destination: URL(string: "https://github.github.com/gfm/")!
  ///       )
  ///       "."
  ///     }
  ///   }
  /// }
  /// ```
  ///
  /// - Parameters:
  ///   - baseURL: The base URL to use when resolving Markdown URLs. If this value is `nil`, the initializer will consider all
  ///              URLs absolute. The default is `nil`.
  ///   - imageBaseURL: The base URL to use when resolving Markdown image URLs. If this value is `nil`, the initializer will
  ///                   determine image URLs using the `baseURL` parameter. The default is `nil`.
  ///   - content: A Markdown content builder that returns the blocks that form the Markdown content.
  public init(
    baseURL: URL? = nil,
    imageBaseURL: URL? = nil,
    @MarkdownContentBuilder content: () -> MarkdownContent
  ) {
    self.init(content(), baseURL: baseURL, imageBaseURL: imageBaseURL)
  }
}

private struct ScaledFontSizeModifier: ViewModifier {
  @ScaledMetric private var size: CGFloat

  init(_ size: CGFloat?) {
    self._size = ScaledMetric(wrappedValue: size ?? FontProperties.defaultSize, relativeTo: .body)
  }

  func body(content: Content) -> some View {
    content.markdownTextStyle {
      FontSize(self.size)
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/BlockMargin.swift
================================================
import SwiftUI

struct BlockMargin: Equatable {
  var top: CGFloat?
  var bottom: CGFloat?

  static let unspecified = BlockMargin()
}

extension View {
  /// Sets the preferred top margin for the block content in this view.
  ///
  /// Use this modifier inside a ``BlockStyle`` `body` closure to customize the top spacing
  /// of the block content.
  ///
  /// - Parameter top: The minimum relative top spacing to use when laying out this block
  ///                  together with other blocks.
  public func markdownMargin(top: RelativeSize) -> some View {
    self.markdownMargin(top: top, bottom: nil)
  }

  /// Sets the preferred bottom margin for the block content in this view.
  ///
  /// Use this modifier inside a ``BlockStyle`` `body` closure to customize the bottom spacing
  /// of the block content.
  ///
  /// - Parameter bottom: The minimum relative bottom spacing to use when laying out this
  ///                     block together with other blocks.
  public func markdownMargin(bottom: RelativeSize) -> some View {
    self.markdownMargin(top: nil, bottom: bottom)
  }

  /// Sets the preferred top and bottom margins for the block content in this view.
  ///
  /// Use this modifier inside a ``BlockStyle`` `body` closure to customize the top and
  /// bottom spacing of the block content.
  ///
  /// - Parameters:
  ///   - top: The minimum relative top spacing to use when laying out this block together with
  ///          other blocks. If you set the value to `nil`, MarkdownUI uses the preferred
  ///          maximum value of the child blocks or the system's default padding amount
  ///          if no preference has been set.
  ///   - bottom: The minimum relative bottom spacing to use when laying out this block
  ///             together with other blocks. If you set the value to `nil`, MarkdownUI
  ///             uses the preferred maximum value of the child blocks or the system's
  ///             default padding amount if no preference has been set.
  public func markdownMargin(top: RelativeSize?, bottom: RelativeSize?) -> some View {
    TextStyleAttributesReader { attributes in
      self.markdownMargin(
        top: top?.points(relativeTo: attributes.fontProperties),
        bottom: bottom?.points(relativeTo: attributes.fontProperties)
      )
    }
  }

  /// Sets the preferred top margin for the block content in this view.
  ///
  /// Use this modifier inside a ``BlockStyle`` `body` closure to customize the top spacing
  /// of the block content.
  ///
  /// - Parameter top: The minimum top spacing, given in points, to use when laying out this block
  ///                  together with other blocks.
  public func markdownMargin(top: CGFloat) -> some View {
    self.markdownMargin(top: top, bottom: nil)
  }

  /// Sets the preferred bottom margin for the block content in this view.
  ///
  /// Use this modifier inside a ``BlockStyle`` `body` closure to customize the bottom spacing
  /// of the block content.
  ///
  /// - Parameter bottom: The minimum bottom spacing, given in points, to use when laying out this
  ///                     block together with other blocks.
  public func markdownMargin(bottom: CGFloat) -> some View {
    self.markdownMargin(top: nil, bottom: bottom)
  }

  /// Sets the preferred top and bottom margins for the block content in this view.
  ///
  /// Use this modifier inside a ``BlockStyle`` `body` closure to customize the top and
  /// bottom spacing of the block content.
  ///
  /// - Parameters:
  ///   - top: The minimum top spacing, given in points, to use when laying out this block
  ///          together with other blocks. If you set the value to `nil`, MarkdownUI uses
  ///          the preferred maximum value of the child blocks or the system's default
  ///          padding amount if no preference has been set.
  ///   - bottom: The minimum bottom spacing, given in points, to use when laying out
  ///             this block together with other blocks. If you set the value to `nil`,
  ///             MarkdownUI uses the preferred maximum value of the child blocks or
  ///             the system's default padding amount if no preference has been set.
  public func markdownMargin(top: CGFloat?, bottom: CGFloat?) -> some View {
    self.transformPreference(BlockMarginsPreference.self) { value in
      let newValue = BlockMargin(top: top, bottom: bottom)

      value.top = [value.top, newValue.top].compactMap { $0 }.max()
      value.bottom = [value.bottom, newValue.bottom].compactMap { $0 }.max()
    }
  }
}

struct BlockMarginsPreference: PreferenceKey {
  static let defaultValue: BlockMargin = .unspecified

  static func reduce(value: inout BlockMargin, nextValue: () -> BlockMargin) {
    let newValue = nextValue()

    value.top = [value.top, newValue.top].compactMap { $0 }.max()
    value.bottom = [value.bottom, newValue.bottom].compactMap { $0 }.max()
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/BlockNode+View.swift
================================================
import SwiftUI

extension BlockNode: View {
  var body: some View {
    switch self {
    case .blockquote(let children):
      BlockquoteView(children: children)
    case .bulletedList(let isTight, let items):
      BulletedListView(isTight: isTight, items: items)
    case .numberedList(let isTight, let start, let items):
      NumberedListView(isTight: isTight, start: start, items: items)
    case .taskList(let isTight, let items):
      TaskListView(isTight: isTight, items: items)
    case .codeBlock(let fenceInfo, let content):
      CodeBlockView(fenceInfo: fenceInfo, content: content)
    case .htmlBlock(let content):
      ParagraphView(content: content)
    case .paragraph(let content):
      ParagraphView(content: content)
    case .heading(let level, let content):
      HeadingView(level: level, content: content)
    case .table(let columnAlignments, let rows):
      if #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) {
        TableView(columnAlignments: columnAlignments, rows: rows)
      }
    case .thematicBreak:
      ThematicBreakView()
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/BlockquoteView.swift
================================================
import SwiftUI

struct BlockquoteView: View {
  @Environment(\.theme.blockquote) private var blockquote

  private let children: [BlockNode]

  init(children: [BlockNode]) {
    self.children = children
  }

  var body: some View {
    self.blockquote.makeBody(
      configuration: .init(
        label: .init(BlockSequence(self.children)),
        content: .init(block: .blockquote(children: self.children))
      )
    )
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/BlockSequence.swift
================================================
import SwiftUI

struct BlockSequence<Data, Content>: View
where
  Data: Sequence,
  Data.Element: Hashable,
  Content: View
{
  @Environment(\.multilineTextAlignment) private var textAlignment
  @Environment(\.tightSpacingEnabled) private var tightSpacingEnabled

  @State private var blockMargins: [Int: BlockMargin] = [:]

  private let data: [Indexed<Data.Element>]
  private let content: (Int, Data.Element) -> Content

  init(
    _ data: Data,
    @ViewBuilder content: @escaping (_ index: Int, _ element: Data.Element) -> Content
  ) {
    self.data = data.indexed()
    self.content = content
  }

  var body: some View {
    VStack(alignment: self.textAlignment.alignment.horizontal, spacing: 0) {
      ForEach(self.data, id: \.self) { element in
        self.content(element.index, element.value)
          .onPreferenceChange(BlockMarginsPreference.self) { value in
            self.blockMargins[element.hashValue] = value
          }
          .padding(.top, self.topPaddingLength(for: element))
      }
    }
  }

  private func topPaddingLength(for element: Indexed<Data.Element>) -> CGFloat? {
    guard element.index > 0 else {
      return 0
    }

    let topSpacing = self.blockMargins[element.hashValue]?.top
    let predecessor = self.data[element.index - 1]
    let predecessorBottomSpacing =
      self.tightSpacingEnabled ? 0 : self.blockMargins[predecessor.hashValue]?.bottom

    return [topSpacing, predecessorBottomSpacing]
      .compactMap { $0 }
      .max()
  }
}

extension BlockSequence where Data == [BlockNode], Content == BlockNode {
  init(_ blocks: [BlockNode]) {
    self.init(blocks) { $1 }
  }
}

extension TextAlignment {
  fileprivate var alignment: Alignment {
    switch self {
    case .leading:
      return .leading
    case .center:
      return .center
    case .trailing:
      return .trailing
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/BulletedListView.swift
================================================
import SwiftUI

struct BulletedListView: View {
  @Environment(\.theme.list) private var list
  @Environment(\.theme.bulletedListMarker) private var bulletedListMarker
  @Environment(\.listLevel) private var listLevel

  private let isTight: Bool
  private let items: [RawListItem]

  init(isTight: Bool, items: [RawListItem]) {
    self.isTight = isTight
    self.items = items
  }

  var body: some View {
    self.list.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(block: .bulletedList(isTight: self.isTight, items: self.items))
      )
    )
  }

  private var label: some View {
    ListItemSequence(items: self.items, markerStyle: self.bulletedListMarker)
      .environment(\.listLevel, self.listLevel + 1)
      .environment(\.tightSpacingEnabled, self.isTight)
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/CodeBlockView.swift
================================================
import SwiftUI

struct CodeBlockView: View {
  @Environment(\.theme.codeBlock) private var codeBlock
  @Environment(\.codeSyntaxHighlighter) private var codeSyntaxHighlighter

  private let fenceInfo: String?
  private let content: String

  init(fenceInfo: String?, content: String) {
    self.fenceInfo = fenceInfo
    self.content = content.hasSuffix("\n") ? String(content.dropLast()) : content
  }

  var body: some View {
    self.codeBlock.makeBody(
      configuration: .init(
        language: self.fenceInfo,
        content: self.content,
        label: .init(self.label)
      )
    )
  }

  private var label: some View {
    self.codeSyntaxHighlighter.highlightCode(self.content, language: self.fenceInfo)
      .textStyleFont()
      .textStyleForegroundColor()
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/ColumnWidthPreference.swift
================================================
import SwiftUI

extension View {
  func readWidth(column: Int) -> some View {
    self.background(
      GeometryReader { proxy in
        Color.clear.preference(key: ColumnWidthPreference.self, value: [column: proxy.size.width])
      }
    )
  }

  func onColumnWidthChange(perform action: @escaping ([Int: CGFloat]) -> Void) -> some View {
    self.onPreferenceChange(ColumnWidthPreference.self, perform: action)
  }
}

private struct ColumnWidthPreference: PreferenceKey {
  static let defaultValue: [Int: CGFloat] = [:]

  static func reduce(value: inout [Int: CGFloat], nextValue: () -> [Int: CGFloat]) {
    value.merge(nextValue(), uniquingKeysWith: max)
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/HeadingView.swift
================================================
import SwiftUI

struct HeadingView: View {
  @Environment(\.theme.headings) private var headings

  private let level: Int
  private let content: [InlineNode]

  init(level: Int, content: [InlineNode]) {
    self.level = level
    self.content = content
  }

  var body: some View {
    self.headings[self.level - 1].makeBody(
      configuration: .init(
        label: .init(InlineText(self.content)),
        content: .init(block: .heading(level: self.level, content: self.content))
      )
    )
    .id(content.renderPlainText().kebabCased())
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/ImageFlow.swift
================================================
import SwiftUI

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
struct ImageFlow: View {
  private enum Item: Hashable {
    case image(RawImageData)
    case lineBreak
  }

  private let items: [Indexed<Item>]

  var body: some View {
    TextStyleAttributesReader { attributes in
      let spacing = RelativeSize.rem(0.25).points(relativeTo: attributes.fontProperties)

      FlowLayout(horizontalSpacing: spacing, verticalSpacing: spacing) {
        ForEach(self.items, id: \.self) { item in
          switch item.value {
          case .image(let data):
            ImageView(data: data)
          case .lineBreak:
            Spacer()
          }
        }
      }
    }
  }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension ImageFlow {
  init?(_ inlines: [InlineNode]) {
    var items: [Item] = []

    for inline in inlines {
      switch inline {
      case let .text(text) where text.isEmpty:
        continue
      case .softBreak:
        continue
      case .lineBreak:
        items.append(.lineBreak)
      case let .image(source, children):
        items.append(.image(.init(source: source, alt: children.renderPlainText())))
      case let .link(destination, children) where children.count == 1:
        guard var data = children.first?.imageData else {
          return nil
        }
        data.destination = destination
        items.append(.image(data))
      default:
        return nil
      }
    }

    self.items = items.indexed()
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/ListItemSequence.swift
================================================
import SwiftUI

struct ListItemSequence: View {
  private let items: [RawListItem]
  private let start: Int
  private let markerStyle: BlockStyle<ListMarkerConfiguration>
  private let markerWidth: CGFloat?

  init(
    items: [RawListItem],
    start: Int = 1,
    markerStyle: BlockStyle<ListMarkerConfiguration>,
    markerWidth: CGFloat? = nil
  ) {
    self.items = items
    self.start = start
    self.markerStyle = markerStyle
    self.markerWidth = markerWidth
  }

  var body: some View {
    BlockSequence(self.items) { index, item in
      ListItemView(
        item: item,
        number: self.start + index,
        markerStyle: self.markerStyle,
        markerWidth: self.markerWidth
      )
    }
    .labelStyle(.titleAndIcon)
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/ListItemView.swift
================================================
import SwiftUI

struct ListItemView: View {
  @Environment(\.theme.listItem) private var listItem
  @Environment(\.listLevel) private var listLevel

  private let item: RawListItem
  private let number: Int
  private let markerStyle: BlockStyle<ListMarkerConfiguration>
  private let markerWidth: CGFloat?

  init(
    item: RawListItem,
    number: Int,
    markerStyle: BlockStyle<ListMarkerConfiguration>,
    markerWidth: CGFloat?
  ) {
    self.item = item
    self.number = number
    self.markerStyle = markerStyle
    self.markerWidth = markerWidth
  }

  var body: some View {
    self.listItem.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(blocks: item.children)
      )
    )
  }

  private var label: some View {
    Label {
      BlockSequence(self.item.children)
    } icon: {
      self.markerStyle
        .makeBody(configuration: .init(listLevel: self.listLevel, itemNumber: self.number))
        .textStyleFont()
        .readWidth(column: 0)
        .frame(width: self.markerWidth, alignment: .trailing)
    }
    #if os(visionOS)
      .labelStyle(BulletItemStyle())
    #endif
  }
}

extension VerticalAlignment {
  private enum CenterOfFirstLine: AlignmentID {
    static func defaultValue(in context: ViewDimensions) -> CGFloat {
      let heightAfterFirstLine = context[.lastTextBaseline] - context[.firstTextBaseline]
      let heightOfFirstLine = context.height - heightAfterFirstLine
      return heightOfFirstLine / 2
    }
  }
  static let centerOfFirstLine = Self(CenterOfFirstLine.self)
}

struct BulletItemStyle: LabelStyle {
  func makeBody(configuration: Configuration) -> some View {
    HStack(alignment: .centerOfFirstLine, spacing: 4) {
      configuration.icon
      configuration.title
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/NumberedListView.swift
================================================
import SwiftUI

struct NumberedListView: View {
  @Environment(\.theme.list) private var list
  @Environment(\.theme.numberedListMarker) private var numberedListMarker
  @Environment(\.listLevel) private var listLevel

  @State private var markerWidth: CGFloat?

  private let isTight: Bool
  private let start: Int
  private let items: [RawListItem]

  init(isTight: Bool, start: Int, items: [RawListItem]) {
    self.isTight = isTight
    self.start = start
    self.items = items
  }

  var body: some View {
    self.list.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(
          block: .numberedList(
            isTight: self.isTight,
            start: self.start,
            items: self.items
          )
        )
      )
    )
  }

  private var label: some View {
    ListItemSequence(
      items: self.items,
      start: self.start,
      markerStyle: self.numberedListMarker,
      markerWidth: self.markerWidth
    )
    .environment(\.listLevel, self.listLevel + 1)
    .environment(\.tightSpacingEnabled, self.isTight)
    .onColumnWidthChange { columnWidths in
      self.markerWidth = columnWidths[0]
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/ParagraphView.swift
================================================
import SwiftUI

struct ParagraphView: View {
  @Environment(\.theme.paragraph) private var paragraph

  private let content: [InlineNode]

  init(content: String) {
    self.init(
      content: [
        .text(content.hasSuffix("\n") ? String(content.dropLast()) : content)
      ]
    )
  }

  init(content: [InlineNode]) {
    self.content = content
  }

  var body: some View {
    self.paragraph.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(block: .paragraph(content: self.content))
      )
    )
  }

  @ViewBuilder private var label: some View {
    if let imageView = ImageView(content) {
      imageView
    } else if #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *),
      let imageFlow = ImageFlow(content)
    {
      imageFlow
    } else {
      InlineText(content)
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TableBackgroundView.swift
================================================
import SwiftUI

struct TableBackgroundView: View {
  @Environment(\.tableBackgroundStyle) private var tableBackgroundStyle

  private let tableBounds: TableBounds

  init(tableBounds: TableBounds) {
    self.tableBounds = tableBounds
  }

  var body: some View {
    ZStack(alignment: .topLeading) {
      ForEach(0..<self.tableBounds.rowCount, id: \.self) { row in
        ForEach(0..<self.tableBounds.columnCount, id: \.self) { column in
          let bounds = self.tableBounds.bounds(forRow: row, column: column)

          Rectangle()
            .fill(self.tableBackgroundStyle.background(row, column))
            .offset(x: bounds.minX, y: bounds.minY)
            .frame(width: bounds.width, height: bounds.height)
        }
      }
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TableBorderSelector.swift
================================================
import SwiftUI

/// A type that selects the visible borders on a Markdown table.
///
/// You use a table border selector to select the visible borders when creating a ``TableBorderStyle``.
public struct TableBorderSelector {
  var rectangles: (_ tableBounds: TableBounds, _ borderWidth: CGFloat) -> [CGRect]
}

extension TableBorderSelector {
  /// A table border selector that selects the outside borders of a table.
  public static var outsideBorders: TableBorderSelector {
    TableBorderSelector { tableBounds, borderWidth in
      [tableBounds.bounds]
    }
  }

  /// A table border selector that selects the inside borders of a table.
  public static var insideBorders: TableBorderSelector {
    TableBorderSelector { tableBounds, borderWidth in
      Self.insideHorizontalBorders.rectangles(tableBounds, borderWidth)
        + Self.insideVerticalBorders.rectangles(tableBounds, borderWidth)
    }
  }

  /// A table border selector that selects the inside horizontal borders of a table.
  public static var insideHorizontalBorders: TableBorderSelector {
    TableBorderSelector { tableBounds, borderWidth in
      (0..<tableBounds.rowCount - 1)
        .map {
          tableBounds.bounds(forRow: $0)
            .insetBy(dx: -borderWidth, dy: -borderWidth)
        }
        .map {
          CGRect(
            origin: .init(x: $0.minX, y: $0.maxY - borderWidth),
            size: .init(width: $0.width, height: borderWidth)
          )
        }
    }
  }

  /// A table border selector that selects the inside vertical borders of a table.
  public static var insideVerticalBorders: TableBorderSelector {
    TableBorderSelector { tableBounds, borderWidth in
      (0..<tableBounds.columnCount - 1)
        .map {
          tableBounds.bounds(forColumn: $0)
            .insetBy(dx: -borderWidth, dy: -borderWidth)
        }
        .map {
          CGRect(
            origin: .init(x: $0.maxX - borderWidth, y: $0.minY),
            size: .init(width: borderWidth, height: $0.height)
          )
        }
    }
  }

  /// A table border selector that selects the horizontal borders of a table.
  public static var horizontalBorders: TableBorderSelector {
    TableBorderSelector { tableBounds, borderWidth in
      Self.outsideHorizontalBorders.rectangles(tableBounds, borderWidth)
        + Self.insideHorizontalBorders.rectangles(tableBounds, borderWidth)
    }
  }

  /// A table border selector that selects all the borders of a table.
  public static var allBorders: TableBorderSelector {
    TableBorderSelector { tableBounds, borderWidth in
      Self.insideBorders.rectangles(tableBounds, borderWidth)
        + Self.outsideBorders.rectangles(tableBounds, borderWidth)
    }
  }
}

extension TableBorderSelector {
  fileprivate static var outsideHorizontalBorders: TableBorderSelector {
    TableBorderSelector { tableBounds, borderWidth in
      [
        CGRect(
          origin: .init(x: tableBounds.bounds.minX, y: tableBounds.bounds.minY),
          size: .init(width: tableBounds.bounds.width, height: borderWidth)
        ),
        CGRect(
          origin: .init(x: tableBounds.bounds.minX, y: tableBounds.bounds.maxY - borderWidth),
          size: .init(width: tableBounds.bounds.width, height: borderWidth)
        ),
      ]
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TableBorderView.swift
================================================
import SwiftUI

struct TableBorderView: View {
  @Environment(\.tableBorderStyle) private var tableBorderStyle

  private let tableBounds: TableBounds

  init(tableBounds: TableBounds) {
    self.tableBounds = tableBounds
  }

  var body: some View {
    ZStack(alignment: .topLeading) {
      let rectangles = self.tableBorderStyle.visibleBorders.rectangles(
        self.tableBounds, self.borderWidth
      )
      ForEach(0..<rectangles.count, id: \.self) {
        let rectangle = rectangles[$0]
        Rectangle()
          .strokeBorder(self.tableBorderStyle.color, style: self.tableBorderStyle.strokeStyle)
          .offset(x: rectangle.minX, y: rectangle.minY)
          .frame(width: rectangle.width, height: rectangle.height)
      }
    }
  }

  private var borderWidth: CGFloat {
    self.tableBorderStyle.strokeStyle.lineWidth
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TableBounds.swift
================================================
import SwiftUI

struct TableBounds {
  var rowCount: Int {
    self.rows.count
  }

  var columnCount: Int {
    self.columns.count
  }

  let bounds: CGRect

  private let rows: [(minY: CGFloat, height: CGFloat)]
  private let columns: [(minX: CGFloat, width: CGFloat)]

  fileprivate init(
    rowCount: Int,
    columnCount: Int,
    anchors: [TableCellIndex: Anchor<CGRect>],
    proxy: GeometryProxy
  ) {
    var rows = Array(
      repeating: (minY: CGFloat.greatestFiniteMagnitude, height: CGFloat(0)),
      count: rowCount
    )
    var columns = Array(
      repeating: (minX: CGFloat.greatestFiniteMagnitude, width: CGFloat(0)),
      count: columnCount
    )

    for row in 0..<rowCount {
      for column in 0..<columnCount {
        guard let anchor = anchors[TableCellIndex(row: row, column: column)] else {
          continue
        }

        let bounds = proxy[anchor]

        rows[row].minY = min(rows[row].minY, bounds.minY)
        rows[row].height = max(rows[row].height, bounds.height)

        columns[column].minX = min(columns[column].minX, bounds.minX)
        columns[column].width = max(columns[column].width, bounds.width)
      }
    }

    self.bounds = proxy.frame(in: .local)
    self.rows = rows
    self.columns = columns
  }

  func bounds(forRow row: Int, column: Int) -> CGRect {
    CGRect(
      origin: .init(x: self.columns[column].minX, y: self.rows[row].minY),
      size: .init(width: self.columns[column].width, height: self.rows[row].height)
    )
  }

  func bounds(forRow row: Int) -> CGRect {
    (0..<self.columnCount)
      .map { self.bounds(forRow: row, column: $0) }
      .reduce(.null, CGRectUnion)
  }

  func bounds(forColumn column: Int) -> CGRect {
    (0..<self.rowCount)
      .map { self.bounds(forRow: $0, column: column) }
      .reduce(.null, CGRectUnion)
  }
}

extension View {
  func tableCellBounds(forRow row: Int, column: Int) -> some View {
    self.anchorPreference(key: TableCellBoundsPreference.self, value: .bounds) { anchor in
      [TableCellIndex(row: row, column: column): anchor]
    }
  }

  func tableDecoration<Background, Overlay>(
    rowCount: Int,
    columnCount: Int,
    background: @escaping (TableBounds) -> Background,
    overlay: @escaping (TableBounds) -> Overlay
  ) -> some View where Background: View, Overlay: View {
    self
      .backgroundPreferenceValue(TableCellBoundsPreference.self) { anchors in
        GeometryReader { proxy in
          background(
            .init(
              rowCount: rowCount,
              columnCount: columnCount,
              anchors: anchors,
              proxy: proxy
            )
          )
        }
      }
      .overlayPreferenceValue(TableCellBoundsPreference.self) { anchors in
        GeometryReader { proxy in
          overlay(
            .init(
              rowCount: rowCount,
              columnCount: columnCount,
              anchors: anchors,
              proxy: proxy
            )
          )
        }
      }
  }
}

private struct TableCellIndex: Hashable {
  var row: Int
  var column: Int
}

private struct TableCellBoundsPreference: PreferenceKey {
  static let defaultValue: [TableCellIndex: Anchor<CGRect>] = [:]

  static func reduce(
    value: inout [TableCellIndex: Anchor<CGRect>],
    nextValue: () -> [TableCellIndex: Anchor<CGRect>]
  ) {
    value.merge(nextValue()) { $1 }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TableCell.swift
================================================
import SwiftUI

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
struct TableCell: View {
  @Environment(\.theme.tableCell) private var tableCell

  private let row: Int
  private let column: Int
  private let cell: RawTableCell

  init(row: Int, column: Int, cell: RawTableCell) {
    self.row = row
    self.column = column
    self.cell = cell
  }

  var body: some View {
    self.tableCell.makeBody(
      configuration: .init(
        row: self.row,
        column: self.column,
        label: .init(self.label),
        content: .init(block: .paragraph(content: cell.content))
      )
    )
    .tableCellBounds(forRow: self.row, column: self.column)
  }

  @ViewBuilder private var label: some View {
    if let imageFlow = ImageFlow(self.cell.content) {
      imageFlow
    } else {
      InlineText(self.cell.content)
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TableView.swift
================================================
import SwiftUI

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
struct TableView: View {
  @Environment(\.theme.table) private var table
  @Environment(\.tableBorderStyle.strokeStyle.lineWidth) private var borderWidth

  private let columnAlignments: [RawTableColumnAlignment]
  private let rows: [RawTableRow]

  init(columnAlignments: [RawTableColumnAlignment], rows: [RawTableRow]) {
    self.columnAlignments = columnAlignments
    self.rows = rows
  }

  var body: some View {
    self.table.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(block: .table(columnAlignments: self.columnAlignments, rows: self.rows))
      )
    )
  }

  private var label: some View {
    Grid(horizontalSpacing: self.borderWidth, verticalSpacing: self.borderWidth) {
      ForEach(0..<self.rowCount, id: \.self) { row in
        GridRow {
          ForEach(0..<self.columnCount, id: \.self) { column in
            TableCell(row: row, column: column, cell: self.rows[row].cells[column])
              .gridColumnAlignment(.init(self.columnAlignments[column]))
          }
        }
      }
    }
    .padding(self.borderWidth)
    .tableDecoration(
      rowCount: self.rowCount,
      columnCount: self.columnCount,
      background: TableBackgroundView.init,
      overlay: TableBorderView.init
    )
  }

  private var rowCount: Int {
    self.rows.count
  }

  private var columnCount: Int {
    self.columnAlignments.count
  }
}

extension HorizontalAlignment {
  fileprivate init(_ rawTableColumnAlignment: RawTableColumnAlignment) {
    switch rawTableColumnAlignment {
    case .none, .left:
      self = .leading
    case .center:
      self = .center
    case .right:
      self = .trailing
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TaskListItemView.swift
================================================
import SwiftUI

struct TaskListItemView: View {
  @Environment(\.theme.listItem) private var listItem
  @Environment(\.theme.taskListMarker) private var taskListMarker

  private let item: RawTaskListItem

  init(item: RawTaskListItem) {
    self.item = item
  }

  var body: some View {
    self.listItem.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(blocks: item.children)
      )
    )
  }

  private var label: some View {
    Label {
      BlockSequence(self.item.children)
    } icon: {
      self.taskListMarker.makeBody(configuration: .init(isCompleted: self.item.isCompleted))
        .textStyleFont()
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TaskListView.swift
================================================
import SwiftUI

struct TaskListView: View {
  @Environment(\.theme.list) private var list
  @Environment(\.listLevel) private var listLevel

  private let isTight: Bool
  private let items: [RawTaskListItem]

  init(isTight: Bool, items: [RawTaskListItem]) {
    self.isTight = isTight
    self.items = items
  }

  var body: some View {
    self.list.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(block: .taskList(isTight: self.isTight, items: self.items))
      )
    )
  }

  private var label: some View {
    BlockSequence(self.items) { _, item in
      TaskListItemView(item: item)
    }
    .labelStyle(.titleAndIcon)
    .environment(\.listLevel, self.listLevel + 1)
    .environment(\.tightSpacingEnabled, self.isTight)
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/TextStyleAttributesReader.swift
================================================
import SwiftUI

struct TextStyleAttributesReader<Content: View>: View {
  @Environment(\.textStyle) private var textStyle

  private let content: (AttributeContainer) -> Content

  init(@ViewBuilder content: @escaping (_ attributes: AttributeContainer) -> Content) {
    self.content = content
  }

  var body: some View {
    self.content(self.attributes)
  }

  private var attributes: AttributeContainer {
    var attributes = AttributeContainer()
    self.textStyle._collectAttributes(in: &attributes)
    return attributes
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Blocks/ThematicBreakView.swift
================================================
import SwiftUI

struct ThematicBreakView: View {
  @Environment(\.theme.thematicBreak) private var thematicBreak

  var body: some View {
    self.thematicBreak.makeBody(configuration: ())
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+BaseURL.swift
================================================
import SwiftUI

extension EnvironmentValues {
  var baseURL: URL? {
    get { self[BaseURLKey.self] }
    set { self[BaseURLKey.self] = newValue }
  }

  var imageBaseURL: URL? {
    get { self[ImageBaseURLKey.self] }
    set { self[ImageBaseURLKey.self] = newValue }
  }
}

private struct BaseURLKey: EnvironmentKey {
  static var defaultValue: URL? = nil
}

private struct ImageBaseURLKey: EnvironmentKey {
  static var defaultValue: URL? = nil
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+CodeSyntaxHighlighter.swift
================================================
import SwiftUI

extension View {
  /// Sets the code syntax highlighter for the Markdown code blocks in a view hierarchy.
  /// - Parameter codeSyntaxHighlighter: The code syntax highlighter to set. Use
  ///                                    ``CodeSyntaxHighlighter/plainText`` or a custom syntax
  ///                                    highlighter that you define by creating a type that conforms to the
  ///                                    ``CodeSyntaxHighlighter`` protocol.
  /// - Returns: A view that uses the specified code syntax highlighter for itself and its
  ///            child views.
  public func markdownCodeSyntaxHighlighter(
    _ codeSyntaxHighlighter: CodeSyntaxHighlighter
  ) -> some View {
    self.environment(\.codeSyntaxHighlighter, codeSyntaxHighlighter)
  }
}

extension EnvironmentValues {
  var codeSyntaxHighlighter: CodeSyntaxHighlighter {
    get { self[CodeSyntaxHighlighterKey.self] }
    set { self[CodeSyntaxHighlighterKey.self] = newValue }
  }
}

private struct CodeSyntaxHighlighterKey: EnvironmentKey {
  static let defaultValue: CodeSyntaxHighlighter = .plainText
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+ImageProvider.swift
================================================
import SwiftUI

extension View {
  /// Sets the image provider for the Markdown images in a view hierarchy.
  /// - Parameter imageProvider: The image provider to set. Use one of the built-in values, like
  ///                            ``ImageProvider/default`` or ``ImageProvider/asset``,
  ///                            or a custom image provider that you define by creating a type that
  ///                            conforms to the ``ImageProvider`` protocol.
  /// - Returns: A view that uses the specified image provider for itself and its child views.
  public func markdownImageProvider<I: ImageProvider>(_ imageProvider: I) -> some View {
    self.environment(\.imageProvider, .init(imageProvider))
  }
}

extension EnvironmentValues {
  var imageProvider: AnyImageProvider {
    get { self[ImageProviderKey.self] }
    set { self[ImageProviderKey.self] = newValue }
  }
}

private struct ImageProviderKey: EnvironmentKey {
  static let defaultValue: AnyImageProvider = .init(.default)
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+InlineImageProvider.swift
================================================
import SwiftUI

extension View {
  /// Sets the inline image provider for the Markdown inline images in a view hierarchy.
  /// - Parameter inlineImageProvider: The inline image provider to set. Use one of the built-in values, like
  ///                                  ``InlineImageProvider/default`` or ``InlineImageProvider/asset``,
  ///                                  or a custom inline image provider that you define by creating a type that
  ///                                  conforms to the ``InlineImageProvider`` protocol.
  /// - Returns: A view that uses the specified inline image provider for itself and its child views.
  public func markdownInlineImageProvider(_ inlineImageProvider: InlineImageProvider) -> some View {
    self.environment(\.inlineImageProvider, inlineImageProvider)
  }
}

extension EnvironmentValues {
  var inlineImageProvider: InlineImageProvider {
    get { self[InlineImageProviderKey.self] }
    set { self[InlineImageProviderKey.self] = newValue }
  }
}

private struct InlineImageProviderKey: EnvironmentKey {
  static let defaultValue: InlineImageProvider = .default
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+List.swift
================================================
import SwiftUI

extension EnvironmentValues {
  var listLevel: Int {
    get { self[ListLevelKey.self] }
    set { self[ListLevelKey.self] = newValue }
  }

  var tightSpacingEnabled: Bool {
    get { self[TightSpacingEnabledKey.self] }
    set { self[TightSpacingEnabledKey.self] = newValue }
  }
}

private struct ListLevelKey: EnvironmentKey {
  static var defaultValue = 0
}

private struct TightSpacingEnabledKey: EnvironmentKey {
  static var defaultValue = false
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+SoftBreakMode.swift
================================================
import SwiftUI

extension View {
  /// Sets the soft break mode for inline texts in a view hierarchy.
  ///
  /// - parameter softBreakMode: If set to `space`, treats all soft breaks as spaces, keeping sentences whole. If set to `lineBreak`, treats soft breaks as full line breaks
  ///
  /// - Returns: A view that uses the specified soft break mode for itself and its child views.
  public func markdownSoftBreakMode(_ softBreakMode: SoftBreak.Mode) -> some View {
    self.environment(\.softBreakMode, softBreakMode)
  }
}

extension EnvironmentValues {
  var softBreakMode: SoftBreak.Mode {
    get { self[SoftBreakModeKey.self] }
    set { self[SoftBreakModeKey.self] = newValue }
  }
}

private struct SoftBreakModeKey: EnvironmentKey {
  static let defaultValue: SoftBreak.Mode = .space
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+Table.swift
================================================
import SwiftUI

extension View {
  /// Sets the table border style for the Markdown tables in a view hierarchy.
  ///
  /// Use this modifier to customize the table border style inside the body of
  /// the ``Theme/table`` block style.
  ///
  /// - Parameter tableBorderStyle: The border style to set.
  public func markdownTableBorderStyle(_ tableBorderStyle: TableBorderStyle) -> some View {
    self.environment(\.tableBorderStyle, tableBorderStyle)
  }

  /// Sets the table background style for the Markdown tables in a view hierarchy.
  ///
  /// Use this modifier to customize the table background style inside the body of
  /// the ``Theme/table`` block style.
  ///
  /// - Parameter tableBackgroundStyle: The background style to set.
  public func markdownTableBackgroundStyle(
    _ tableBackgroundStyle: TableBackgroundStyle
  ) -> some View {
    self.environment(\.tableBackgroundStyle, tableBackgroundStyle)
  }
}

extension EnvironmentValues {
  var tableBorderStyle: TableBorderStyle {
    get { self[TableBorderStyleKey.self] }
    set { self[TableBorderStyleKey.self] = newValue }
  }

  var tableBackgroundStyle: TableBackgroundStyle {
    get { self[TableBackgroundStyleKey.self] }
    set { self[TableBackgroundStyleKey.self] = newValue }
  }
}

private struct TableBorderStyleKey: EnvironmentKey {
  static let defaultValue = TableBorderStyle(color: .secondary)
}

private struct TableBackgroundStyleKey: EnvironmentKey {
  static let defaultValue = TableBackgroundStyle.clear
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+TextStyle.swift
================================================
import SwiftUI

extension View {
  /// Sets the default text style for the Markdown inlines in a view hierarchy.
  ///
  /// Use this modifier inside a ``BlockStyle`` `body` block to customize
  /// the default text style for the block's Markdown inlines.
  ///
  /// - Parameter textStyle: A text style builder that returns the text style to use.
  public func markdownTextStyle<S: TextStyle>(
    @TextStyleBuilder textStyle: @escaping () -> S
  ) -> some View {
    self.transformEnvironment(\.textStyle) {
      $0 = $0.appending(textStyle())
    }
  }

  func textStyleFont() -> some View {
    TextStyleAttributesReader { attributes in
      self.font(attributes.fontProperties.map(Font.withProperties))
    }
  }

  func textStyleForegroundColor() -> some View {
    TextStyleAttributesReader { attributes in
      self.foregroundColor(attributes.foregroundColor)
    }
  }

  func textStyle(_ textStyle: TextStyle) -> some View {
    self.transformEnvironment(\.textStyle) {
      $0 = $0.appending(textStyle)
    }
  }
}

extension TextStyle {
  @TextStyleBuilder fileprivate func appending<S: TextStyle>(
    _ textStyle: S
  ) -> some TextStyle {
    self
    textStyle
  }
}

extension EnvironmentValues {
  fileprivate(set) var textStyle: TextStyle {
    get { self[TextStyleKey.self] }
    set { self[TextStyleKey.self] = newValue }
  }
}

private struct TextStyleKey: EnvironmentKey {
  static let defaultValue: TextStyle = FontProperties()
}



================================================
FILE: Sources/MarkdownUI/Views/Environment/Environment+Theme.swift
================================================
import SwiftUI

extension View {
  /// Sets the current ``Theme`` for the Markdown contents in a view hierarchy.
  /// - Parameter theme: The theme to set.
  public func markdownTheme(_ theme: Theme) -> some View {
    self.environment(\.theme, theme)
  }

  /// Replaces a specific text style of the current ``Theme`` with the given text style.
  /// - Parameters:
  ///   - keyPath: The ``Theme`` key path to the text style to replace.
  ///   - textStyle: A text style builder that returns the new text style to use for the given key path.
  public func markdownTextStyle<S: TextStyle>(
    _ keyPath: WritableKeyPath<Theme, TextStyle>,
    @TextStyleBuilder textStyle: () -> S
  ) -> some View {
    self.environment((\EnvironmentValues.theme).appending(path: keyPath), textStyle())
  }

  /// Replaces a specific block style on the current ``Theme`` with a block style initialized with the given body closure.
  /// - Parameters:
  ///   - keyPath: The ``Theme`` key path to the block style to replace.
  ///   - body: A view builder that returns the customized block.
  public func markdownBlockStyle<Body: View>(
    _ keyPath: WritableKeyPath<Theme, BlockStyle<Void>>,
    @ViewBuilder body: @escaping () -> Body
  ) -> some View {
    self.environment((\EnvironmentValues.theme).appending(path: keyPath), .init(body: body))
  }

  /// Replaces a specific block style on the current ``Theme`` with a block style initialized with the given body closure.
  /// - Parameters:
  ///   - keyPath: The ``Theme`` key path to the block style to replace.
  ///   - body: A view builder that receives the block configuration and returns the customized block.
  public func markdownBlockStyle<Configuration, Body: View>(
    _ keyPath: WritableKeyPath<Theme, BlockStyle<Configuration>>,
    @ViewBuilder body: @escaping (_ configuration: Configuration) -> Body
  ) -> some View {
    self.environment((\EnvironmentValues.theme).appending(path: keyPath), .init(body: body))
  }

  /// Replaces the current ``Theme`` task list marker with the given list marker.
  public func markdownTaskListMarker(
    _ value: BlockStyle<TaskListMarkerConfiguration>
  ) -> some View {
    self.environment(\.theme.taskListMarker, value)
  }

  /// Replaces the current ``Theme`` bulleted list marker with the given list marker.
  public func markdownBulletedListMarker(
    _ value: BlockStyle<ListMarkerConfiguration>
  ) -> some View {
    self.environment(\.theme.bulletedListMarker, value)
  }

  /// Replaces the current ``Theme`` numbered list marker with the given list marker.
  public func markdownNumberedListMarker(
    _ value: BlockStyle<ListMarkerConfiguration>
  ) -> some View {
    self.environment(\.theme.numberedListMarker, value)
  }
}

extension EnvironmentValues {
  var theme: Theme {
    get { self[ThemeKey.self] }
    set { self[ThemeKey.self] = newValue }
  }
}

private struct ThemeKey: EnvironmentKey {
  static let defaultValue: Theme = .basic
}



================================================
FILE: Sources/MarkdownUI/Views/Inlines/ImageView.swift
================================================
import SwiftUI

struct ImageView: View {
  @Environment(\.theme.image) private var image
  @Environment(\.imageProvider) private var imageProvider
  @Environment(\.imageBaseURL) private var baseURL

  private let data: RawImageData

  init(data: RawImageData) {
    self.data = data
  }

  var body: some View {
    self.image.makeBody(
      configuration: .init(
        label: .init(self.label),
        content: .init(block: self.content)
      )
    )
  }

  private var label: some View {
    self.imageProvider.makeImage(url: self.url)
      .link(destination: self.data.destination)
      .accessibilityLabel(self.data.alt)
  }

  private var content: BlockNode {
    if let destination = self.data.destination {
      return .paragraph(
        content: [
          .link(
            destination: destination,
            children: [.image(source: self.data.source, children: [.text(self.data.alt)])]
          )
        ]
      )
    } else {
      return .paragraph(
        content: [.image(source: self.data.source, children: [.text(self.data.alt)])]
      )
    }
  }

  private var url: URL? {
    URL(string: self.data.source, relativeTo: self.baseURL)
  }
}

extension ImageView {
  init?(_ inlines: [InlineNode]) {
    guard inlines.count == 1, let data = inlines.first?.imageData else {
      return nil
    }
    self.init(data: data)
  }
}

extension View {
  fileprivate func link(destination: String?) -> some View {
    self.modifier(LinkModifier(destination: destination))
  }
}

private struct LinkModifier: ViewModifier {
  @Environment(\.baseURL) private var baseURL
  @Environment(\.openURL) private var openURL

  let destination: String?

  var url: URL? {
    self.destination.flatMap {
      URL(string: $0, relativeTo: self.baseURL)
    }
  }

  func body(content: Content) -> some View {
    if let url {
      Button {
        self.openURL(url)
      } label: {
        content
      }
      .buttonStyle(.plain)
    } else {
      content
    }
  }
}



================================================
FILE: Sources/MarkdownUI/Views/Inlines/InlineText.swift
================================================
import SwiftUI

struct InlineText: View {
  @Environment(\.inlineImageProvider) private var inlineImageProvider
  @Environment(\.baseURL) private var baseURL
  @Environment(\.imageBaseURL) private var imageBaseURL
  @Environment(\.softBreakMode) private var softBreakMode
  @Environment(\.theme) private var theme

  @State private var inlineImages: [String: Image] = [:]

  private let inlines: [InlineNode]

  init(_ inlines: [InlineNode]) {
    self.inlines = inlines
  }

  var body: some View {
    TextStyleAttributesReader { attributes in
      self.inlines.renderText(
        baseURL: self.baseURL,
        textStyles: .init(
          code: self.theme.code,
          emphasis: self.theme.emphasis,
          strong: self.theme.strong,
          strikethrough: self.theme.strikethrough,
          link: self.theme.link
        ),
        images: self.inlineImages,
        softBreakMode: self.softBreakMode,
        attributes: attributes
      )
    }
    .task(id: self.inlines) {
      self.inlineImages = (try? await self.loadInlineImages()) ?? [:]
    }
  }

  private func loadInlineImages() async throws -> [String: Image] {
    let images = Set(self.inlines.compactMap(\.imageData))
    guard !images.isEmpty else { return [:] }

    return try await withThrowingTaskGroup(of: (String, Image).self) { taskGroup in
      for image in images {
        guard let url = URL(string: image.source, relativeTo: self.imageBaseURL) else {
          continue
        }

        taskGroup.addTask {
          (image.source, try await self.inlineImageProvider.image(with: url, label: image.alt))
        }
      }

      var inlineImages: [String: Image] = [:]

      for try await result in taskGroup {
        inlineImages[result.0] = result.1
      }

      return inlineImages
    }
  }
}



================================================
FILE: Tests/MarkdownUITests/FontPropertiesTests.swift
================================================
#if !os(tvOS)
  import SwiftUI
  import XCTest

  @testable import MarkdownUI

  final class FontPropertiesTests: XCTestCase {
    func testFontWithProperties() {
      // given
      var fontProperties = FontProperties()

      // then
      XCTAssertEqual(
        Font.system(size: FontProperties.defaultSize, design: .default),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(family: .custom("Menlo"))

      // then
      XCTAssertEqual(
        Font.custom("Menlo", fixedSize: FontProperties.defaultSize),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(familyVariant: .monospaced)

      // then
      XCTAssertEqual(
        Font.system(size: FontProperties.defaultSize, design: .default).monospaced(),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(capsVariant: .lowercaseSmallCaps)

      // then
      XCTAssertEqual(
        Font.system(size: FontProperties.defaultSize, design: .default).lowercaseSmallCaps(),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(digitVariant: .monospaced)

      // then
      XCTAssertEqual(
        Font.system(size: FontProperties.defaultSize, design: .default).monospacedDigit(),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(style: .italic)

      // then
      XCTAssertEqual(
        Font.system(size: FontProperties.defaultSize, design: .default).italic(),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(weight: .heavy)

      // then
      XCTAssertEqual(
        Font.system(size: FontProperties.defaultSize, design: .default).weight(.heavy),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(size: 42)

      // then
      XCTAssertEqual(
        Font.system(size: 42, design: .default),
        Font.withProperties(fontProperties)
      )

      // when
      fontProperties = FontProperties(scale: 1.5)

      // then
      XCTAssertEqual(
        Font.system(size: round(FontProperties.defaultSize * 1.5), design: .default),
        Font.withProperties(fontProperties)
      )
    }
  }
#endif



================================================
FILE: Tests/MarkdownUITests/HTMLTagTests.swift
================================================
import Foundation
import XCTest

@testable import MarkdownUI

final class HTMLTagTests: XCTestCase {
  func testInvalidTag() {
    XCTAssertNil(HTMLTag(""))
    XCTAssertNil(HTMLTag("foo"))
    XCTAssertNil(HTMLTag("<"))
    XCTAssertNil(HTMLTag("<>"))
  }

  func testOpeningTag() {
    // given
    let tag = HTMLTag("<sub>")

    // then
    XCTAssertEqual("sub", tag?.name)
  }

  func testOpeningTagWithAttributes() {
    // given
    let tag = HTMLTag(
      "<img src=\"img_girl.jpg\" alt=\"Girl in a jacket\" width=\"500\" height=\"600\">"
    )

    // then
    XCTAssertEqual("img", tag?.name)
  }

  func testClosingTag() {
    let tag = HTMLTag("</sub>")
    XCTAssertEqual(tag?.name, "sub")
  }

  func testSelfClosingTag() {
    XCTAssertEqual("br", HTMLTag("<br />")?.name)
  }
}



================================================
FILE: Tests/MarkdownUITests/InlineContentBuilderTests.swift
================================================
import Foundation
import XCTest

@testable import MarkdownUI

final class InlineContentBuilderTests: XCTestCase {
  func testEmpty() {
    // given
    @InlineContentBuilder func build() -> InlineContent {}

    // when
    let result = build()

    // then
    XCTAssertEqual(.init(), result)
  }

  func testExpressions() {
    // given
    @InlineContentBuilder func build() -> InlineContent {
      "Hello"
      SoftBreak()
      "world!"
      LineBreak()
      Code("let a = b")
      Strikethrough {
        "This is a "
        Strong("mistake, ")
        Emphasis("right?")
      }
      InlineLink("Hurricane", destination: URL(string: "https://w.wiki/qYn")!)
      InlineImage("Puppy", source: URL(string: "https://picsum.photos/id/237/200/300")!)
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      InlineContent(
        inlines: [
          .text("Hello"),
          .softBreak,
          .text("world!"),
          .lineBreak,
          .code("let a = b"),
          .strikethrough(
            children: [
              .text("This is a "),
              .strong(children: [.text("mistake, ")]),
              .emphasis(children: [.text("right?")]),
            ]
          ),
          .link(destination: "https://w.wiki/qYn", children: [.text("Hurricane")]),
          .image(source: "https://picsum.photos/id/237/200/300", children: [.text("Puppy")]),
        ]
      ),
      result
    )
  }

  func testForLoops() {
    // given
    @InlineContentBuilder func build() -> InlineContent {
      for i in 0...3 {
        "\(i)"
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      InlineContent(
        inlines: [
          .text("0"),
          .text("1"),
          .text("2"),
          .text("3"),
        ]
      ),
      result
    )
  }

  func testIf() {
    @InlineContentBuilder func build() -> InlineContent {
      "Something is "
      if true {
        Emphasis {
          "true"
        }
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      InlineContent(
        inlines: [
          .text("Something is "),
          .emphasis(children: [.text("true")]),
        ]
      ),
      result
    )
  }

  func testIfElse() {
    @InlineContentBuilder func build(_ value: Bool) -> InlineContent {
      "Something is "
      if value {
        Emphasis {
          "true"
        }
      } else {
        "false"
      }
    }

    // when
    let result1 = build(true)
    let result2 = build(false)

    // then
    XCTAssertEqual(
      InlineContent(
        inlines: [
          .text("Something is "),
          .emphasis(children: [.text("true")]),
        ]
      ),
      result1
    )
    XCTAssertEqual(
      InlineContent(
        inlines: [
          .text("Something is "),
          .text("false"),
        ]
      ),
      result2
    )
  }
}



================================================
FILE: Tests/MarkdownUITests/ListContentBuilderTests.swift
================================================
import Foundation
import XCTest

@testable import MarkdownUI

final class ListContentBuilderTests: XCTestCase {
  func testEmpty() {
    // given
    @ListContentBuilder func build() -> [ListItem] {}

    // when
    let result = build()

    // then
    XCTAssertEqual([], result)
  }

  func testExpressions() {
    // given
    @ListContentBuilder func build() -> [ListItem] {
      "Flour"
      ListItem {
        "Cheese"
      }
      ListItem {
        Paragraph {
          "Tomatoes"
        }
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      [
        .init(children: [.paragraph(content: [.text("Flour")])]),
        .init(children: [.paragraph(content: [.text("Cheese")])]),
        .init(children: [.paragraph(content: [.text("Tomatoes")])]),
      ],
      result
    )
  }

  func testForLoops() {
    // given
    @ListContentBuilder func build() -> [ListItem] {
      for i in 0...3 {
        "\(i)"
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      [
        .init(children: [.paragraph(content: [.text("0")])]),
        .init(children: [.paragraph(content: [.text("1")])]),
        .init(children: [.paragraph(content: [.text("2")])]),
        .init(children: [.paragraph(content: [.text("3")])]),
      ],
      result
    )
  }

  func testIf() {
    @ListContentBuilder func build() -> [ListItem] {
      "Something is:"
      if true {
        ListItem {
          "true"
        }
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      [
        .init(children: [.paragraph(content: [.text("Something is:")])]),
        .init(children: [.paragraph(content: [.text("true")])]),
      ],
      result
    )
  }

  func testIfElse() {
    @ListContentBuilder func build(_ value: Bool) -> [ListItem] {
      "Something is:"
      if value {
        ListItem {
          "true"
        }
      } else {
        "false"
      }
    }

    // when
    let result1 = build(true)
    let result2 = build(false)

    // then
    XCTAssertEqual(
      [
        .init(children: [.paragraph(content: [.text("Something is:")])]),
        .init(children: [.paragraph(content: [.text("true")])]),
      ],
      result1
    )
    XCTAssertEqual(
      [
        .init(children: [.paragraph(content: [.text("Something is:")])]),
        .init(children: [.paragraph(content: [.text("false")])]),
      ],
      result2
    )
  }
}



================================================
FILE: Tests/MarkdownUITests/MarkdownContentBuilderTests.swift
================================================
import Foundation
import XCTest

@testable import MarkdownUI

final class MarkdownContentBuilderTests: XCTestCase {
  func testEmpty() {
    // given
    @MarkdownContentBuilder func build() -> MarkdownContent {}

    // when
    let result = build()

    // then
    XCTAssertEqual(.init(), result)
  }

  func testExpressions() {
    // given
    @MarkdownContentBuilder func build() -> MarkdownContent {
      "**First** paragraph."
      Paragraph {
        Strong("Second")
        " paragraph."
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      MarkdownContent(
        blocks: [
          .paragraph(
            content: [
              .strong(children: [.text("First")]),
              .text(" paragraph."),
            ]
          ),
          .paragraph(
            content: [
              .strong(children: [.text("Second")]),
              .text(" paragraph."),
            ]
          ),
        ]
      ),
      result
    )
  }

  func testForLoops() {
    // given
    @MarkdownContentBuilder func build() -> MarkdownContent {
      for i in 0...3 {
        "\(i)"
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      MarkdownContent(
        blocks: [
          .paragraph(content: [.text("0")]),
          .paragraph(content: [.text("1")]),
          .paragraph(content: [.text("2")]),
          .paragraph(content: [.text("3")]),
        ]
      ),
      result
    )
  }

  func testIf() {
    @MarkdownContentBuilder func build() -> MarkdownContent {
      "Something is:"
      if true {
        "true"
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      MarkdownContent(
        blocks: [
          .paragraph(content: [.text("Something is:")]),
          .paragraph(content: [.text("true")]),
        ]
      ),
      result
    )
  }

  func testIfElse() {
    @MarkdownContentBuilder func build(_ value: Bool) -> MarkdownContent {
      "Something is:"
      if value {
        "true"
      } else {
        "false"
      }
    }

    // when
    let result1 = build(true)
    let result2 = build(false)

    // then
    XCTAssertEqual(
      MarkdownContent(
        blocks: [
          .paragraph(content: [.text("Something is:")]),
          .paragraph(content: [.text("true")]),
        ]
      ),
      result1
    )
    XCTAssertEqual(
      MarkdownContent(
        blocks: [
          .paragraph(content: [.text("Something is:")]),
          .paragraph(content: [.text("false")]),
        ]
      ),
      result2
    )
  }
}



================================================
FILE: Tests/MarkdownUITests/MarkdownContentTests.swift
================================================
import MarkdownUI
import XCTest

final class MarkdownContentTests: XCTestCase {
  func testEmpty() {
    // when
    let content = MarkdownContent("")

    // then
    XCTAssertEqual(MarkdownContent {}, content)
    XCTAssertEqual("", content.renderMarkdown())
  }

  func testBlockquote() {
    // given
    let markdown = """
      > Hello
      >\u{20}
      > > World
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Blockquote {
          "Hello"
          Blockquote {
            "World"
          }
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testList() {
    // given
    let markdown = """
      1.  one
      2.  two
            - nested 1
            - nested 2
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        NumberedList {
          "one"
          ListItem {
            "two"
            BulletedList {
              "nested 1"
              "nested 2"
            }
          }
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testLooseList() {
    // given
    let markdown = """
      9.  one

      10. two
      \u{20}\u{20}\u{20}\u{20}
            - nested 1
            - nested 2
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        NumberedList(tight: false, start: 9) {
          "one"
          ListItem {
            "two"
            BulletedList {
              "nested 1"
              "nested 2"
            }
          }
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testTaskList() {
    // given
    let markdown = """
      - [ ] one
      - [x] two
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        TaskList {
          "one"
          TaskListItem(isCompleted: true) {
            "two"
          }
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testCodeBlock() {
    // given
    let markdown = """
      ``` swift
      let a = 5
      let b = 42
      ```
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        CodeBlock(language: "swift") {
          """
          let a = 5
          let b = 42

          """
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testParagraph() {
    // given
    let markdown = "Hello world\\!"

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Hello world!"
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testHeading() {
    // given
    let markdown = """
      # Hello

      ## World
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Heading {
          "Hello"
        }
        Heading(.level2) {
          "World"
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testTable() throws {
    guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
      throw XCTSkip("Required API is not available for this test")
    }

    // given
    let markdown = """
      |Default|Leading|Center|Trailing|
      | --- | :-- | :-: | --: |
      |git status|git status|git status|git status|
      |git diff|git diff|git diff|git diff|
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        TextTable {
          TextTableColumn<[String]>(title: "Default", value: \.[0])
          TextTableColumn(alignment: .leading, title: "Leading", value: \.[1])
          TextTableColumn(alignment: .center, title: "Center", value: \.[2])
          TextTableColumn(alignment: .trailing, title: "Trailing", value: \.[3])
        } rows: {
          TextTableRow(Array(repeating: "git status", count: 4))
          TextTableRow(Array(repeating: "git diff", count: 4))
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testThematicBreak() {
    // given
    let markdown = """
      Foo

      -----

      Bar
      """

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        "Foo"
        ThematicBreak()
        "Bar"
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testSoftBreak() {
    // given
    let markdown = "Hello\nWorld"

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Hello"
          SoftBreak()
          "World"
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testLineBreak() {
    // given
    let markdown = "Hello  \nWorld"

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Hello"
          LineBreak()
          "World"
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testCode() {
    // given
    let markdown = "Returns `nil`."

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Returns "
          Code("nil")
          "."
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testEmphasis() {
    // given
    let markdown = "Hello *world*."

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Hello "
          Emphasis("world")
          "."
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testStrong() {
    // given
    let markdown = "Hello **world**."

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Hello "
          Strong("world")
          "."
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testStrikethrough() {
    // given
    let markdown = "Hello ~~world~~."

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Hello "
          Strikethrough("world")
          "."
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testLink() {
    // given
    let markdown = "Hello [world](https://example.com)."

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          "Hello "
          InlineLink("world", destination: URL(string: "https://example.com")!)
          "."
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }

  func testImage() {
    // given
    let markdown = "![Puppy](https://picsum.photos/id/237/200/300)"

    // when
    let content = MarkdownContent(markdown)

    // then
    XCTAssertEqual(
      MarkdownContent {
        Paragraph {
          InlineImage("Puppy", source: URL(string: "https://picsum.photos/id/237/200/300")!)
        }
      },
      content
    )
    XCTAssertEqual(markdown, content.renderMarkdown())
  }
}



================================================
FILE: Tests/MarkdownUITests/MarkdownImageTests.swift
================================================
#if os(iOS)
  import SnapshotTesting
  import SwiftUI
  import XCTest

  import MarkdownUI

  final class MarkdownImageTests: XCTestCase {
    private let layout = SwiftUISnapshotLayout.device(config: .iPhone8)

    override func setUpWithError() throws {
      try XCTSkipIf(UIDevice.current.userInterfaceIdiom == .pad, "Skipping on Mac Catalyst")
    }

    func testFailingImage() {
      let view = Markdown {
        #"""
        An image that fails to load:

        ![](https://picsum.photos/500/300)

        ― Photo by André Spieker
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testRelativeImage() {
      let view = Markdown(baseURL: URL(string: "https://example.com/picsum/")) {
        #"""
        500x300 image:

        ![](237-500x300)

        ― Photo by André Spieker
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownImageProvider(
        AssetImageProvider(
          name: { url in
            XCTAssertEqual(
              URL(string: "237-500x300", relativeTo: URL(string: "https://example.com/picsum/"))!,
              url
            )
            return url.lastPathComponent
          },
          bundle: .module
        )
      )

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testImageLink() {
      let view = Markdown {
        #"""
        A link that contains an image instead of text:

        [![](https://example.com/picsum/237-100x150)](https://example.com)

        ― Photo by André Spieker
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownImageProvider(AssetImageProvider(bundle: .module))

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testMultipleImages() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Required API is not available for this test")
      }

      let view = Markdown {
        #"""
        [![](https://example.com/picsum/237-100x150)](https://example.com)
        ![](https://example.com/picsum/237-125x75)
        ![](https://example.com/picsum/237-500x300)
        ![](https://example.com/picsum/237-100x150)\#u{20}\#u{20}
        ![](https://example.com/picsum/237-125x75)

        ― Photo by André Spieker
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownImageProvider(AssetImageProvider(bundle: .module))

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testMultipleImagesSize() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Required API is not available for this test")
      }

      let view = Markdown {
        #"""
        ![](https://example.com/picsum/237-100x150)
        ![](https://example.com/picsum/237-125x75)

        ― Photo by André Spieker
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownImageProvider(AssetImageProvider(bundle: .module))

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testColorScheme() {
      let content = """
        This image is contextualized for either dark or light mode:

        ![](https://example.com/picsum/237-100x150#gh-dark-mode-only)
        ![](https://example.com/picsum/237-125x75#gh-light-mode-only)

        ― Photo by André Spieker
        """

      let view = VStack {
        Markdown(content)
          .background()
          .colorScheme(.light)
          .border(Color.accentColor)
          .padding()
        Markdown(content)
          .background()
          .colorScheme(.dark)
          .border(Color.accentColor)
          .padding()
      }
      .markdownImageProvider(AssetImageProvider(bundle: .module))

      assertSnapshot(of: view, as: .image(layout: layout))
    }
  }
#endif



================================================
FILE: Tests/MarkdownUITests/MarkdownListTests.swift
================================================
#if os(iOS)
  import SnapshotTesting
  import SwiftUI
  import XCTest

  import MarkdownUI

  final class MarkdownListTests: XCTestCase {
    private let layout = SwiftUISnapshotLayout.device(config: .iPhone8)

    override func setUpWithError() throws {
      try XCTSkipIf(UIDevice.current.userInterfaceIdiom == .pad, "Skipping on Mac Catalyst")
    }

    func testTaskList() {
      let view = Markdown {
        #"""
        - [x] A finished task
        - [ ] An unfinished task
        - [ ] Another unfinished task
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testBulletedList() {
      let view = Markdown {
        #"""
        * Systems
          * FFF units
          * Great Underground Empire (Zork)
          * Potrzebie
            * Equals the thickness of Mad issue 26
              * Developed by 19-year-old Donald E. Knuth
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testBulletedDashedList() {
      let view = Markdown {
        #"""
        * Systems
          * FFF units
          * Great Underground Empire (Zork)
          * Potrzebie
            * Equals the thickness of Mad issue 26
              * Developed by 19-year-old Donald E. Knuth
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownBulletedListMarker(.dash)

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testNumberedList() {
      let view = Markdown {
        #"""
        This is an incomplete list of headgear:

        1. Hats
        1. Caps
        1. Bonnets

        Some more:

        10. Helmets
        1. Hoods
        1. Headbands, headscarves, wimples

        A list with a high start:

        999. The sky above the port was the color of television, tuned to a dead channel.
        1. It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testRomanNumberedList() {
      let view = Markdown {
        #"""
        This is an incomplete list of headgear:

        1. Hats
        1. Caps
        1. Bonnets

        A list with a high start:

        999. The sky above the port was the color of television, tuned to a dead channel.
        1. It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownNumberedListMarker(.lowerRoman)

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testLooseList() {
      let view = Markdown {
        #"""
        A loose list:

        1. Hats

        1. Caps

        1. Bonnets

        Another loose list:

        1. Hats
        1. Caps
        1. Bonnets

           This paragraph makes the list loose.
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }
  }

#endif



================================================
FILE: Tests/MarkdownUITests/MarkdownTableTests.swift
================================================
#if os(iOS)
  import SnapshotTesting
  import SwiftUI
  import XCTest

  import MarkdownUI

  final class MarkdownTableTests: XCTestCase {
    private let layout = SwiftUISnapshotLayout.device(config: .iPhone8)
    private let perceptualPrecision: Float = 0.98

    func testTable() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Table rendering is not available")
      }

      let view = Markdown {
        #"""
        A table with some padding:

        | Command | Description |
        | --- | --- |
        | git status | List all new or modified files |
        | git diff | Show file differences that haven't been staged |
        """#
      }
      .padding()
      .border(Color.accentColor)

      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testTableAlignment() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Table rendering is not available")
      }

      let view = Markdown {
        #"""
        A table with some padding:

        | Default    | Leading    | Center     | Trailing   |
        | ---        | :---       |    :---:   |       ---: |
        | git status | git status | git status | git status |
        | git diff   | git diff   | git diff   | git diff   |
        """#
      }
      .padding()
      .border(Color.accentColor)

      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testTableWithImages() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Table rendering is not available")
      }

      let view = Markdown {
        #"""
        A table with some padding:

        | First Header  | Second Header |
        | --- | --- |
        | ![](https://example.com/picsum/237-100x150) | ![](https://example.com/picsum/237-125x75) |
        | ![](https://example.com/picsum/237-500x300) | ![](https://example.com/picsum/237-100x150) |

        ― Photo by André Spieker
        """#
      }
      .padding()
      .border(Color.accentColor)
      .markdownImageProvider(AssetImageProvider(bundle: .module))

      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testEmptyTable() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Table rendering is not available")
      }

      let view = Markdown {
        #"""
        A table with some padding:

        | First Header  | Second Header |
        | ------------- | ------------- |
        """#
      }
      .padding()
      .border(Color.accentColor)

      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testTableSize() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Table rendering is not available")
      }

      let view = Markdown {
        #"""
        A table with some padding:

        | First Header  | Second Header |
        | ------------- | ------------- |
        | Content Cell  | Content Cell  |
        | Content Cell  | Content Cell  |
        """#
      }
      .padding()
      .border(Color.accentColor)

      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testTableBackground() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Table rendering is not available")
      }

      let view = Markdown {
        #"""
        A table with some padding:

        | Command | Description |
        | --- | --- |
        | git status | List all new or modified files |
        | git diff | Show file differences that haven't been staged |
        """#
      }
      .padding()
      .border(Color.accentColor)
      .markdownBlockStyle(\.table) { configuration in
        configuration.label
          .markdownMargin(top: .zero, bottom: .em(1))
          .markdownTableBackgroundStyle(
            .alternatingRows(Color.clear, Color(.secondarySystemBackground), header: .mint)
          )
      }

      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testTableBorder() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Table rendering is not available")
      }

      let view = Markdown {
        #"""
        A table with some padding:

        | Command | Description |
        | --- | --- |
        | git status | List all new or modified files |
        | git diff | Show file differences that haven't been staged |
        """#
      }
      .padding()
      .border(Color.accentColor)
      .markdownBlockStyle(\.table) { configuration in
        configuration.label
          .markdownMargin(top: .zero, bottom: .em(1))
          .markdownTableBorderStyle(
            .init(
              .outsideBorders,
              color: Color.mint,
              strokeStyle: .init(lineWidth: 2, lineJoin: .round, dash: [4])
            )
          )
      }

      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }
  }
#endif



================================================
FILE: Tests/MarkdownUITests/MarkdownTests.swift
================================================
#if os(iOS)
  import SnapshotTesting
  import SwiftUI
  import XCTest

  import MarkdownUI

  final class MarkdownTests: XCTestCase {
    private let layout = SwiftUISnapshotLayout.device(config: .iPhone8)

    override func setUpWithError() throws {
      try XCTSkipIf(UIDevice.current.userInterfaceIdiom == .pad, "Skipping on Mac Catalyst")
    }

    func testBlockquote() {
      let view = Markdown {
        #"""
        If you'd like to quote someone, use the > character before the line.
        Blockquotes can be nested, and can also contain other formatting.

        > “Well, art is art, isn't it? Still,
        > on the other hand, water is water!
        > And east is east and west is west and
        > if you take cranberries and stew them
        > like applesauce they taste much more
        > like prunes than rhubarb does. Now,
        > uh... now you tell me what you
        > know.”
        > > “I sent the club a wire stating,
        > > **PLEASE ACCEPT MY RESIGNATION. I DON'T
        > > WANT TO BELONG TO ANY CLUB THAT WILL ACCEPT ME AS A MEMBER**.”
        > > > “Outside of a dog, a book is man's best friend. Inside of a
        > > > dog it's too dark to read.”

        ― Groucho Marx
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testCodeBlock() {
      let view = Markdown {
        #"""
        Use a group to collect multiple views into a single instance,
        without affecting the layout of those views. After creating a
        group, any modifier you apply to the group affects all of that
        group’s members.

        ```swift
        Group {
            Text("SwiftUI")
            Text("Combine")
            Text("Swift System")
        }
        .font(.headline)
        ```

        ― From Apple Developer Documentation
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testVerbatimHTML() {
      let view = Markdown {
        #"""
        A `Markdown` view ignores HTML blocks and renders
        them as verbatim text.

        <p>
        You can use Markdown syntax instead.
        </p>

        The same happens with <strong>HTML inlines</strong>.
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testOpenCodeBlock() {
      let view = Markdown {
        #"""
        An empty code block without a closing fence:

        ```swift
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testParagraphs() {
      let view = Markdown {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.

        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testCenteredParagraphs() {
      let view = Markdown {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.

        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      .border(Color.accentColor)
      .padding()
      .multilineTextAlignment(.center)

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testTrailingParagraphs() {
      let view = Markdown {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.

        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      .border(Color.accentColor)
      .padding()
      .multilineTextAlignment(.trailing)

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testSpacing() {
      let view = Markdown {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.

        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownBlockStyle(\.paragraph) { configuration in
        configuration.label
          .markdownMargin(bottom: .zero)
      }

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testHeadings() {
      let view = Markdown {
        #"""
        # Heading 1
        The sky above the port was the color of television, tuned to a dead channel.
        ## Heading 2
        The sky above the port was the color of television, tuned to a dead channel.
        ### Heading 3
        The sky above the port was the color of television, tuned to a dead channel.
        #### Heading 4
        The sky above the port was the color of television, tuned to a dead channel.
        ##### Heading 5
        The sky above the port was the color of television, tuned to a dead channel.
        ###### Heading 6
        The sky above the port was the color of television, tuned to a dead channel.
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testThematicBreak() {
      let view = Markdown {
        #"""
        # SwiftUI

        Declare the user interface and behavior for your app
        on every platform.

        ---

        ## Overview

        SwiftUI provides views, controls, and layout structures
        for declaring your app’s user interface.

        ---

        ― From Apple Developer Documentation
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testInlines() {
      let view = Markdown {
        #"""
        **This is bold text**

        *This text is italicized*

        ~~This was mistaken text~~

        **This text is _extremely_ important**

        ***All this text is important***

        MarkdownUI is fully compliant with the [CommonMark Spec](https://spec.commonmark.org/current/).

        Visit https://github.com.

        Use `git status` to list all new or modified files that haven't yet been committed.

        You can insert a line break<br>
        using the HTML `<br>`
        <br>      tag.
        """#
      }
      .border(Color.accentColor)
      .padding()

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testInlinesStyling() {
      let view = Markdown {
        #"""
        **This is bold text**

        *This text is italicized*

        ~~This was mistaken text~~

        **This text is _extremely_ important**

        **_All this text is important_**

        MarkdownUI is fully compliant with the [CommonMark Spec](https://spec.commonmark.org/current/).

        Visit https://github.com.

        Use `git status` to list all new or modified files that haven't yet been committed.
        """#
      }
      .border(Color.accentColor)
      .padding()
      .markdownTextStyle(\.code) {
        FontFamilyVariant(.monospaced)
        BackgroundColor(.yellow)
      }
      .markdownTextStyle(\.strong) {
        FontWeight(.heavy)
      }
      .markdownTextStyle(\.emphasis) {
        FontStyle(.italic)
        UnderlineStyle(.single)
      }
      .markdownTextStyle(\.strikethrough) {
        ForegroundColor(.primary)
        BackgroundColor(.primary)
      }
      .markdownTextStyle(\.link) {
        UnderlineStyle(.init(pattern: .dot))
      }

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testSoftBreakModeSpace() {
      let view = Markdown {
        #"""
        # This is a heading

        Item 1
        Item 2
        Item 3
        Item 4

        I would **very much** like to write
        A long paragraph that spans _multiple lines_
        But should ~~render differently~~ based on
        soft break mode
        """#
      }
      .markdownSoftBreakMode(.space)

      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testSoftBreakModeLineBreak() {
      let view = Markdown {
        #"""
        # This is a heading

        Item 1
        Item 2
        Item 3
        Item 4

        I would **very much** like to write
        A long paragraph that spans _multiple lines_
        But should ~~render differently~~ based on
        soft break mode
        """#
      }
      .markdownSoftBreakMode(.lineBreak)

      assertSnapshot(of: view, as: .image(layout: layout))
    }
  }
#endif



================================================
FILE: Tests/MarkdownUITests/TaskListContentBuilderTests.swift
================================================
import Foundation
import XCTest

@testable import MarkdownUI

final class TaskListContentBuilderTests: XCTestCase {
  func testEmpty() {
    // given
    @TaskListContentBuilder func build() -> [TaskListItem] {}

    // when
    let result = build()

    // then
    XCTAssertEqual([], result)
  }

  func testExpressions() {
    // given
    @TaskListContentBuilder func build() -> [TaskListItem] {
      "Flour"
      TaskListItem(isCompleted: true) {
        "Cheese"
      }
      TaskListItem {
        Paragraph {
          "Tomatoes"
        }
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      [
        .init(isCompleted: false, children: [.paragraph(content: [.text("Flour")])]),
        .init(isCompleted: true, children: [.paragraph(content: [.text("Cheese")])]),
        .init(isCompleted: false, children: [.paragraph(content: [.text("Tomatoes")])]),
      ],
      result
    )
  }

  func testForLoops() {
    // given
    @TaskListContentBuilder func build() -> [TaskListItem] {
      for i in 0...3 {
        "\(i)"
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      [
        .init(isCompleted: false, children: [.paragraph(content: [.text("0")])]),
        .init(isCompleted: false, children: [.paragraph(content: [.text("1")])]),
        .init(isCompleted: false, children: [.paragraph(content: [.text("2")])]),
        .init(isCompleted: false, children: [.paragraph(content: [.text("3")])]),
      ],
      result
    )
  }

  func testIf() {
    @TaskListContentBuilder func build() -> [TaskListItem] {
      "Something is:"
      if true {
        TaskListItem(isCompleted: true) {
          "true"
        }
      }
    }

    // when
    let result = build()

    // then
    XCTAssertEqual(
      [
        .init(isCompleted: false, children: [.paragraph(content: [.text("Something is:")])]),
        .init(isCompleted: true, children: [.paragraph(content: [.text("true")])]),
      ],
      result
    )
  }

  func testIfElse() {
    @TaskListContentBuilder func build(_ value: Bool) -> [TaskListItem] {
      "Something is:"
      if value {
        TaskListItem(isCompleted: true) {
          "true"
        }
      } else {
        "false"
      }
    }

    // when
    let result1 = build(true)
    let result2 = build(false)

    // then
    XCTAssertEqual(
      [
        .init(isCompleted: false, children: [.paragraph(content: [.text("Something is:")])]),
        .init(isCompleted: true, children: [.paragraph(content: [.text("true")])]),
      ],
      result1
    )
    XCTAssertEqual(
      [
        .init(isCompleted: false, children: [.paragraph(content: [.text("Something is:")])]),
        .init(isCompleted: false, children: [.paragraph(content: [.text("false")])]),
      ],
      result2
    )
  }
}



================================================
FILE: Tests/MarkdownUITests/TextStyleBuilderTests.swift
================================================
import MarkdownUI
import SwiftUI
import XCTest

final class TextStyleBuilderTests: XCTestCase {
  func testBuildEmpty() {
    // given
    @TextStyleBuilder func build() -> some TextStyle {}
    let textStyle = build()

    // when
    var attributes = AttributeContainer()
    textStyle._collectAttributes(in: &attributes)

    // then
    XCTAssertEqual(AttributeContainer(), attributes)
  }

  func testBuildOne() {
    // given
    @TextStyleBuilder func build() -> some TextStyle {
      ForegroundColor(.primary)
    }
    let textStyle = build()

    // when
    var attributes = AttributeContainer()
    textStyle._collectAttributes(in: &attributes)

    // then
    XCTAssertEqual(AttributeContainer().foregroundColor(.primary), attributes)
  }

  func testBuildMany() {
    // given
    @TextStyleBuilder func build() -> some TextStyle {
      ForegroundColor(.primary)
      BackgroundColor(.cyan)
      UnderlineStyle(.single)
    }
    let textStyle = build()

    // when
    var attributes = AttributeContainer()
    textStyle._collectAttributes(in: &attributes)

    // then
    XCTAssertEqual(
      AttributeContainer()
        .foregroundColor(.primary)
        .backgroundColor(.cyan)
        .underlineStyle(.single),
      attributes
    )
  }

  func testBuildOptional() {
    // given
    @TextStyleBuilder func makeTextStyle(_ condition: Bool) -> some TextStyle {
      ForegroundColor(.primary)
      if condition {
        BackgroundColor(.cyan)
      }
    }
    let textStyle1 = makeTextStyle(true)
    let textStyle2 = makeTextStyle(false)

    // when
    var attributes1 = AttributeContainer()
    textStyle1._collectAttributes(in: &attributes1)
    var attributes2 = AttributeContainer()
    textStyle2._collectAttributes(in: &attributes2)

    // then
    XCTAssertEqual(
      AttributeContainer()
        .foregroundColor(.primary)
        .backgroundColor(.cyan),
      attributes1
    )
    XCTAssertEqual(
      AttributeContainer()
        .foregroundColor(.primary),
      attributes2
    )
  }

  func testBuildEither() {
    // given
    @TextStyleBuilder func makeTextStyle(_ condition: Bool) -> some TextStyle {
      ForegroundColor(.primary)
      if condition {
        BackgroundColor(.cyan)
      } else {
        UnderlineStyle(.single)
      }
    }
    let textStyle1 = makeTextStyle(true)
    let textStyle2 = makeTextStyle(false)

    // when
    var attributes1 = AttributeContainer()
    textStyle1._collectAttributes(in: &attributes1)
    var attributes2 = AttributeContainer()
    textStyle2._collectAttributes(in: &attributes2)

    // then
    XCTAssertEqual(
      AttributeContainer()
        .foregroundColor(.primary)
        .backgroundColor(.cyan),
      attributes1
    )
    XCTAssertEqual(
      AttributeContainer()
        .foregroundColor(.primary)
        .underlineStyle(.single),
      attributes2
    )
  }
}



================================================
FILE: Tests/MarkdownUITests/ThemeDocCTests.swift
================================================
#if os(iOS)
  import SnapshotTesting
  import SwiftUI
  import XCTest

  import MarkdownUI

  final class ThemeDocCTests: XCTestCase {
    private let layout = SwiftUISnapshotLayout.device(config: .iPhone8)

    override func setUpWithError() throws {
      try XCTSkipIf(UIDevice.current.userInterfaceIdiom == .pad, "Skipping on Mac Catalyst")
    }

    func testInlines() {
      let view = ThemePreview(theme: .docC) {
        #"""
        **This is bold text**

        *This text is italicized*

        ~~This was mistaken text~~

        **This text is _extremely_ important**

        MarkdownUI is fully compliant with the [CommonMark Spec](https://spec.commonmark.org/current/).

        Use `git status` to list all new or modified files that haven't yet been committed.
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testHeadings() {
      let view = ThemePreview(theme: .docC, colorScheme: .light) {
        #"""
        Paragraph.
        # Heading 1
        Paragraph.
        ## Heading 2
        Paragraph.
        ### Heading 3
        Paragraph.
        #### Heading 4
        Paragraph.
        ##### Heading 5
        Paragraph.
        ###### Heading 6
        Paragraph.
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testParagraph() {
      let view = ThemePreview(theme: .docC, colorScheme: .light) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.

        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testBlockquote() {
      let view = ThemePreview(theme: .docC) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        > Outside of a dog, a book is man's best friend. Inside of a dog it's too dark to read.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testCodeBlock() {
      let view = ThemePreview(theme: .docC) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        ```swift
        struct Sightseeing: Activity {
            func perform(with sloth: inout Sloth) -> Speed {
                sloth.energyLevel -= 10
                return .slow
            }
        }
        ```

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testImage() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Required API is not available for this test")
      }

      let view = ThemePreview(theme: .docC, colorScheme: .light) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        ![](https://example.com/picsum/237-100x150)

        It was a bright cold day in April, and the clocks were striking thirteen.

        ![](https://example.com/picsum/237-100x150)
        ![](https://example.com/picsum/237-125x75)

        ― Photo by André Spieker
        """#
      }
      .markdownImageProvider(AssetImageProvider(bundle: .module))
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testList() {
      let view = ThemePreview(theme: .docC, colorScheme: .light) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        * Systems
          * FFF units
          * Great Underground Empire (Zork)
          * Potrzebie
            * Equals the thickness of Mad issue 26
              * Developed by 19-year-old Donald E. Knuth

        It was a bright cold day in April, and the clocks were striking thirteen.

        10. Helmets
        1. Hoods
        1. Headbands, headscarves, wimples

        The sky above the port was the color of television, tuned to a dead channel.

        - [x] A finished task
        - [ ] An unfinished task
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testTable() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Required API is not available for this test")
      }

      let view = ThemePreview(theme: .docC) {
        #"""
        Add tables of data:

        | Sloth speed  | Description                           |
        | ------------ | ------------------------------------- |
        | `slow`       | Moves slightly faster than a snail.   |
        | `medium`     | Moves at an average speed.            |
        | `fast`       | Moves faster than a hare.             |
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }

    func testThematicBreak() {
      let view = ThemePreview(theme: .docC) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        ---

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(of: view, as: .image(layout: layout))
    }
  }

#endif



================================================
FILE: Tests/MarkdownUITests/ThemeGitHubTests.swift
================================================
#if os(iOS)
  import SnapshotTesting
  import SwiftUI
  import XCTest

  import MarkdownUI

  final class ThemeGitHubTests: XCTestCase {
    private let layout = SwiftUISnapshotLayout.device(config: .iPhone8)
    private let perceptualPrecision: Float = 0.97

    override func setUpWithError() throws {
      try XCTSkipIf(UIDevice.current.userInterfaceIdiom == .pad, "Skipping on Mac Catalyst")
    }

    func testInlines() {
      let view = ThemePreview(theme: .gitHub) {
        #"""
        **This is bold text**

        *This text is italicized*

        ~~This was mistaken text~~

        **This text is _extremely_ important**

        MarkdownUI is fully compliant with the [CommonMark Spec](https://spec.commonmark.org/current/).

        Use `git status` to list all new or modified files that haven't yet been committed.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testHeadings() {
      let view = ThemePreview(theme: .gitHub, colorScheme: .light) {
        #"""
        Paragraph.
        # Heading 1
        Paragraph.
        ## Heading 2
        Paragraph.
        ### Heading 3
        Paragraph.
        #### Heading 4
        Paragraph.
        ##### Heading 5
        Paragraph.
        ###### Heading 6
        Paragraph.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testHeadingsColors() {
      let view = ThemePreview(theme: .gitHub) {
        #"""
        # Heading 1
        Paragraph.
        ## Heading 2
        Paragraph.
        ###### Heading 6
        Paragraph.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testParagraph() {
      let view = ThemePreview(theme: .gitHub, colorScheme: .light) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.

        The sky above the port was the color of television, tuned to a dead channel.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testBlockquote() {
      let view = ThemePreview(theme: .gitHub) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        > Outside of a dog, a book is man's best friend. Inside of a dog it's too dark to read.

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testCodeBlock() {
      let view = ThemePreview(theme: .gitHub) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        ```swift
        struct Sightseeing: Activity {
            func perform(with sloth: inout Sloth) -> Speed {
                sloth.energyLevel -= 10
                return .slow
            }
        }
        ```

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testTaskList() {
      let view = ThemePreview(theme: .gitHub) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        - [x] A finished task
        - [ ] An unfinished task
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testList() {
      let view = ThemePreview(theme: .gitHub, colorScheme: .light) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        * Systems
          * FFF units
          * Great Underground Empire (Zork)
          * Potrzebie
            * Equals the thickness of Mad issue 26
              * Developed by 19-year-old Donald E. Knuth

        It was a bright cold day in April, and the clocks were striking thirteen.

        10. Helmets
        1. Hoods
        1. Headbands, headscarves, wimples

        The sky above the port was the color of television, tuned to a dead channel.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testTable() throws {
      guard #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) else {
        throw XCTSkip("Required API is not available for this test")
      }

      let view = ThemePreview(theme: .gitHub) {
        #"""
        Add tables of data:

        | Sloth speed  | Description                           |
        | ------------ | ------------------------------------- |
        | `slow`       | Moves slightly faster than a snail.   |
        | `medium`     | Moves at an average speed.            |
        | `fast`       | Moves faster than a hare.             |
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }

    func testThematicBreak() {
      let view = ThemePreview(theme: .gitHub) {
        #"""
        The sky above the port was the color of television, tuned to a dead channel.

        ---

        It was a bright cold day in April, and the clocks were striking thirteen.
        """#
      }
      assertSnapshot(
        of: view, as: .image(perceptualPrecision: perceptualPrecision, layout: layout)
      )
    }
  }
#endif



================================================
FILE: Tests/MarkdownUITests/ThemePreview.swift
================================================
import MarkdownUI
import SwiftUI

struct ThemePreview: View {
  private let theme: Theme
  private let colorSchemes: [ColorScheme]
  private let content: () -> MarkdownContent

  init(
    theme: Theme,
    colorSchemes: [ColorScheme] = ColorScheme.allCases,
    @MarkdownContentBuilder content: @escaping () -> MarkdownContent
  ) {
    self.theme = theme
    self.colorSchemes = colorSchemes
    self.content = content
  }

  init(
    theme: Theme,
    colorScheme: ColorScheme,
    @MarkdownContentBuilder content: @escaping () -> MarkdownContent
  ) {
    self.init(theme: theme, colorSchemes: [colorScheme], content: content)
  }

  var body: some View {
    VStack {
      ForEach(self.colorSchemes, id: \.self) { colorScheme in
        Markdown(content: self.content)
          .padding()
          .background()
          .colorScheme(colorScheme)
      }
    }
    .markdownTheme(self.theme)
    .padding()
  }
}



================================================
FILE: Tests/MarkdownUITests/Resources/Images.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Tests/MarkdownUITests/Resources/Images.xcassets/237-100x150.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "237-100x150.jpg",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Tests/MarkdownUITests/Resources/Images.xcassets/237-125x75.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "237-125x75.jpg",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: Tests/MarkdownUITests/Resources/Images.xcassets/237-500x300.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "237-500x300.jpg",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: .github/CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[INSERT CONTACT METHOD].
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

Thank you for contributing to MarkdownUI!

Before you submit an issue, please complete the report with all the relevant details for your bug and go through every item in the checklist.

**Describe the bug**
A clear and concise description of what the bug is.

**Checklist**
- [ ] I can reproduce this issue with a vanilla SwiftUI project.
- [ ] I can reproduce this issue using the `main` branch of this package.
- [ ] This bug hasn't been addressed in an [existing GitHub issue](https://github.com/gonzalezreal/swift-markdown-ui/issues).

**Steps to reproduce**
Explanation of how to reproduce the incorrect behavior. This could include an attached project, a link to code, or a Markdown-formatted text exhibiting the issue.
1. ...

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Version information**
- MarkdownUI: [e.g. 2.0.0, or a commit hash]
- OS: [e.g. iOS 15, macOS 13]
- Xcode: [e.g. 14.2.0]

**Additional context**
Add any other context about the problem here.



================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
blank_issues_enabled: false

contact_links:
  - name: Discussion
    url: https://github.com/gonzalezreal/swift-markdown-ui/discussions
    about: MarkdownUI Q&A, ideas, and more
  - name: Documentation
    url: https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui/2.0.0/documentation/markdownui
    about: MarkdownUI documentation



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - '*'
jobs:
  tests:
    runs-on: macos-12
    steps:
      - uses: actions/checkout@v2
      - name: Select Xcode 14.2
        run: sudo xcode-select -s /Applications/Xcode_14.2.app
      - name: Run tests
        run: make test



================================================
FILE: .github/workflows/format.yml
================================================
name: Format
on:
  push:
    branches:
      - main
jobs:
  format:
    name: swift-format
    runs-on: macos-13
    steps:
      - uses: actions/checkout@v4
      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_15.0.app
      - name: Install
        run: brew install swift-format
      - name: Format
        run: make format
      - uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: Run swift format
          branch: 'main'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


